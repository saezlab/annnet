{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"annnet \u2014 Annotated Network Data Structures for Science","text":"<p>annnet (Annotated Network) is a unified, high\u2011expressivity graph platform that brings anndata\u2011style, annotated containers to networks, multilayer structures, and hypergraphs.</p> <p>Use it for systems/network biology, omics integration, and any domain needing flexible graph semantics with stable, lossless storage and excellent interoperability.</p>"},{"location":"#why-annnet","title":"Why annnet?","text":"<ul> <li>Maximum graph expressiveness: hyperedges; directed/undirected per\u2011edge; parallel edges; self\u2011loops; vertex\u2013edge and edge\u2013edge relations; graph/edge\u2011level semantics.</li> <li>Multilayer networks: layers, aspects, inter\u2011layer edges.</li> <li>Powerful slicing: create subnetworks, clusters, arbitrary \u201cslices\u201d; switch active slice.</li> <li>Annotated tables: Polars\u2011backed tables for vertices, edges, layers, slices, metadata.</li> <li>Interoperability: NetworkX/igraph/graph\u2011tool via lazy proxies; file IO for GraphML, GEXF, SIF, SBML, CX2, Parquet GraphDir, JSON/Excel/DataFrames.</li> <li>Disk\u2011backed, lossless <code>.annnet</code> storage using Zarr + Parquet + JSON.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>import annnet as an\n\nG = an.Graph(directed=True)\nG.add_slice(\"toy\")\nG.slices.active = \"toy\"\nfor v in [\"A\", \"B\", \"C\", \"D\"]:\n    G.add_vertex(v, label=v, kind=\"gene\")\n\nG.add_edge(\"A\", \"B\", weight=2.0, edge_directed=True, relation=\"activates\")\nG.add_edge(\"B\", \"C\", weight=1.0, edge_directed=False, relation=\"binds\")\nG.add_hyperedge(head=[\"A\", \"B\"], tail=[\"C\", \"D\"], weight=1.0)\n\n# NetworkX algorithm (if installed)\ndeg = G.nx.degree_centrality(G)\n</code></pre> <p>See Get Started \u2192 Quickstart for a walkthrough.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install annnet\n\n# Optional extras\npip install \"annnet[networkx,igraph]\"   # backends\npip install \"annnet[io]\"                # JSON/Parquet/Zarr, Excel, Narwhals\npip install \"annnet[all]\"               # common extras (graph\u2011tool not on PyPI)\n</code></pre> <p>Graph\u2011tool is supported if installed from your OS/package manager.</p>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li>Project: goals and scope</li> <li>Design philosophy: principles and trade\u2011offs</li> <li>Explanations: zero\u2011loss storage and interoperability</li> <li>Reference: API docs</li> </ul> <p>This is the main documentation page.</p>"},{"location":"about/","title":"About","text":"<p>annnet is an open-source project by the Saez Lab and contributors.</p>"},{"location":"about/#authors","title":"Authors","text":"<ul> <li>Youssef Zerta</li> <li>Bottazzi Daniele</li> <li>Denes Turei</li> </ul> <p>Maintainers: - Bottazzi Daniele - Youssef Zerta</p>"},{"location":"about/#license","title":"License","text":"<p>BSD 3\u2011Clause License. See the <code>LICENSE</code> file in the repository.</p>"},{"location":"about/#links","title":"Links","text":"<ul> <li>Repository: https://github.com/saezlab/annnet</li> <li>Documentation: https://saezlab.github.io/annnet</li> </ul>"},{"location":"installation/","title":"Installation guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing <code>annnet</code>, please ensure you have the following tools installed:</p> Tool Minimum Version Description Installation Guide Python 3.10 Programming language Install Python 3 uv \u2014 Python packaging &amp; dependency manager Install uv git \u2014 Version control system Install git <p>Tip</p> <p>If you are missing any of those pre-requisites, please follow the installation guide in each resource before you continue.</p>"},{"location":"installation/#checking-prerequisites","title":"Checking prerequisites","text":"<p>Verify that everything is installed by running:</p> <pre><code>python --version   # Should be 3.10 or higher\nuv --version\ngit --version\n</code></pre>"},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#from-pypi","title":"From PyPI","text":"<pre><code>pip install annnet\n\n# Optional extras\npip install \"annnet[networkx,igraph]\"   # backends\npip install \"annnet[io]\"                # JSON/Parquet/Zarr, Excel, Narwhals\npip install \"annnet[all]\"               # common extras (graph\u2011tool not on PyPI)\n</code></pre> <p>Graph\u2011tool is supported if installed via your OS/package manager.</p>"},{"location":"installation/#from-source-editable-dev-install","title":"From source (editable dev install)","text":"<p>This package is under active development. To try the latest, clone and install in editable mode so changes reflect immediately without reinstalling.</p> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/saezlab/annnet.git\n</code></pre></p> </li> <li> <p>Navigate into the project directory: <pre><code>cd annnet\n</code></pre></p> </li> <li> <p>Install the package in editable mode using <code>uv</code>: <pre><code>uv pip install -e .\n</code></pre></p> </li> </ol> <p>You can now start using <code>annnet</code> in your Python environment. Any changes you make to the source code will take effect immediately.</p>"},{"location":"annnet-project/design-philosophy/","title":"Design philosophy","text":"<p>annnet is designed with these principles:</p> <ul> <li>Simple, consistent interface for all graph types.</li> <li>Interoperability\u2011first: integrate, don\u2019t replace.</li> <li>Performance\u2011aware, not performance\u2011obsessed.</li> <li>Extensible and modular, not monolithic.</li> </ul>"},{"location":"annnet-project/design-philosophy/#architectural-choices","title":"Architectural choices","text":"<ul> <li>Separate structure from attributes: sparse incidence matrix for topology; attributes in Polars tables.</li> <li>Lazy interoperability: convert to NetworkX/igraph/graph\u2011tool only when needed (via proxies <code>G.nx</code>, <code>G.ig</code>, <code>G.gt</code>).</li> <li>Slices and views: copy\u2011on\u2011write patterns for subgraphs and state changes.</li> <li>Lossless storage: <code>.annnet</code> directories combine Zarr (arrays) and Parquet (tables), plus JSON sidecars.</li> </ul> <p>See the architecture overview for a deeper dive into data layout, conversion manifests, hyperedge semantics, and multilayer networks.</p>"},{"location":"annnet-project/project/","title":"Project","text":"<p>annnet provides a high\u2011expressivity, annotated graph container with:</p> <ul> <li>Flexible topology: binary edges and hyperedges, directed/undirected on a per\u2011edge basis, multiedges, self\u2011loops, vertex\u2013edge and edge\u2013edge relations.</li> <li>Multilayer structures: layers, aspects, inter\u2011layer edges.</li> <li>Slicing: define and switch between multiple graph \u201cviews\u201d.</li> <li>Annotated tables: Polars\u2011backed DataFrames for vertices, edges, layers, slices, and metadata.</li> <li>Interoperability: NetworkX/igraph/graph\u2011tool (lazy proxies), plus broad file formats.</li> <li>Stable storage: lossless on\u2011disk <code>.annnet</code> format (Zarr + Parquet + JSON).</li> </ul>"},{"location":"annnet-project/project/#package-layout","title":"Package layout","text":"<pre><code>annnet/\n\u251c\u2500\u2500 core/         # Graph class, managers, lazy proxies (nx/ig/gt)\n\u251c\u2500\u2500 adapters/     # Backend adapters (nx/ig/gt) and format adapters (GraphML/GEXF/SIF/SBML/CX2/Parquet/JSON/DataFrames)\n\u251c\u2500\u2500 io/           # Lossless .annnet storage (read/write) + Excel/CSV helpers\n\u251c\u2500\u2500 algorithms/   # Pure\u2011Python algorithms using core only\n\u2514\u2500\u2500 utils/        # Utilities (typing/validation/config)\n</code></pre> <p>See the architecture overview for design details, data structures, and IO layout.</p>"},{"location":"annnet-project/project/#goals","title":"Goals","text":"<ul> <li>Interoperability\u2011first: integrate with existing ecosystems.</li> <li>Zero\u2011loss persistence: save and reload without losing structure.</li> <li>Expressive but practical: handle complex structures while staying approachable.</li> <li>Familiar ergonomics: anndata\u2011inspired annotations and workflows.</li> </ul>"},{"location":"annnet-project/project/#scope","title":"Scope","text":"<ul> <li>Supported runtimes: Python 3.10+.</li> <li>Optional backends: NetworkX, igraph, graph\u2011tool (if installed).</li> <li>Formats: GraphML, GEXF, SIF, SBML, CX2, Parquet GraphDir, JSON/NDJSON, Excel/CSV, DataFrames (via Narwhals).</li> </ul>"},{"location":"annnet-project/use-cases/","title":"Use cases","text":"<p>This page highlights practical scenarios captured in the example notebooks, especially <code>notebooks/SBUC.ipynb</code>.</p>"},{"location":"annnet-project/use-cases/#1-analysis-with-backend-proxies","title":"1) Analysis with backend proxies","text":"<ul> <li>Run NetworkX algorithms directly: <code>G.nx.degree_centrality(G)</code>, <code>G.nx.louvain_communities(G)</code> (if community is available).</li> <li>Use igraph for metrics like <code>pagerank</code>, <code>betweenness</code>, or community detection via <code>G.ig</code> (if <code>python-igraph</code> installed).</li> <li>Construct a simplified backend graph with options:</li> </ul> <pre><code>nxG = G.nx.backend(\n    directed=True,\n    hyperedge_mode=\"skip\",  # or \"expand\" to reify\n    slices=[\"eval\"],         # or a single slice=\"eval\"\n    simple=True,             # collapse multiedges (sum weights)\n)\n</code></pre> <p>The SBUC notebook shows patterns like degree/betweenness centrality, shortest path, PageRank, Louvain, etc., across <code>G.nx</code> and <code>G.ig</code>.</p>"},{"location":"annnet-project/use-cases/#2-multilayer-modeling-and-visualization","title":"2) Multilayer modeling and visualization","text":"<ul> <li>Define aspects (e.g., time, modality) and construct intra/inter/coupling edges per layer combination.</li> <li>Export to Cytoscape via CX2 for visualization:</li> </ul> <pre><code>from annnet.adapters.cx2_adapter import to_cx2\ncx2 = to_cx2(G, hyperedges=\"reify\")\n# write json to file for Cytoscape import\n</code></pre>"},{"location":"annnet-project/use-cases/#3-sbml-integration-and-stoichiometry","title":"3) SBML integration and stoichiometry","text":"<ul> <li>Import biochemical models from SBML (libSBML/COBRA) and represent reactions as directed hyperedges with stoichiometric coefficients embedded in the incidence matrix.</li> <li>Convert to backend for algorithmic analysis or to CX2/GraphML for visualization/archival.</li> </ul>"},{"location":"annnet-project/use-cases/#4-interoperability-and-roundtrips","title":"4) Interoperability and round\u2011trips","text":"<ul> <li>Convert to NetworkX/igraph with a manifest; edit externally; round\u2011trip back:</li> </ul> <pre><code>import annnet as an\nnxG, manifest = an.to_nx(G, directed=True, hyperedge_mode=\"skip\")\n# ... external processing ...\nG2 = an.from_nx(nxG, manifest)\n</code></pre>"},{"location":"annnet-project/use-cases/#5-slices-for-scenarioscontexts","title":"5) Slices for scenarios/contexts","text":"<ul> <li>Use slices to represent scenarios (train/eval), conditions, or experimental contexts.</li> <li>Override edge weights per slice and toggle the active slice during analysis.</li> </ul>"},{"location":"annnet-project/use-cases/#notebook","title":"Notebook","text":"<ul> <li>Open <code>notebooks/SBUC.ipynb</code> to explore these patterns interactively.</li> <li>The documentation site can render notebooks placed under <code>docs/</code> (via mkdocs\u2011jupyter). If you want this notebook live on the site, I can copy or adapt it under <code>docs/</code>.</li> </ul>"},{"location":"community/","title":"Join Us","text":"<p>Welcome to the annnet community! We follow open-source principles and encourage any sort of contribution. We communicate on GitHub, where we also organise our projects.</p> <ul> <li> <p> Where to Start</p> <p>If you'd like to learn how to contribute to our projects, please follow the steps outlined in the contribution guide.</p> <p> To the contribution guide</p> </li> </ul>"},{"location":"community/#contributing-guidelines-github-links","title":"Contributing Guidelines GitHub Links","text":"<ul> <li> <p>Contribution guidelines</p> </li> <li> <p>Code of Conduct</p> </li> <li> <p>Developer Guide</p> </li> </ul>"},{"location":"community/contribute-codebase/","title":"Developer Guide","text":"<p>Thank you for considering to contribute to the project! This guide will help you to get started with the development of the project. If you have any questions, please feel free to ask them in the issue tracker on GitHub.</p>"},{"location":"community/contribute-codebase/#small-contributions","title":"Small Contributions","text":"<p>If you want to contribute a small change (e.g., a bugfix), you can probably immediately go ahead and create a pull request. For more substantial changes or additions, please read on.</p>"},{"location":"community/contribute-codebase/#larger-contributions","title":"Larger Contributions","text":"<p>If you want to contribute a larger change, please create an issue first. This will allow us to discuss the change and make sure that it fits into the project.  It can happen that development for a feature is already in progress, so it is important to check first to avoid duplicate work. If you have any questions, feel free to approach us in any way you like.</p>"},{"location":"community/contribute-codebase/#dependency-management","title":"Dependency management","text":"<p>We use Poetry for dependency management. Please make sure that you have installed Poetry and set up the environment correctly before starting development.</p>"},{"location":"community/contribute-codebase/#setting-up-the-environment","title":"Setting up the environment","text":"<ul> <li> <p>Install dependencies from the lock file: <code>poetry install</code></p> </li> <li> <p>Use the environment: You can either run commands directly with <code>poetry run &lt;command&gt;</code> or open a shell with <code>poetry shell</code> and then run commands directly.</p> </li> </ul>"},{"location":"community/contribute-codebase/#updating-the-environment","title":"Updating the environment","text":"<p>If you want to fix dependency issues, please do so in the Poetry framework. If Poetry does not work for you for some reason, please let us know.</p> <p>The Poetry dependencies are organized in groups. There are groups with dependencies needed for running annnet (<code>[tool.poetry.dependencies]</code> with the group name <code>main</code>) and a group with dependencies needed for development (<code>[tool.poetry.group.dev.dependencies]</code> with the group name <code>dev</code>).</p> <p>For adding new dependencies:</p> <ul> <li> <p>Add new dependencies via <code>poetry add</code>: <code>poetry add &lt;dependency&gt; --group &lt;group&gt;</code>. This will update the <code>pyproject.toml</code> and lock file automatically.</p> </li> <li> <p>Add new dependencies via <code>pyproject.toml</code>: Add the dependency to the <code>pyproject.toml</code> file in the correct group, including version. Then update the lock file: <code>poetry lock</code> and install the dependencies: <code>poetry install</code>.</p> </li> </ul>"},{"location":"community/contribute-codebase/#code-quality-and-formal-requirements","title":"Code quality and formal requirements","text":"<p>For ensuring code quality, the following tools are used:</p> <ul> <li> <p>isort for sorting imports</p> </li> <li> <p>black for automated code formatting</p> </li> <li> <p>pre-commit-hooks for ensuring some general rules</p> </li> <li> <p>pep585-upgrade for automatically upgrading type hints to the new native types defined in PEP 585</p> </li> <li> <p>pygrep-hooks for ensuring some general naming rules</p> </li> <li> <p>Ruff An extremely fast Python linter and code formatter, written in Rust</p> </li> </ul> <p>We recommend configuring your IDE to execute Ruff on save/type, which will automatically keep your code clean and fix some linting errors as you type. This is made possible by the fast execution of Ruff and removes the need to run a dedicated pre-commit step. For instance, in VSCode or Cursor, you can add this to your <code>.vscode/settings.json</code>:</p> <pre><code>{\n    \"editor.formatOnType\": true,\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll.ruff\": \"explicit\",\n        \"source.organizeImports.ruff\": \"explicit\"\n    },\n    \"editor.defaultFormatter\": \"charliermarsh.ruff\"\n}\n</code></pre> <p>Alternatively, pre-commit hooks can be used to automatically or manually run these tools before each commit. They are defined in <code>.pre-commit-config.yaml</code>. To install the hooks run <code>poetry run pre-commit install</code>. The hooks are then executed before each commit. For running the hook for all project files (not only the changed ones) run <code>poetry run pre-commit run --all-files</code>. Our CI runs the pre-commit hooks, so running them locally is a good way to check if your code conforms to the formatting rules.</p>"},{"location":"community/contribute-codebase/#testing","title":"Testing","text":"<p>The project uses pytest for testing. To run the tests, please run <code>pytest</code> in the root directory of the project. We are developing annnet using test-driven development. Please make sure that you add tests for your code before submitting a pull request.</p> <p>The existing tests can also help you to understand how the code works. If you have any questions, please feel free to ask them in the issue tracker or on Zulip.</p> <p>Before submitting a pull request, please make sure that all tests pass and that the documentation builds correctly.</p>"},{"location":"community/contribute-codebase/#versioning","title":"Versioning","text":"<p>We use semantic versioning for the project. This means that the version number is incremented according to the following scheme:</p> <ul> <li> <p>Increment the major version number if you make incompatible API changes.</p> </li> <li> <p>Increment the minor version number if you add functionality in a backwards-   compatible manner. Since we are still in the 0.x.y version range, most of the   significant changes will increase the minor version number.</p> </li> <li> <p>Increment the patch version number if you make backwards-compatible bug fixes.</p> </li> </ul> <p>We use the <code>bumpversion</code> tool to update the version number in the <code>pyproject.toml</code> file. This will create a new git tag automatically. Usually, versioning is done by the maintainers, so please do not increment versions in pull requests by default.</p>"},{"location":"community/contribute-codebase/#finding-an-issue-to-contribute-to","title":"Finding an issue to contribute to","text":"<p>If you are brand new to annnet or open-source development, we recommend searching the GitHub \"Issues\" tab to find issues that interest you. Unassigned issues labeled <code>Docs</code> and <code>good first</code> are typically good for newer contributors.</p> <p>Once you've found an interesting issue, it's a good idea to assign the issue to yourself, so nobody else duplicates the work on it.</p> <p>If for whatever reason you are not able to continue working with the issue, please unassign it, so other people know it's available again. If you want to work on an issue that is currently assigned but you're unsure whether work is actually being done, feel free to kindly ask the current assignee if you can take over (please allow at least a week of inactivity before getting in touch).</p>"},{"location":"community/contribute-codebase/#submitting-a-pull-request","title":"Submitting a Pull Request","text":""},{"location":"community/contribute-codebase/#tips-for-a-successful-pull-request","title":"Tips for a successful pull request","text":"<p>To improve the chances of your pull request being reviewed, you should:</p> <ul> <li>Reference an open issue for non-trivial changes to clarify the PR's purpose.</li> <li>Ensure you have appropriate tests. Tests should be the focus of any PR (apart from documentation changes).</li> <li>Keep your pull requests as simple as possible. Larger PRs take longer to review.</li> <li>Ensure that CI is in a green state. Reviewers may tell you to fix the CI before looking at anything else.</li> </ul>"},{"location":"community/contribute-codebase/#version-control-git-and-github","title":"Version control, Git, and GitHub","text":"<p>annnet is hosted on GitHub, and to contribute, you will need to sign up for a free GitHub account. We use Git for version control to allow many people to work together on the project.</p> <p>If you are new to Git, you can reference some of these resources for learning Git. Feel free to reach out to the contributor community for help if needed:</p> <ul> <li>Git documentation.</li> </ul> <p>The project follows a forking workflow further described on this page whereby contributors fork the repository, make changes and then create a Pull Request. So please be sure to read and follow all the instructions in this guide.</p> <p>If you are new to contributing to projects through forking on GitHub, take a look at the GitHub documentation for contributing to projects. GitHub provides a quick tutorial using a test repository that may help you become more familiar with forking a repository, cloning a fork, creating a feature branch, pushing changes and making Pull Requests.</p> <p>Below are some useful resources for learning more about forking and Pull Requests on GitHub:</p> <ul> <li> <p>the GitHub documentation for forking a repo.</p> </li> <li> <p>the GitHub documentation for collaborating with Pull Requests.</p> </li> <li> <p>the GitHub documentation for working with forks.</p> </li> </ul> <p>There are also many unwritten rules and conventions that are helpful in interacting with other open-source contributors. These lessons from PyOpenSci are a good resource for learning more about how to interact with other open-source contributors in scientific computing.</p>"},{"location":"community/contribute-codebase/#getting-started-with-git","title":"Getting started with Git","text":"<p>GitHub has instructions for installing git, setting up your SSH key, and configuring git. All these steps need to be completed before you can work seamlessly between your local repository and GitHub.</p>"},{"location":"community/contribute-codebase/#create-a-fork-of-annnet","title":"Create a fork of annnet","text":"<p>You will need your own fork of annnetin order to eventually open a Pull Request. Go to the annnet project page and hit the Fork button. Please uncheck the box to copy only the main branch before selecting Create Fork. You will then want to clone your fork to your machine.</p> <pre><code>git clone https://github.com/your-user-name/annnet.git\ncd annnet\ngit remote add upstream https://github.com/annnet/annnet.git\ngit fetch upstream\n</code></pre> <p>This creates the directory <code>annnet</code> and connects your repository to the upstream (main project) annnet repository. They have the same name, but your local repository and fork are separate from the upstream repository.</p>"},{"location":"community/contribute-codebase/#creating-a-feature-branch","title":"Creating a feature branch","text":"<p>Your local <code>main</code> branch should always reflect the current state of annnet repository. First ensure it's up-to-date with the main annnet repository.</p> <pre><code>git checkout main\ngit pull upstream main --ff-only\n</code></pre> <p>Then, create a feature branch for making your changes. For example, we are going to create a branch called <code>my-new-feature-for-annnet</code></p> <pre><code>git checkout -b my-new-feature-for-annnet\n</code></pre> <p>This changes your working branch from <code>main</code> to the <code>my-new-feature-for-annnet</code> branch. Keep any changes in this branch specific to one bug or feature so it is clear what the branch brings to annnet. You can have many feature branches and switch between them using the <code>git checkout</code> command.</p>"},{"location":"community/contribute-codebase/#making-code-changes","title":"Making code changes","text":"<p>Before modifying any code, ensure you follow the contributing environment guidelines to set up an appropriate development environment.</p> <p>When making changes, follow these annnet-specific guidelines:</p> <ol> <li> <p>Keep changes of that branch/PR focused on a single feature or bug fix.</p> </li> <li> <p>Follow roughly the conventional commit message conventions.</p> </li> </ol>"},{"location":"community/contribute-codebase/#pushing-your-changes","title":"Pushing your changes","text":"<p>When you want your committed changes to appear publicly on your GitHub page, you can push your forked feature branch's commits to your forked repository on GitHub.</p> <p>Now your code is on GitHub, but it is not yet a part of the annnet project. For that to happen, a Pull Request (PR) needs to be submitted.</p>"},{"location":"community/contribute-codebase/#opening-a-pull-request-pr","title":"Opening a Pull Request (PR)","text":"<p>If everything looks good according to the general guidelines, you are ready to make a Pull Request. A Pull Request is how code from your fork becomes available to the project maintainers to review and merge into the project to appear in the next release. To submit a Pull Request:</p> <ol> <li> <p>Navigate to your repository on GitHub.</p> </li> <li> <p>Click on the Compare &amp; Pull Request button.</p> </li> <li> <p>You can then click on Commits and Files Changed to make sure everything looks okay one last time.</p> </li> <li> <p>Write a descriptive title that includes prefixes. annnet uses a convention for title prefixes, most commonly, <code>feat:</code> for features, <code>fix:</code> for bug fixes, and <code>refactor:</code> for refactoring.</p> </li> <li> <p>Write a description of your changes in the <code>Preview Discussion</code> tab. This description will inform the reviewers about the changes you made, so please include all relevant information, including the motivation, implementation details, and references to any issues that you are addressing.</p> </li> <li> <p>Make sure to <code>Allow edits from maintainers</code>; this allows the maintainers to make changes to your PR directly, which is useful if you are not sure how to fix the PR.</p> </li> <li> <p>Click <code>Send Pull Request</code>.</p> </li> <li> <p>Optionally, you can assign reviewers to your PR, if you know who should review it.</p> </li> </ol> <p>This request then goes to the repository maintainers, and they will review the code.</p>"},{"location":"community/contribute-codebase/#updating-your-pull-request","title":"Updating your Pull Request","text":"<p>Based on the review you get on your pull request, you will probably need to make some changes to the code. You can follow the steps above again to address any feedback and update your pull request.</p>"},{"location":"community/contribute-codebase/#parallel-changes-in-the-upstream-main-branch","title":"Parallel changes in the upstream <code>main</code> branch","text":"<p>In case of simultaneous changes to the upstream code, it is important that these changes are reflected in your pull request. To update your feature branch with changes in the annnet <code>main</code> branch, run:</p> <pre><code>    git checkout my-new-feature-for-annnet\n    git fetch upstream\n    git merge upstream/main\n</code></pre> <p>If there are no conflicts (or they could be fixed automatically), a file with a default commit message will open, and you can simply save and quit this file.</p> <p>If there are merge conflicts, you need to resolve those conflicts. See here for an explanation on how to do this.</p> <p>Once the conflicts are resolved, run:</p> <ol> <li><code>git add -u</code> to stage any files you've updated;</li> <li><code>git commit</code> to finish the merge.</li> </ol> <p>After the feature branch has been updated locally, you can now update your pull request by pushing to the branch on GitHub:</p> <pre><code>    git push origin my-new-feature-for-annnet\n</code></pre> <p>Any <code>git push</code> will automatically update your pull request with your branch's changes and restart the <code>Continuous Integration</code> checks.</p>"},{"location":"community/contribute-docs/","title":"Contributing to the documentation","text":"<p>Contributing to the documentation benefits everyone who uses annnet. We encourage you to help us improve the documentation, and you don't have to be an expert on annnet to do so! In fact, there are sections of the docs that are worse off after being written by experts. If something in the docs doesn't make sense to you, updating the relevant section after you figure it out is a great way to ensure it will help the next person.</p>"},{"location":"community/contribute-docs/#how-to-contribute-to-the-documentation","title":"How to contribute to the documentation","text":"<p>The documentation is written in Markdown, which is almost like writing in plain English, and built using Material for MkDocs. The simplest way to contribute to the docs is to click on the <code>Edit</code> button (pen and paper) at the top right of any page. This will take you to the source file on GitHub, where you can make your changes and create a pull request using GitHub's web interface (the <code>Commit changes...</code> button).</p> <p>Some other important things to know about the docs:</p> <ul> <li> <p>The annnet documentation consists of two parts: the docstrings in the code   itself and the docs in the <code>docs/</code> folder. The docstrings provide a clear   explanation of the usage of the individual functions, while the documentation   website you are looking at is built from the <code>docs/</code> folder.</p> </li> <li> <p>The docstrings follow a convention, based on the Google Docstring   Standard.</p> </li> <li> <p>Our API documentation files in <code>docs/reference/source</code> contain the   instructions for the auto-generated documentation from the docstrings. For   classes, there are a few subtleties around controlling which methods and   attributes have pages auto-generated.</p> </li> </ul>"},{"location":"community/contribute/","title":"How to Start Contributing","text":"<p>There are many valuable ways to contribute besides writing code. Thank you for dedicating your time to improve our project!</p>"},{"location":"community/contribute/#bug-reports-and-enhancement-requests","title":"Bug reports and enhancement requests","text":"<p>Bug reports and enhancement requests are an important part of making any software more stable. We curate them though Github issues. When opening an issue or request, please select the appropriate category and fill out the issue form fully to ensure others and the core development team can fully understand the scope of the issue. If your category is not listed, you can create a blank issue.</p> <p>The issue will then show up to the annnet community and be open to comments/ideas from others.</p>"},{"location":"community/contribute/#categories","title":"Categories","text":"<ul> <li>Bug Report: Report incorrect behavior in the annnet library</li> <li>Register New Component: Register a new component in the annnet ecosystem, either one you have created, or one that you would like to see added</li> <li>Documentation Improvement: Report wrong or missing documentation</li> <li>Feature Request: Suggest an idea for annnet</li> </ul>"},{"location":"community/contribute/#detailed-guides","title":"Detailed Guides","text":"<ul> <li> <p> Contributing to the Documentation</p> <p>A simple way to get started is to contribute to the documentation. Please follow the guide here to learn how to do so.</p> <p> To the contribution guide</p> </li> </ul> <ul> <li> <p> Contributing to the Code Base</p> <p>The best way to contribute code is to open a pull request on Github. Please follow the guide here to learn how to do so.</p> <p> To the contribution guide</p> </li> </ul>"},{"location":"learn/explanation/","title":"Explanations","text":"<p>Deep dives into how annnet works under the hood.</p> <ul> <li>Interoperability: runtime backend adapters (NetworkX/igraph/graph\u2011tool) and conversion manifests.</li> <li>annnet zero\u2011loss serialization: <code>.annnet</code> storage with Zarr + Parquet + JSON.</li> </ul> <p>See also the architecture overview for broader design context.</p>"},{"location":"learn/explanation/architecture-overview/","title":"Architecture overview","text":"<p>This page summarizes the core design from <code>architecture.md</code>.</p>"},{"location":"learn/explanation/architecture-overview/#core-data-model","title":"Core data model","text":"<ul> <li>Incidence matrix (V\u00d7E) as the primary structure (sparse DOK in\u2011memory, stored as COO). Each edge is a column; direction uses sign (+ for head/source, \u2212 for tail/target). Undirected edges use + on all incident vertices.</li> <li>Unified entity system: vertex rows and edge\u2011entities (for vertex\u2013edge relations) share the same row space with <code>entity_to_idx</code>, <code>idx_to_entity</code>, and <code>entity_types</code>.</li> <li>Edge system: <code>edge_to_idx</code>, <code>idx_to_edge</code>, <code>edge_definitions</code>, per\u2011edge <code>weight</code>, and <code>directed</code> flags. Parallel edges are separate columns.</li> </ul>"},{"location":"learn/explanation/architecture-overview/#direction-and-hyperedges","title":"Direction and hyperedges","text":"<ul> <li>Direction control at three levels: graph default, per\u2011edge override, mixed mode.</li> <li>Hyperedges: undirected (set membership) or directed (head\u2192tail) with explicit <code>hyperedge_definitions</code> and <code>edge_kind</code>.</li> <li>SBML stoichiometry: per\u2011endpoint coefficients written directly into incidence columns.</li> </ul>"},{"location":"learn/explanation/architecture-overview/#slices","title":"Slices","text":"<ul> <li>Named subgraph memberships with a current active slice for new elements.</li> <li>Set algebra (union/intersection/difference) and per\u2011slice edge attributes (e.g., weight overrides).</li> </ul>"},{"location":"learn/explanation/architecture-overview/#multilayer-networks-kivela","title":"Multilayer networks (Kivel\u00e4)","text":"<ul> <li>Aspects and elementary layers define the layer space (cartesian product). Vertex\u2011layer presence tracked in <code>V\u00d7M</code> set; edges can be intra\u2011layer, inter\u2011layer, or coupling.</li> <li>Supra\u2011adjacency and supra\u2011Laplacian available; a 4\u2011index tensor view provides a higher\u2011order representation.</li> </ul>"},{"location":"learn/explanation/architecture-overview/#attributes-polars-dataframes","title":"Attributes (Polars DataFrames)","text":"<ul> <li>Separate, columnar tables for vertex, edge, slice, and edge\u2011slice attributes. Structural keys are filtered; only pure user attributes go into tables.</li> <li>Upsert semantics with automatic schema growth and type inference; read\u2011only views for quick inspection.</li> </ul>"},{"location":"learn/explanation/architecture-overview/#interoperability","title":"Interoperability","text":"<ul> <li>Runtime backend adapters:</li> <li>NetworkX via <code>G.nx</code> and <code>to_nx</code>/<code>from_nx</code></li> <li>igraph via <code>G.ig</code> and <code>to_igraph</code>/<code>from_igraph</code></li> <li>graph\u2011tool via <code>G.gt</code> and <code>to_graphtool</code> (if installed)</li> <li>Conversion options: <code>directed</code>, <code>hyperedge_mode</code> (skip/expand), slice selection, and simple mode (collapse multiedges). Proxies may slim attributes to those required for algorithms.</li> <li>Manifests: returned on conversion to improve round\u2011trip fidelity on import (hyperedges, slices, multigraph collapsing).</li> </ul>"},{"location":"learn/explanation/architecture-overview/#storage-layout-annnet","title":"Storage layout (.annnet)","text":"<ul> <li>Directory structure combines Zarr for arrays and Parquet for tables, plus JSON sidecars. Key paths:</li> <li><code>manifest.json</code> with counts, versions, and slice metadata</li> <li><code>structure/incidence.zarr/{row,col,data}</code> and index maps as Parquet</li> <li><code>tables/*</code> for attributes; <code>layers/</code> and <code>slices/</code> for multilayer and slice data</li> <li><code>audit/</code> for history; optional <code>cache/</code> for CSR/CSC; <code>uns/</code> for unstructured results</li> </ul>"},{"location":"learn/explanation/architecture-overview/#history-and-diffs","title":"History and diffs","text":"<ul> <li>Automatic mutation logging with export to Parquet/JSON/CSV/NDJSON, named snapshots, and diffs between snapshots.</li> </ul>"},{"location":"learn/explanation/architecture-overview/#spectral-methods","title":"Spectral methods","text":"<ul> <li>Supra adjacency/Laplacian, transition matrices, eigenvalue routines, diffusion and random walk helpers, and coupling regime sweeps.</li> </ul> <p>For full details, see the top\u2011level <code>architecture.md</code> in the repository.</p>"},{"location":"learn/explanation/history-and-diffs/","title":"History and diffs","text":"<p>annnet records mutations automatically and provides snapshots and diffs for auditability.</p>"},{"location":"learn/explanation/history-and-diffs/#automatic-mutation-logging","title":"Automatic mutation logging","text":"<p>Every mutating method is wrapped to append an event with timestamp, monotonic clock, operation name, payload, and result.</p> <p>Example event shape:</p> <pre><code>{\n  \"version\": 42,\n  \"ts_utc\": \"2025-12-05T10:30:00.123456Z\",\n  \"mono_ns\": 123456789,\n  \"op\": \"add_vertex\",\n  \"vertex_id\": \"alice\",\n  \"attributes\": {\"age\": 30},\n  \"result\": \"alice\"\n}\n</code></pre> <p>Controls:</p> <pre><code>G.enable_history(True)   # toggle logging\nG.clear_history()        # clear in\u2011memory history buffer\nG.mark(\"checkpoint\")     # insert a labeled marker\n</code></pre> <p>Export and views:</p> <pre><code>df = G.history(as_df=True)          # Polars DataFrame view\nn = G.export_history(\"log.parquet\") # or .ndjson / .json / .csv\n</code></pre>"},{"location":"learn/explanation/history-and-diffs/#snapshots-and-diffs","title":"Snapshots and diffs","text":"<p>Create labeled snapshots, then compute differences between them to see structural and attribute changes.</p> <pre><code>snap1 = G.snapshot(label=\"before\")\n# ... perform mutations ...\nsnap2 = G.snapshot(label=\"after\")\n\ndiff = G.diff(\"before\", \"after\")\ndiff.added_vertices     # set[str]\ndiff.removed_vertices   # set[str]\ndiff.added_edges        # set[str]\ndiff.removed_edges      # set[str]\n</code></pre> <p>Tips: - Use checkpoints/marks to segment logs for analysis. - Export history alongside <code>.annnet</code> for provenance. - Pair snapshots with <code>export_history()</code> to reconstruct change timelines.</p>"},{"location":"learn/explanation/interoperability/","title":"Interoperability and adapters","text":"<p>annnet distinguishes two kinds of adapters:</p> <ul> <li>Runtime backend adapters (interoperability): power the lazy proxies <code>G.nx</code>, <code>G.ig</code>, <code>G.gt</code> to call algorithms and create in\u2011memory graphs for NetworkX, igraph, and graph\u2011tool.</li> <li>Format/data adapters (I/O): read/write files and data tables (GraphML, GEXF, SIF, SBML, CX2, Parquet GraphDir, JSON/NDJSON, Excel/CSV, DataFrames via Narwhals).</li> </ul> <p>In short: proxies = nx/ig/gt at runtime; file formats = adapters under the hood.</p>"},{"location":"learn/explanation/interoperability/#using-runtime-proxies","title":"Using runtime proxies","text":"<pre><code># NetworkX\nbc = G.nx.betweenness_centrality(G)\n\n# Get a concrete backend graph with options\nnxG = G.nx.backend(\n    directed=True,\n    hyperedge_mode=\"skip\",  # or \"expand\"\n    slice=\"toy\",\n    simple=True,             # collapse multiedges\n)\n\n# igraph (if installed)\npagerank = G.ig.pagerank(G)\n</code></pre> <p>Behavioral notes: - Hyperedges: may be dropped or expanded depending on <code>hyperedge_mode</code> and backend. - Slices: backends operate on a single view; multiple slices can be flattened unless specified. - Attributes: proxies keep only needed attributes by default for performance.</p>"},{"location":"learn/explanation/interoperability/#manifests-for-roundtrip-conversions","title":"Manifests for round\u2011trip conversions","text":"<p>When converting to external graphs, annnet returns a manifest capturing details needed to reconstruct the original structure as faithfully as possible on import.</p> <pre><code>import annnet as an\n\nnxG, manifest = an.to_nx(G, directed=True, hyperedge_mode=\"skip\")\n# ... use nxG ...\nG2 = an.from_nx(nxG, manifest)\n</code></pre> <p>Manifests are especially useful when: - Hyperedges are reified or skipped. - Multiple slices are flattened for a backend. - Multigraphs are collapsed to simple graphs for algorithm convenience.</p>"},{"location":"learn/explanation/io_annnet/","title":"annnet zero-loss serialization: Zarr + Parquet","text":""},{"location":"learn/explanation/io_annnet/#design-goals","title":"Design goals","text":"<ol> <li>Zero topology loss: Preserve exact incidence matrix, all edge types, hyperedges, parallel edges</li> <li>Complete metadata: All attributes, slices, history, provenance</li> <li>Cross-platform: Works on Windows/Linux/Mac, Python/R/Julia</li> <li>Incremental updates: Can append without full rewrite</li> <li>Cloud support: S3/GCS/Azure compatible via Zarr</li> <li>Fast random access: Chunked storage for large graphs</li> </ol>"},{"location":"learn/explanation/io_annnet/#file-structure","title":"File Structure","text":"<pre><code>graph.annnet/\n\u251c\u2500\u2500 manifest.json                 # root descriptor (format, counts, compression, etc.)\n\u251c\u2500\u2500 structure/\n\u2502   \u251c\u2500\u2500 incidence.zarr/           # Zarr v3 group holding COO [coordinate list] arrays\n\u2502   \u2502   \u251c\u2500\u2500 zarr.json             # Zarr v3 group metadata (includes group attributes)\n\u2502   \u2502   \u251c\u2500\u2500 row/                  # Zarr array (int32) of entity indices (COO row)\n\u2502   \u2502   \u251c\u2500\u2500 col/                  # Zarr array (int32) of edge indices   (COO col)\n\u2502   \u2502   \u2514\u2500\u2500 data/                 # Zarr array (float32) of weights      (COO data)\n\u2502   \u2502   # group attributes include: {\"shape\": [n_entities, n_edges]}\n\u2502   \u251c\u2500\u2500 entity_to_idx.parquet     # entity_id \u2192 row index\n\u2502   \u251c\u2500\u2500 idx_to_entity.parquet     # row index \u2192 entity_id\n\u2502   \u251c\u2500\u2500 entity_types.parquet      # entity_id \u2192 \"vertex\" | \"edge\"\n\u2502   \u251c\u2500\u2500 edge_to_idx.parquet       # edge_id \u2192 column index\n\u2502   \u251c\u2500\u2500 idx_to_edge.parquet       # column index \u2192 edge_id\n\u2502   \u251c\u2500\u2500 edge_definitions.parquet  # edge_id \u2192 (source, target, edge_type) for simple edges\n\u2502   \u251c\u2500\u2500 edge_weights.parquet      # edge_id \u2192 weight\n\u2502   \u251c\u2500\u2500 edge_directed.parquet     # edge_id \u2192 bool | null\n\u2502   \u251c\u2500\u2500 edge_kind.parquet         # edge_id \u2192 \"binary\" | \"hyper\" | \"intra\" | \"inter\"\n\u2502   \u2514\u2500\u2500 hyperedge_definitions.parquet\n\u2502       # columns: edge_id, directed(bool), members(List[Utf8]) OR head(List[Utf8]), tail(List[Utf8])\n\u2502\n\u251c\u2500\u2500 tables/\n\u2502   \u251c\u2500\u2500 vertex_attributes.parquet      # vertex-level DF [dataframe]\n\u2502   \u251c\u2500\u2500 edge_attributes.parquet        # edge-level DF\n\u2502   \u251c\u2500\u2500 slice_attributes.parquet       # slice metadata\n\u2502   \u2514\u2500\u2500 edge_slice_attributes.parquet  # (slice_id, edge_id, weight)\n\u2502\n\u251c\u2500\u2500 layers/                           # Kivela Multilayer Structures\n\u2502   \u251c\u2500\u2500 metadata.json                 # {\"aspects\": [...], \"elem_layers\": {...}}\n\u2502   \u251c\u2500\u2500 vertex_presence.parquet       # vertex_id, layer(List[str])\n\u2502   \u251c\u2500\u2500 edge_layers.parquet           # edge_id, layer_1(List[str]), layer_2(List[str]|null)\n\u2502   \u251c\u2500\u2500 elem_layer_attributes.parquet # attributes for elementary layers\n\u2502   \u251c\u2500\u2500 aspect_attributes.json        # attributes for aspects\n\u2502   \u251c\u2500\u2500 tuple_layer_attributes.parquet # layer(List[str]), attributes(JSON)\n\u2502   \u2514\u2500\u2500 vertex_layer_attributes.parquet # vertex_id, layer(List[str]), attributes(JSON)\n\u2502\n\u251c\u2500\u2500 slices/                           # Subgraph Views\n\u2502   \u251c\u2500\u2500 registry.parquet              # slice_id, name, metadata\u2026\n\u2502   \u251c\u2500\u2500 vertex_memberships.parquet    # (slice_id, vertex_id)\n\u2502   \u2514\u2500\u2500 edge_memberships.parquet      # (slice_id, edge_id, weight)\n\u2502\n\u251c\u2500\u2500 cache/                            # optional materialized views\n\u2502   \u251c\u2500\u2500 csr.zarr/                     # CSR [compressed sparse row] cache\n\u2502   \u2514\u2500\u2500 csc.zarr/                     # CSC [compressed sparse column] cache\n\u2502\n\u251c\u2500\u2500 audit/\n\u2502   \u251c\u2500\u2500 history.parquet               # operation log (nested payloads stringified to JSON [JavaScript Object Notation])\n\u2502   \u251c\u2500\u2500 snapshots/                    # optional labeled snapshots\n\u2502   \u2514\u2500\u2500 provenance.json               # creation time, software versions, etc.\n\u2502\n\u2514\u2500\u2500 uns/                              # unstructured metadata &amp; results\n    \u251c\u2500\u2500 graph_attributes.json\n    \u2514\u2500\u2500 results/\n</code></pre>"},{"location":"learn/explanation/io_annnet/#manifest-schema-manifestjson","title":"Manifest Schema (<code>manifest.json</code>)","text":"<pre><code>{\n  \"format\": \"annnet\",\n  \"version\": \"1.1.0\",\n  \"created\": \"2025-10-23T10:30:00Z\",\n  \"annnet_version\": \"0.1.0\",\n  \"graph_version\": 42,\n  \"directed\": true,\n  \"counts\": {\n    \"vertices\": 1000,\n    \"edges\": 5000,\n    \"entities\": 1050,\n    \"slices\": 3,\n    \"hyperedges\": 50,\n    \"aspects\": 2\n  },\n  \"slices\": [\"default\", \"temporal_2023\", \"temporal_2024\"],\n  \"active_slice\": \"default\",\n  \"default_slice\": \"default\",\n  \"schema_version\": \"1.0\",\n  \"checksum\": \"sha256:abcdef...\",\n  \"compression\": \"zstd\",\n  \"encoding\": {\n    \"zarr\": \"v3\",\n    \"parquet\": \"2.0\"\n  }\n}\n</code></pre>"},{"location":"learn/explanation/io_annnet/#field-mapping-to-inmemory-graph","title":"Field mapping to in\u2011memory graph","text":"<ul> <li><code>format</code>, <code>version</code>: file format identifier and schema version.</li> <li><code>created</code>: ISO timestamp of export.</li> <li><code>annnet_version</code>: library version that wrote the data.</li> <li><code>graph_version</code>: internal monotonic version counter (used by caches/proxies).</li> <li><code>directed</code>: default directionality for edges when unspecified per\u2011edge.</li> <li><code>counts</code>: sanity counts for fast checks; not authoritative for reading.</li> <li><code>vertices</code> \u2194 number of entities with type <code>vertex</code> in <code>entity_types.parquet</code>.</li> <li><code>edges</code> \u2194 number of columns in incidence (and rows in <code>edge_*</code> maps).</li> <li><code>entities</code> \u2194 total rows in incidence and size of <code>entity_*</code> maps.</li> <li><code>slices</code> \u2194 number of slices in <code>slices/registry.parquet</code>.</li> <li><code>hyperedges</code> \u2194 entries in <code>structure/hyperedge_definitions.parquet</code>.</li> <li><code>aspects</code> \u2194 number of aspects in <code>layers/metadata.json</code>.</li> <li><code>slices</code>: ordered list of slice IDs; <code>active_slice</code> and <code>default_slice</code> indicate runtime state.</li> <li><code>compression</code>: preferred codec for Parquet writing (e.g., <code>zstd</code>).</li> <li><code>encoding</code>: explicit versions of Zarr and Parquet encodings used.</li> </ul>"},{"location":"learn/explanation/io_annnet/#validation-and-compatibility","title":"Validation and compatibility","text":"<ul> <li>Readers should not rely solely on <code>counts</code> for trust; derive truth from Parquet/Zarr sources.</li> <li>Unknown keys MUST be ignored to allow forward\u2011compatible schema evolution.</li> <li>If <code>schema_version</code> is older, treat missing sections as optional (e.g., no <code>layers/</code> folder \u2192 monolayer).</li> <li>If <code>active_slice</code> is not present in <code>slices/registry.parquet</code>, fall back to <code>default_slice</code> or <code>\"default\"</code>.</li> <li>Zarr root MUST carry <code>attrs.shape = [n_entities, n_edges]</code> for the incidence matrix.</li> </ul>"},{"location":"learn/explanation/io_annnet/#advantages","title":"Advantages","text":"<ol> <li>Zero loss: topology + metadata round-trip exactly</li> <li>Portable: Parquet/Zarr are first-class in Python/R/Julia</li> <li>Incremental: replace just the parts you touched</li> <li>Cloud-native: Zarr stores are compatible with S3/GCS/Azure</li> <li>Interoperable: PaParquet works with Pandas/DuckDB/Arrow ecosystems</li> <li>Compressed: zstd/lz4 where supported</li> <li>Chunked: fast random access on large graphs</li> <li>Schema evolution: add new tables without breaking old readers</li> </ol>"},{"location":"learn/explanation/managers-and-views/","title":"Managers and views","text":"<p>annnet exposes several manager accessors and view utilities to organize functionality.</p>"},{"location":"learn/explanation/managers-and-views/#slicemanager-gslices","title":"SliceManager (<code>G.slices</code>)","text":"<ul> <li>Create/delete: <code>G.add_slice(id, **attrs)</code>, <code>G.drop_slice(id)</code></li> <li>Activate: <code>G.slices.active = id</code></li> <li>List: <code>G.list_slices(include_default=True)</code></li> <li>Memberships: <code>G.add_vertex_to_slice(id, v)</code>, <code>G.add_edge_to_slice(id, e)</code></li> <li>Set algebra: <code>G.slice_union(ids)</code>, <code>G.slice_intersection(ids)</code>, <code>G.slice_difference(a, b)</code></li> <li>Per\u2011slice edge overrides: <code>G.set_edge_slice_attrs(id, e, weight=...)</code>, <code>G.get_effective_edge_weight(e, slice=id)</code></li> </ul>"},{"location":"learn/explanation/managers-and-views/#layermanager-glayers","title":"LayerManager (<code>G.layers</code>)","text":"<ul> <li>Define aspects/layers: <code>G.set_aspects(aspects=[...], elem_layers={...})</code></li> <li>Presence: <code>G.add_presence(v, layer_tuple)</code>, <code>G.has_presence(v, layer_tuple)</code></li> <li>Edge types: <code>G.add_intra_edge_nl(u, v, layer)</code>, <code>G.add_inter_edge_nl(u, layer_u, v, layer_v)</code>, <code>G.add_coupling_edge_nl(v, layer_a, layer_b)</code></li> <li>Matrices: <code>G.supra_adjacency()</code>, <code>G.supra_laplacian(kind=\"comb\"|\"norm\")</code>, <code>G.adjacency_tensor_view()</code></li> </ul>"},{"location":"learn/explanation/managers-and-views/#indexmanager-gidx","title":"IndexManager (<code>G.idx</code>)","text":"<ul> <li>Vertex/entity maps: <code>entity_to_idx</code>, <code>idx_to_entity</code>, <code>entity_types</code></li> <li>Edge maps: <code>edge_to_idx</code>, <code>idx_to_edge</code></li> <li>Queries: <code>G.get_edge_ids(u, v)</code>, <code>G.has_vertex(v)</code>, <code>G.has_edge(edge_id=...)</code></li> </ul>"},{"location":"learn/explanation/managers-and-views/#cachemanager-gcache","title":"CacheManager (<code>G.cache</code>)","text":"<ul> <li>Materialize CSR/CSC: <code>G.cache.ensure_csr()</code>, <code>G.cache.ensure_csc()</code></li> <li>Clear caches: <code>G.cache.clear()</code></li> </ul>"},{"location":"learn/explanation/managers-and-views/#graph-views-and-subgraphs","title":"Graph views and subgraphs","text":"<ul> <li>Read\u2011only filter view: <code>G.view(vertices=[...], edges=[...], slices=[...])</code></li> <li>Materialized subgraphs:</li> <li>Vertex\u2011induced: <code>G.subgraph(vertices)</code></li> <li>Edge\u2011induced: <code>G.edge_subgraph(edges)</code></li> <li>Combined: <code>G.extract_subgraph(vertices=[...], edges=[...])</code></li> </ul>"},{"location":"learn/explanation/managers-and-views/#direction-and-hyperedges","title":"Direction and hyperedges","text":"<ul> <li>Edge direction: graph default via <code>Graph(directed=...)</code>, per\u2011edge override via <code>add_edge(..., edge_directed=...)</code></li> <li>Hyperedges:</li> <li>Undirected: <code>G.add_hyperedge(members=[...], weight=..., tag=...)</code></li> <li>Directed head\u2192tail: <code>G.add_hyperedge(head=[...], tail=[...], weight=...)</code></li> <li>Stoichiometry: <code>G.set_hyperedge_coeffs(eid, {vertex: coeff, ...})</code></li> </ul>"},{"location":"learn/explanation/managers-and-views/#backend-interoperability-proxies","title":"Backend interoperability (proxies)","text":"<ul> <li>NetworkX: <code>G.nx.&lt;algo&gt;(G)</code>; concrete graph via <code>G.nx.backend(directed=..., hyperedge_mode=\"skip|expand\", slice=..., simple=True)</code></li> <li>igraph: <code>G.ig.&lt;algo&gt;(G)</code> (if python\u2011igraph installed)</li> <li>graph\u2011tool: <code>G.gt.&lt;module&gt;.&lt;algo&gt;(...)</code> (if graph\u2011tool installed)</li> </ul> <p>See Architecture Overview for deeper context and data structures.</p>"},{"location":"learn/explanation/managers-and-views/#cheatsheet","title":"Cheatsheet","text":"Area Method One\u2011liner Slices <code>G.add_slice(id, **attrs)</code> Create a slice with optional metadata Slices <code>G.slices.active = id</code> Set current active slice Slices <code>G.slice_union(ids)</code> Union of multiple slices (membership) Slices <code>G.set_edge_slice_attrs(id, e, weight=...)</code> Override edge attrs in a slice Layers <code>G.set_aspects(aspects, elem_layers)</code> Define Kivel\u00e4 aspects/layers Layers <code>G.add_presence(v, layer_tuple)</code> Declare vertex presence in a layer Layers <code>G.supra_adjacency()</code> Build supra\u2011adjacency matrix Index <code>G.get_edge_ids(u, v)</code> List edge IDs between two vertices Index <code>G.has_vertex(v)</code> / <code>G.has_edge(...)</code> Membership checks Cache <code>G.cache.ensure_csr()</code> Materialize CSR; <code>ensure_csc()</code> for CSC Views <code>G.view(vertices=..., edges=..., slices=...)</code> Read\u2011only filtered view Subgraphs <code>G.subgraph(vertices)</code> Vertex\u2011induced subgraph Subgraphs <code>G.edge_subgraph(edges)</code> Edge\u2011induced subgraph Direction <code>Graph(directed=...)</code> Default directionality at graph level Direction <code>add_edge(..., edge_directed=...)</code> Per\u2011edge direction override Hyperedges <code>add_hyperedge(members=[...])</code> Undirected hyperedge Hyperedges <code>add_hyperedge(head=[...], tail=[...])</code> Directed hyperedge Proxies <code>G.nx.backend(..., simple=True)</code> Get NX graph; collapse multiedges"},{"location":"learn/explanation/math-incidence/","title":"Math: incidence matrix and operators","text":"<p>This page summarizes the core linear algebra behind annnet's incidence representation.</p>"},{"location":"learn/explanation/math-incidence/#incidence-matrix","title":"Incidence matrix","text":"<ul> <li>Let V be the set of entities (vertices and edge\u2011entities) and E the set of edges.</li> <li>The incidence matrix is <code>B \u2208 R^{|V|\u00d7|E|}</code>; each column corresponds to an edge <code>e \u2208 E</code>.</li> </ul> <p>Sign convention (one convenient choice): - Directed edge e: for each head/source endpoint <code>u</code>, set <code>B[u,e] = +w_e</code>; for each tail/target endpoint <code>v</code>, set <code>B[v,e] = \u2212w_e</code>. - Undirected edge e: for each endpoint <code>u</code>, set <code>B[u,e] = +w_e</code>. - Hyperedges: set non\u2011zeros for all members (undirected) or heads/tails (directed) accordingly.</p> <p>Weights and coefficients: - Edge weights <code>w_e</code> scale the column; stoichiometric coefficients (SBML) write directly into <code>B[:,e]</code> as endpoint\u2011specific values.</p>"},{"location":"learn/explanation/math-incidence/#native-support-for-complex-structures","title":"Native support for complex structures","text":"<ul> <li>Hyperedges: columns with more than two non\u2011zeros; directed hyperedges use signed entries to indicate head\u2192tail.</li> <li>Parallel edges: just more columns with the same endpoint sets (distinct edge IDs).</li> <li>Vertex\u2192edge and edge\u2192edge edges: edge\u2011entities occupy rows in V, so edges can connect any combination of rows.</li> </ul>"},{"location":"learn/explanation/math-incidence/#operators-from-incidence","title":"Operators from incidence","text":"<p>Let <code>W = diag(w_e)</code> be a diagonal matrix of per\u2011edge weights (or use the column norms if coefficients vary per endpoint).</p> <ul> <li>Undirected Laplacian: <code>L = B W B\u1d40</code> (positive semidefinite; generalizes to hyperedges).</li> <li>Directed adjacency (one construct):</li> <li>Split <code>B</code> into positive and negative parts: <code>B\u207a = max(B,0)</code>, <code>B\u207b = max(\u2212B,0)</code>.</li> <li>Define <code>A = B\u207a W (B\u207b)\u1d40</code> so that arcs go from heads to tails.</li> <li>Row\u2011stochastic transition: <code>P = D\u207b\u00b9 A</code> with <code>D = diag(A 1)</code> where <code>1</code> is the all\u2011ones vector.</li> </ul> <p>Notes: - Other directed Laplacians exist; the incidence construction above is compatible with several standard definitions. - In multilayer settings, construct the supra incidence <code>B\u0303</code> over <code>(vertex, layer)</code> pairs and apply the same formulas.</p>"},{"location":"learn/explanation/math-multilayer/","title":"Math: multilayer operators","text":"<p>Let <code>L = A\u2081 \u00d7 A\u2082 \u00d7 \u2026 \u00d7 A_k</code> be the cartesian product of aspects, where each aspect <code>A_i</code> has a finite set of elementary layers. A layer index is a tuple <code>\u03b1 \u2208 L</code>.</p>"},{"location":"learn/explanation/math-multilayer/#supra-incidence-and-adjacency","title":"Supra incidence and adjacency","text":"<ul> <li>Build the set of present vertex\u2011layers <code>V\u00d7M = {(v, \u03b1) : v has presence in layer \u03b1}</code>.</li> <li>Define supra incidence <code>B\u0303 \u2208 R^{|V\u00d7M| \u00d7 |E|}</code> by mapping each original endpoint <code>(v, \u03b1)</code> of edge <code>e</code> to a row in <code>B\u0303</code> with the same sign convention as the monolayer case.</li> </ul> <p>From <code>B\u0303</code>, obtain: - Supra Laplacian: <code>L\u0303 = B\u0303 W B\u0303\u1d40</code> (undirected or symmetrized case). - Directed supra adjacency: <code>\u00c2 = B\u0303\u207a W (B\u0303\u207b)\u1d40</code>.</p>"},{"location":"learn/explanation/math-multilayer/#tensor-representation","title":"Tensor representation","text":"<p>Alternatively, use a 4\u2011index tensor view <code>\ud835\udc9c[u, \u03b1, v, \u03b2]</code> giving the weight of arcs from <code>(u, \u03b1)</code> to <code>(v, \u03b2)</code>.</p> <ul> <li>Fold to supra adjacency by indexing <code>(u,\u03b1)</code> and <code>(v,\u03b2)</code> pairs.</li> <li>Unfold from supra adjacency back to tensor by inverting the index mapping.</li> </ul>"},{"location":"learn/explanation/math-multilayer/#edge-types-in-multilayer","title":"Edge types in multilayer","text":"<ul> <li>Intra\u2011layer: endpoints share the same layer tuple \u03b1.</li> <li>Inter\u2011layer: endpoints lie in different layer tuples.</li> <li>Coupling: endpoint is the same vertex across two layers <code>(v, \u03b1) \u2194 (v, \u03b2)</code>.</li> </ul> <p>These categories determine which blocks of <code>\u00c2</code> are populated and how presence constraints apply.</p>"},{"location":"learn/guides/","title":"HowTo / FAQ","text":"<p>This FAQ explains why annnet uses an incidence matrix, and how that naturally supports hyperedges, vertex\u2192edge edges, parallel edges, weights, and directionality.</p>"},{"location":"learn/guides/#why-incidence-matrix","title":"Why incidence matrix?","text":"<p>We represent the graph by a sparse incidence matrix <code>B \u2208 R^{|V| \u00d7 |E|}</code> where each column corresponds to an edge and each row corresponds to an entity (a vertex or an edge\u2011entity).</p> <p>Intuition: - Each edge is a column; its non\u2011zeros mark which entities it connects. - Direction is encoded by the sign:   - <code>+w</code> for a source/head membership   - <code>\u2212w</code> for a target/tail membership   - Undirected membership uses <code>+w</code> for all incident entities - Parallel edges are simply additional columns with the same endpoints. - Hyperedges set multiple <code>+w</code> or <code>\u2212w</code> entries in the column.</p> <p>Small example with weights and mixed edge types:</p> <pre><code>Entities (rows):   a,  b,  c,  d\nEdges (columns):  e1, e2, e3\n\nB =\n      e1  e2  e3\n a   +2   0  +1   # a is source in e1 (w=2), member in undirected e3 (w=1)\n b   -2  +1  +1   # b is target in e1 (w=2), member in e2/e3 (w=1)\n c    0  +1  +1   # c is member in e2/e3\n d    0  -2  +1   # d is target in e2 (w=2), member in e3\n\ne1: directed a \u2192 b (weight 2)\ne2: directed b \u2192 d (weight 2) but encoded as +1 on b and \u22122 on d (e.g., normalized head)\ne3: undirected hyperedge {a,b,c,d} (weight 1)\n</code></pre> <p>From <code>B</code>, you can construct familiar operators: - Undirected Laplacian: <code>L = B W B\u1d40</code> with diagonal <code>W = diag(w_e)</code> - Directed adjacency (one option): <code>A = B\u207a W (B\u207b)\u1d40</code> where <code>B\u207a = max(B,0)</code>, <code>B\u207b = max(\u2212B,0)</code></p>"},{"location":"learn/guides/#how-do-hyperedges-work","title":"How do hyperedges work?","text":"<p>Hyperedges are columns with more than two non\u2011zeros: - Undirected hyperedge over members <code>M</code> puts <code>+w</code> in rows for all <code>v \u2208 M</code>. - Directed hyperedge with head <code>H</code> and tail <code>T</code> puts <code>+w</code> in rows <code>v \u2208 H</code> and <code>\u2212w</code> in rows <code>v \u2208 T</code>. - Stoichiometric coefficients (e.g., SBML) write exact per\u2011endpoint weights into <code>B[:, e]</code>.</p> <p>This generalizes natively: no need to reify hyperedges into auxiliary nodes unless exporting to a format that requires it.</p>"},{"location":"learn/guides/#can-edges-connect-to-edges-vertexedge-edgeedge","title":"Can edges connect to edges (vertex\u2192edge, edge\u2192edge)?","text":"<p>Yes. annnet has a unified entity set: rows correspond to both vertices and edge\u2011entities. You can register an edge\u2011entity (row) and then create edges whose endpoints are vertices, edge\u2011entities, or mixed.</p> <p>Examples:</p> <pre><code>G.add_edge_entity(\"e_meta\", description=\"signal\")\nG.add_edge(\"e_meta\", \"C\", edge_type=\"vertex_edge\", edge_directed=True)\n# Edge\u2192edge is similar: endpoints can be previously declared edge\u2011entities\n</code></pre> <p>In the incidence matrix, those edge\u2011entities occupy rows like any vertex, so vertex\u2192edge and edge\u2192edge edges are just additional columns with non\u2011zeros at the appropriate rows.</p>"},{"location":"learn/guides/#how-are-parallel-edges-represented","title":"How are parallel edges represented?","text":"<p>Each parallel edge is its own column with a distinct ID. Aggregations are applied only when you explicitly request a simple backend graph (e.g., <code>G.nx.backend(..., simple=True)</code>), where multiple columns between the same endpoints are combined (e.g., summed weights).</p>"},{"location":"learn/guides/#how-are-weights-handled","title":"How are weights handled?","text":"<ul> <li>Column scale represents the edge weight. For binary edges, you either store the weight at the head (directed) or split symmetrically (undirected). For hyperedges, coefficients go into the respective incidence entries.</li> <li>annnet also supports per\u2011slice overrides (e.g., the same edge has different effective weights in different contexts) via <code>edge_slice_attributes</code>.</li> </ul>"},{"location":"learn/guides/#how-do-i-get-adjacency-and-laplacian","title":"How do I get adjacency and Laplacian?","text":"<p>Common constructions from the incidence matrix:</p> <pre><code>Let W = diag(w_e) be diagonal weights per edge.\nUndirected Laplacian:   L = B W B\u1d40\nDirected adjacency:     A = B\u207a W (B\u207b)\u1d40  with  B\u207a = max(B,0),  B\u207b = max(\u2212B,0)\nRow\u2011stochastic:         P = D\u207b\u00b9 A,  where D = diag(A 1)\n</code></pre> <p>annnet also provides multilayer (supra) versions of these matrices when layers/aspects are defined.</p>"},{"location":"learn/tutorials/quickstart/","title":"Quickstart","text":"<p>This quickstart shows how to create a graph, work with slices and annotations, add hyperedges, and run an algorithm through a backend proxy.</p>"},{"location":"learn/tutorials/quickstart/#install","title":"Install","text":"<pre><code>pip install annnet\n# optional backends and IO\npip install \"annnet[networkx,igraph]\" \"annnet[io]\"\n</code></pre>"},{"location":"learn/tutorials/quickstart/#build-a-small-graph","title":"Build a small graph","text":"<pre><code>import annnet as an\n\nG = an.Graph(directed=True)\nG.add_slice(\"toy\")\nG.slices.active = \"toy\"\n\nfor v in [\"A\", \"B\", \"C\", \"D\"]:\n    G.add_vertex(v, label=v, kind=\"gene\")\n\n# Binary edges (directed + undirected)\nG.add_edge(\"A\", \"B\", weight=2.0, edge_directed=True, relation=\"activates\")\nG.add_edge(\"B\", \"C\", weight=1.0, edge_directed=False, relation=\"binds\")\n\n# Hyperedge (directed head\u2192tail)\nG.add_hyperedge(head=[\"A\", \"B\"], tail=[\"C\", \"D\"], weight=1.0)\n</code></pre>"},{"location":"learn/tutorials/quickstart/#run-an-algorithm-networkx","title":"Run an algorithm (NetworkX)","text":"<pre><code># Requires networkx installed\ndeg = G.nx.degree_centrality(G)\n</code></pre> <p>You can fetch a concrete NetworkX graph with options:</p> <pre><code>nxG = G.nx.backend(\n    directed=True,\n    hyperedge_mode=\"skip\",  # or \"expand\"\n    slice=\"toy\",\n    simple=True,             # collapse multiedges\n)\n</code></pre>"},{"location":"learn/tutorials/quickstart/#convert-and-save","title":"Convert and save","text":"<pre><code>import annnet as an\n\n# File formats\nan.to_graphml(G, \"graph.graphml\", directed=True, hyperedge_mode=\"reify\")\n\n# Lossless storage\nan.annnet.write(G, \"my_graph.annnet\", overwrite=True)\nR = an.annnet.read(\"my_graph.annnet\")\n</code></pre> <p>Next steps: - See Explanations \u2192 Interoperability for round\u2011trip manifests. - See Explanations \u2192 annnet zero\u2011loss serialization for storage details.</p>"},{"location":"notebooks/SBUC/","title":"AnnNet Introduction - Multilayer Network Analysis in Systems Biology","text":"In\u00a0[1]: Copied! <pre># . Setup &amp; Initialization\n\nimport numpy as np\nimport polars as pl\nfrom scipy.sparse.linalg import eigsh\nfrom collections import defaultdict\n\nimport sys\nimport os\nsys.path.insert(0, os.path.abspath(\"..\"))\nfrom annnet.core.graph import Graph\n\n# visualization\nimport matplotlib.pyplot as plt\n</pre> # . Setup &amp; Initialization  import numpy as np import polars as pl from scipy.sparse.linalg import eigsh from collections import defaultdict  import sys import os sys.path.insert(0, os.path.abspath(\"..\")) from annnet.core.graph import Graph  # visualization import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre># . Initialize Graph with Full Configuration\n\nG = Graph(directed=None, n=100, e=300)  # None = mixed directionality allowed\n\n# Enable mutation history\nG.enable_history(True)\nG.mark(\"initialization\")\n\n# Set graph-level attributes (unstructured metadata)\nG.graph_attributes[\"name\"] = \"Multi-Omic Disease Network\"\nG.graph_attributes[\"organism\"] = \"Homo sapiens\"\nG.graph_attributes[\"disease_context\"] = \"inflammatory_pathway\"\nG.graph_attributes[\"version\"] = \"1.0\"\n\nprint(f\"Graph initialized: capacity={G._matrix.shape}, history={G._history_enabled}\")\nprint(f\"Graph attributes: {G.graph_attributes}\")\n</pre> # . Initialize Graph with Full Configuration  G = Graph(directed=None, n=100, e=300)  # None = mixed directionality allowed  # Enable mutation history G.enable_history(True) G.mark(\"initialization\")  # Set graph-level attributes (unstructured metadata) G.graph_attributes[\"name\"] = \"Multi-Omic Disease Network\" G.graph_attributes[\"organism\"] = \"Homo sapiens\" G.graph_attributes[\"disease_context\"] = \"inflammatory_pathway\" G.graph_attributes[\"version\"] = \"1.0\"  print(f\"Graph initialized: capacity={G._matrix.shape}, history={G._history_enabled}\") print(f\"Graph attributes: {G.graph_attributes}\")  <pre>Graph initialized: capacity=(100, 300), history=True\nGraph attributes: {'name': 'Multi-Omic Disease Network', 'organism': 'Homo sapiens', 'disease_context': 'inflammatory_pathway', 'version': '1.0'}\n</pre> In\u00a0[3]: Copied! <pre># . Define Multilayer Structure (Kivel\u00e4 Formalism)\n\n# Define multi-aspect structure\nG.set_aspects(\n    aspects=[\"omic\"],\n    elem_layers={\n        \"omic\": [\"PPI\", \"metabolic\", \"regulatory\", \"phenotype\"]\n    }\n)\n\n# Set aspect-level metadata\nG.set_aspect_attrs(\"omic\",\n    description=\"Biological interaction layer\",\n    data_sources=[\"STRING\", \"KEGG\", \"TRRUST\", \"DisGeNET\"]\n)\n\n# Set layer-level metadata\nG.set_layer_attrs((\"PPI\",), \n    interaction_type=\"physical\",\n    evidence=\"experimental\",\n    database=\"STRING\"\n)\nG.set_layer_attrs((\"metabolic\",),\n    interaction_type=\"enzymatic\", \n    pathways=[\"glycolysis\", \"TCA\", \"lipid\"],\n    database=\"KEGG\"\n)\nG.set_layer_attrs((\"regulatory\",),\n    interaction_type=\"transcriptional\",\n    direction=\"TF_to_target\",\n    database=\"TRRUST\"\n)\nG.set_layer_attrs((\"phenotype\",),\n    interaction_type=\"association\",\n    evidence=\"GWAS\",\n    database=\"DisGeNET\"\n)\n\nprint(f\"Aspects: {G.aspects}\")\nprint(f\"Elementary layers: {G.elem_layers}\")\nprint(f\"\\n=== Aspects View ===\")\nprint(G.aspects_view())\nprint(f\"\\n=== Layers View ===\")\nprint(G.layers_view())\n</pre> # . Define Multilayer Structure (Kivel\u00e4 Formalism)  # Define multi-aspect structure G.set_aspects(     aspects=[\"omic\"],     elem_layers={         \"omic\": [\"PPI\", \"metabolic\", \"regulatory\", \"phenotype\"]     } )  # Set aspect-level metadata G.set_aspect_attrs(\"omic\",     description=\"Biological interaction layer\",     data_sources=[\"STRING\", \"KEGG\", \"TRRUST\", \"DisGeNET\"] )  # Set layer-level metadata G.set_layer_attrs((\"PPI\",),      interaction_type=\"physical\",     evidence=\"experimental\",     database=\"STRING\" ) G.set_layer_attrs((\"metabolic\",),     interaction_type=\"enzymatic\",      pathways=[\"glycolysis\", \"TCA\", \"lipid\"],     database=\"KEGG\" ) G.set_layer_attrs((\"regulatory\",),     interaction_type=\"transcriptional\",     direction=\"TF_to_target\",     database=\"TRRUST\" ) G.set_layer_attrs((\"phenotype\",),     interaction_type=\"association\",     evidence=\"GWAS\",     database=\"DisGeNET\" )  print(f\"Aspects: {G.aspects}\") print(f\"Elementary layers: {G.elem_layers}\") print(f\"\\n=== Aspects View ===\") print(G.aspects_view()) print(f\"\\n=== Layers View ===\") print(G.layers_view()) <pre>Aspects: ['omic']\nElementary layers: {'omic': ['PPI', 'metabolic', 'regulatory', 'phenotype']}\n\n=== Aspects View ===\nshape: (1, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 aspect \u2506 elem_layers            \u2506 description                  \u2506 data_sources         \u2502\n\u2502 ---    \u2506 ---                    \u2506 ---                          \u2506 ---                  \u2502\n\u2502 str    \u2506 list[str]              \u2506 str                          \u2506 list[str]            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 omic   \u2506 [\"PPI\", \"metabolic\", \u2026 \u2506 Biological interaction layer \u2506 [\"STRING\", \"KEGG\", \u2026 \u2502\n\u2502        \u2506 \"phenot\u2026               \u2506                              \u2506 \"DisGeNET\u2026           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n=== Layers View ===\nshape: (4, 8)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 layer_tupl \u2506 layer_id   \u2506 omic       \u2506 interactio \u2506 evidence  \u2506 database \u2506 pathways  \u2506 direction \u2502\n\u2502 e          \u2506 ---        \u2506 ---        \u2506 n_type     \u2506 ---       \u2506 ---      \u2506 ---       \u2506 ---       \u2502\n\u2502 ---        \u2506 str        \u2506 str        \u2506 ---        \u2506 str       \u2506 str      \u2506 list[str] \u2506 str       \u2502\n\u2502 list[str]  \u2506            \u2506            \u2506 str        \u2506           \u2506          \u2506           \u2506           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [\"PPI\"]    \u2506 PPI        \u2506 PPI        \u2506 physical   \u2506 experimen \u2506 STRING   \u2506 null      \u2506 null      \u2502\n\u2502            \u2506            \u2506            \u2506            \u2506 tal       \u2506          \u2506           \u2506           \u2502\n\u2502 [\"metaboli \u2506 metabolic  \u2506 metabolic  \u2506 enzymatic  \u2506 null      \u2506 KEGG     \u2506 [\"glycoly \u2506 null      \u2502\n\u2502 c\"]        \u2506            \u2506            \u2506            \u2506           \u2506          \u2506 sis\",     \u2506           \u2502\n\u2502            \u2506            \u2506            \u2506            \u2506           \u2506          \u2506 \"TCA\",    \u2506           \u2502\n\u2502            \u2506            \u2506            \u2506            \u2506           \u2506          \u2506 \"lipid\"]  \u2506           \u2502\n\u2502 [\"regulato \u2506 regulatory \u2506 regulatory \u2506 transcript \u2506 null      \u2506 TRRUST   \u2506 null      \u2506 TF_to_tar \u2502\n\u2502 ry\"]       \u2506            \u2506            \u2506 ional      \u2506           \u2506          \u2506           \u2506 get       \u2502\n\u2502 [\"phenotyp \u2506 phenotype  \u2506 phenotype  \u2506 associatio \u2506 GWAS      \u2506 DisGeNET \u2506 null      \u2506 null      \u2502\n\u2502 e\"]        \u2506            \u2506            \u2506 n          \u2506           \u2506          \u2506           \u2506           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> In\u00a0[4]: Copied! <pre># . Create Biological Entities\n\n# Genes/proteins\ngenes = [\"GENE_A\", \"GENE_B\", \"GENE_C\", \"GENE_D\", \"GENE_E\", \n         \"GENE_F\", \"GENE_G\", \"GENE_H\", \"GENE_I\", \"GENE_J\"]\ntfs = [\"GENE_A\", \"GENE_C\", \"GENE_F\"]\nenzymes = [\"GENE_B\", \"GENE_D\", \"GENE_G\", \"GENE_I\"]\n\n# Metabolites\nmetabolites = [\"MET_1\", \"MET_2\", \"MET_3\", \"MET_4\", \"MET_5\", \"MET_6\"]\n\n# Phenotypes\nphenotypes = [\"inflammation\", \"cell_death\", \"proliferation\", \"immune_response\"]\n\n# Add genes with attributes\nfor g in genes:\n    G.add_vertex(g,\n        entity_type=\"gene\",\n        is_tf=(g in tfs),\n        is_enzyme=(g in enzymes),\n        chromosome=np.random.randint(1, 23),\n        expression_level=np.random.uniform(0, 100),\n        druggable=np.random.choice([True, False]),\n        annotation_source=\"Ensembl\"\n    )\n\n# Add metabolites\nfor i, m in enumerate(metabolites):\n    G.add_vertex(m,\n        entity_type=\"metabolite\",\n        molecular_weight=100 + i * 50,\n        pathway=\"glycolysis\" if i &lt; 3 else \"lipid\",\n        KEGG_id=f\"C{10000 + i}\",\n        concentration_uM=np.random.uniform(1, 1000)\n    )\n\n# Add phenotypes\nfor p in phenotypes:\n    G.add_vertex(p,\n        entity_type=\"phenotype\",\n        category=\"disease\" if p in [\"inflammation\", \"cell_death\"] else \"process\",\n        MeSH_id=f\"D{np.random.randint(10000, 99999)}\",\n        severity_score=np.random.uniform(0, 1)\n    )\n\nG.mark(\"vertices_added\")\nprint(f\"Total vertices: {G.number_of_vertices()}\")\n</pre> # . Create Biological Entities  # Genes/proteins genes = [\"GENE_A\", \"GENE_B\", \"GENE_C\", \"GENE_D\", \"GENE_E\",           \"GENE_F\", \"GENE_G\", \"GENE_H\", \"GENE_I\", \"GENE_J\"] tfs = [\"GENE_A\", \"GENE_C\", \"GENE_F\"] enzymes = [\"GENE_B\", \"GENE_D\", \"GENE_G\", \"GENE_I\"]  # Metabolites metabolites = [\"MET_1\", \"MET_2\", \"MET_3\", \"MET_4\", \"MET_5\", \"MET_6\"]  # Phenotypes phenotypes = [\"inflammation\", \"cell_death\", \"proliferation\", \"immune_response\"]  # Add genes with attributes for g in genes:     G.add_vertex(g,         entity_type=\"gene\",         is_tf=(g in tfs),         is_enzyme=(g in enzymes),         chromosome=np.random.randint(1, 23),         expression_level=np.random.uniform(0, 100),         druggable=np.random.choice([True, False]),         annotation_source=\"Ensembl\"     )  # Add metabolites for i, m in enumerate(metabolites):     G.add_vertex(m,         entity_type=\"metabolite\",         molecular_weight=100 + i * 50,         pathway=\"glycolysis\" if i &lt; 3 else \"lipid\",         KEGG_id=f\"C{10000 + i}\",         concentration_uM=np.random.uniform(1, 1000)     )  # Add phenotypes for p in phenotypes:     G.add_vertex(p,         entity_type=\"phenotype\",         category=\"disease\" if p in [\"inflammation\", \"cell_death\"] else \"process\",         MeSH_id=f\"D{np.random.randint(10000, 99999)}\",         severity_score=np.random.uniform(0, 1)     )  G.mark(\"vertices_added\") print(f\"Total vertices: {G.number_of_vertices()}\")    <pre>Total vertices: 20\n</pre> In\u00a0[5]: Copied! <pre># . Vertex Attribute Views (Polars DataFrames)\n\n# Full vertex attribute table\nprint(\"=== Complete Vertex Attributes ===\")\nprint(G.vertices_view())\n\n# Filter by entity type using Polars\nvertex_df = G.vertices_view()\nprint(\"\\n=== Genes Only ===\")\ngenes_df = vertex_df.filter(pl.col(\"entity_type\") == \"gene\")\nprint(genes_df)\n\n# Get specific attributes\nprint(\"\\n=== Enzymes with Expression Levels ===\")\nenzymes_df = vertex_df.filter(pl.col(\"is_enzyme\") == True).select([\n    \"vertex_id\", \"expression_level\", \"druggable\"\n])\nprint(enzymes_df)\n</pre> # . Vertex Attribute Views (Polars DataFrames)  # Full vertex attribute table print(\"=== Complete Vertex Attributes ===\") print(G.vertices_view())  # Filter by entity type using Polars vertex_df = G.vertices_view() print(\"\\n=== Genes Only ===\") genes_df = vertex_df.filter(pl.col(\"entity_type\") == \"gene\") print(genes_df)  # Get specific attributes print(\"\\n=== Enzymes with Expression Levels ===\") enzymes_df = vertex_df.filter(pl.col(\"is_enzyme\") == True).select([     \"vertex_id\", \"expression_level\", \"druggable\" ]) print(enzymes_df) <pre>=== Complete Vertex Attributes ===\nshape: (20, 15)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex_id   \u2506 entity_type \u2506 is_tf \u2506 is_enzyme \u2506 \u2026 \u2506 concentrat \u2506 category \u2506 MeSH_id \u2506 severity_s \u2502\n\u2502 ---         \u2506 ---         \u2506 ---   \u2506 ---       \u2506   \u2506 ion_uM     \u2506 ---      \u2506 ---     \u2506 core       \u2502\n\u2502 str         \u2506 str         \u2506 bool  \u2506 bool      \u2506   \u2506 ---        \u2506 str      \u2506 str     \u2506 ---        \u2502\n\u2502             \u2506             \u2506       \u2506           \u2506   \u2506 f64        \u2506          \u2506         \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_A      \u2506 gene        \u2506 true  \u2506 false     \u2506 \u2026 \u2506 null       \u2506 null     \u2506 null    \u2506 null       \u2502\n\u2502 GENE_B      \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null       \u2506 null     \u2506 null    \u2506 null       \u2502\n\u2502 GENE_C      \u2506 gene        \u2506 true  \u2506 false     \u2506 \u2026 \u2506 null       \u2506 null     \u2506 null    \u2506 null       \u2502\n\u2502 GENE_D      \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null       \u2506 null     \u2506 null    \u2506 null       \u2502\n\u2502 GENE_E      \u2506 gene        \u2506 false \u2506 false     \u2506 \u2026 \u2506 null       \u2506 null     \u2506 null    \u2506 null       \u2502\n\u2502 \u2026           \u2506 \u2026           \u2506 \u2026     \u2506 \u2026         \u2506 \u2026 \u2506 \u2026          \u2506 \u2026        \u2506 \u2026       \u2506 \u2026          \u2502\n\u2502 MET_6       \u2506 metabolite  \u2506 null  \u2506 null      \u2506 \u2026 \u2506 431.593551 \u2506 null     \u2506 null    \u2506 null       \u2502\n\u2502 inflammatio \u2506 phenotype   \u2506 null  \u2506 null      \u2506 \u2026 \u2506 null       \u2506 disease  \u2506 D20844  \u2506 0.454486   \u2502\n\u2502 n           \u2506             \u2506       \u2506           \u2506   \u2506            \u2506          \u2506         \u2506            \u2502\n\u2502 cell_death  \u2506 phenotype   \u2506 null  \u2506 null      \u2506 \u2026 \u2506 null       \u2506 disease  \u2506 D24921  \u2506 0.701903   \u2502\n\u2502 proliferati \u2506 phenotype   \u2506 null  \u2506 null      \u2506 \u2026 \u2506 null       \u2506 process  \u2506 D16617  \u2506 0.933925   \u2502\n\u2502 on          \u2506             \u2506       \u2506           \u2506   \u2506            \u2506          \u2506         \u2506            \u2502\n\u2502 immune_resp \u2506 phenotype   \u2506 null  \u2506 null      \u2506 \u2026 \u2506 null       \u2506 process  \u2506 D49895  \u2506 0.380994   \u2502\n\u2502 onse        \u2506             \u2506       \u2506           \u2506   \u2506            \u2506          \u2506         \u2506            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n=== Genes Only ===\nshape: (10, 15)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex_id \u2506 entity_type \u2506 is_tf \u2506 is_enzyme \u2506 \u2026 \u2506 concentrati \u2506 category \u2506 MeSH_id \u2506 severity_sc \u2502\n\u2502 ---       \u2506 ---         \u2506 ---   \u2506 ---       \u2506   \u2506 on_uM       \u2506 ---      \u2506 ---     \u2506 ore         \u2502\n\u2502 str       \u2506 str         \u2506 bool  \u2506 bool      \u2506   \u2506 ---         \u2506 str      \u2506 str     \u2506 ---         \u2502\n\u2502           \u2506             \u2506       \u2506           \u2506   \u2506 f64         \u2506          \u2506         \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_A    \u2506 gene        \u2506 true  \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_B    \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_C    \u2506 gene        \u2506 true  \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_D    \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_E    \u2506 gene        \u2506 false \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_F    \u2506 gene        \u2506 true  \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_G    \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_H    \u2506 gene        \u2506 false \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_I    \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_J    \u2506 gene        \u2506 false \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n=== Enzymes with Expression Levels ===\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex_id \u2506 expression_level \u2506 druggable \u2502\n\u2502 ---       \u2506 ---              \u2506 ---       \u2502\n\u2502 str       \u2506 f64              \u2506 str       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_B    \u2506 73.626742        \u2506 true      \u2502\n\u2502 GENE_D    \u2506 8.287539         \u2506 false     \u2502\n\u2502 GENE_G    \u2506 0.206838         \u2506 false     \u2502\n\u2502 GENE_I    \u2506 95.564032        \u2506 false     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> In\u00a0[6]: Copied! <pre># . Define Layer Presence (V_M)\n\n# PPI layer: all genes\nfor g in genes:\n    G.add_presence(g, (\"PPI\",))\n\n# Metabolic layer: metabolites + enzymes\nfor m in metabolites:\n    G.add_presence(m, (\"metabolic\",))\nfor e in enzymes:\n    G.add_presence(e, (\"metabolic\",))\n\n# Regulatory layer: all genes (TF -&gt; target relationships)\nfor g in genes:\n    G.add_presence(g, (\"regulatory\",))\n\n# Phenotype layer: phenotypes + disease-associated genes\nfor p in phenotypes:\n    G.add_presence(p, (\"phenotype\",))\nfor g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:\n    G.add_presence(g, (\"phenotype\",))\n\n# Set vertex-layer specific attributes\nG.set_vertex_layer_attrs(\"GENE_A\", (\"PPI\",), ppi_degree=5, hub_score=0.9)\nG.set_vertex_layer_attrs(\"GENE_A\", (\"regulatory\",), n_targets=3, tf_activity=0.8)\nG.set_vertex_layer_attrs(\"GENE_A\", (\"phenotype\",), disease_association=0.95)\n\nprint(f\"Total (vertex, layer) pairs: {len(G._VM)}\")\nfor layer in [(\"PPI\",), (\"metabolic\",), (\"regulatory\",), (\"phenotype\",)]:\n    verts = G.layer_vertex_set(layer)\n    print(f\"  {layer[0]}: {len(verts)} entities\")\n</pre> # . Define Layer Presence (V_M)  # PPI layer: all genes for g in genes:     G.add_presence(g, (\"PPI\",))  # Metabolic layer: metabolites + enzymes for m in metabolites:     G.add_presence(m, (\"metabolic\",)) for e in enzymes:     G.add_presence(e, (\"metabolic\",))  # Regulatory layer: all genes (TF -&gt; target relationships) for g in genes:     G.add_presence(g, (\"regulatory\",))  # Phenotype layer: phenotypes + disease-associated genes for p in phenotypes:     G.add_presence(p, (\"phenotype\",)) for g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:     G.add_presence(g, (\"phenotype\",))  # Set vertex-layer specific attributes G.set_vertex_layer_attrs(\"GENE_A\", (\"PPI\",), ppi_degree=5, hub_score=0.9) G.set_vertex_layer_attrs(\"GENE_A\", (\"regulatory\",), n_targets=3, tf_activity=0.8) G.set_vertex_layer_attrs(\"GENE_A\", (\"phenotype\",), disease_association=0.95)  print(f\"Total (vertex, layer) pairs: {len(G._VM)}\") for layer in [(\"PPI\",), (\"metabolic\",), (\"regulatory\",), (\"phenotype\",)]:     verts = G.layer_vertex_set(layer)     print(f\"  {layer[0]}: {len(verts)} entities\") <pre>Total (vertex, layer) pairs: 58\n  PPI: 10 entities\n  metabolic: 10 entities\n  regulatory: 10 entities\n  phenotype: 8 entities\n</pre> In\u00a0[7]: Copied! <pre># . Build Intra-Layer Edges with\n#\n# Binary Edge Expressiveness:\n# - Weighted edges\n# - Directed vs undirected; edge level and graph level; flexible directionality \n# - Parallel edges\n# - Self-loops\n# - Edge attributes\n# - Hybrid edges (edge-edge; vertex-edge)\n\n# === PPI Layer (UNDIRECTED, weighted) ===\nppi_edges = [\n    (\"GENE_A\", \"GENE_B\", 0.9),\n    (\"GENE_A\", \"GENE_C\", 0.8),\n    (\"GENE_A\", \"GENE_D\", 0.7),\n    (\"GENE_A\", \"GENE_E\", 0.6),\n    (\"GENE_B\", \"GENE_C\", 0.5),\n    (\"GENE_B\", \"GENE_F\", 0.8),\n    (\"GENE_C\", \"GENE_G\", 0.7),\n    (\"GENE_D\", \"GENE_H\", 0.6),\n    (\"GENE_E\", \"GENE_F\", 0.5),\n    (\"GENE_F\", \"GENE_G\", 0.9),\n    (\"GENE_F\", \"GENE_H\", 0.7),\n    (\"GENE_G\", \"GENE_I\", 0.6),\n    (\"GENE_H\", \"GENE_I\", 0.8),\n    (\"GENE_I\", \"GENE_J\", 0.9),\n    (\"GENE_J\", \"GENE_A\", 0.4),\n]\n\nfor src, tgt, w in ppi_edges:\n    eid = G.add_intra_edge_nl(src, tgt, (\"PPI\",), weight=w)\n    # Add edge attributes\n    G.set_edge_attrs(eid, \n        interaction_type=\"physical\",\n        evidence_score=w,\n        detection_method=\"co-IP\" if w &gt; 0.7 else \"Y2H\",\n        pubmed_ids=[f\"PMID{np.random.randint(10000000, 99999999)}\"]\n    )\n\n# === SELF-LOOP: Gene A auto-regulation ===\nself_loop_eid = G.add_intra_edge_nl(\"GENE_A\", \"GENE_A\", (\"PPI\",), weight=0.3)\nG.set_edge_attrs(self_loop_eid,\n    interaction_type=\"homodimerization\",\n    evidence_score=0.3,\n    note=\"GENE_A forms homodimer\"\n)\nprint(f\"Self-loop added: {self_loop_eid}\")\n\n# === PARALLEL EDGES: Multiple evidence types ===\n# Two different experiments detected GENE_B - GENE_F interaction\nparallel_eid_1 = G.add_intra_edge_nl(\"GENE_B\", \"GENE_F\", (\"PPI\",), weight=0.75,\n                                      eid=\"GENE_B--GENE_F@PPI_coIP\")\nG.set_edge_attrs(parallel_eid_1, detection_method=\"co-IP\", experiment_id=\"EXP001\")\n\nparallel_eid_2 = G.add_intra_edge_nl(\"GENE_B\", \"GENE_F\", (\"PPI\",), weight=0.65,\n                                      eid=\"GENE_B--GENE_F@PPI_Y2H\")\nG.set_edge_attrs(parallel_eid_2, detection_method=\"Y2H\", experiment_id=\"EXP002\")\n\nprint(f\"Parallel edges: {parallel_eid_1}, {parallel_eid_2}\")\n\n# === Metabolic Layer (UNDIRECTED for enzyme-metabolite associations) ===\nmetabolic_edges = [\n    (\"GENE_B\", \"MET_1\", 1.0),\n    (\"GENE_B\", \"MET_2\", 1.0),\n    (\"MET_1\", \"MET_2\", 0.8),\n    (\"GENE_D\", \"MET_2\", 1.0),\n    (\"GENE_D\", \"MET_3\", 1.0),\n    (\"MET_2\", \"MET_3\", 0.9),\n    (\"GENE_G\", \"MET_3\", 1.0),\n    (\"GENE_G\", \"MET_4\", 1.0),\n    (\"MET_3\", \"MET_4\", 0.7),\n    (\"GENE_I\", \"MET_4\", 1.0),\n    (\"GENE_I\", \"MET_5\", 1.0),\n    (\"GENE_I\", \"MET_6\", 1.0),\n    (\"MET_4\", \"MET_5\", 0.6),\n    (\"MET_5\", \"MET_6\", 0.8),\n]\n\nfor src, tgt, w in metabolic_edges:\n    eid = G.add_intra_edge_nl(src, tgt, (\"metabolic\",), weight=w)\n    # Determine if enzyme-metabolite or metabolite-metabolite\n    src_type = G.get_vertex_attrs(src).get(\"entity_type\")\n    tgt_type = G.get_vertex_attrs(tgt).get(\"entity_type\")\n    if src_type == \"gene\" or tgt_type == \"gene\":\n        G.set_edge_attrs(eid, reaction_type=\"catalysis\", reversible=False)\n    else:\n        G.set_edge_attrs(eid, reaction_type=\"conversion\", reversible=True)\n\n# === Regulatory Layer (DIRECTED: TF -&gt; Target) ===\nregulatory_edges = [\n    (\"GENE_A\", \"GENE_B\", 0.9, \"activation\"),\n    (\"GENE_A\", \"GENE_D\", 0.8, \"activation\"),\n    (\"GENE_A\", \"GENE_E\", 0.7, \"activation\"),\n    (\"GENE_C\", \"GENE_F\", 0.9, \"activation\"),\n    (\"GENE_C\", \"GENE_G\", 0.8, \"repression\"),  # repression\n    (\"GENE_C\", \"GENE_H\", 0.6, \"activation\"),\n    (\"GENE_F\", \"GENE_I\", 0.9, \"activation\"),\n    (\"GENE_F\", \"GENE_J\", 0.7, \"activation\"),\n    (\"GENE_H\", \"GENE_A\", 0.3, \"repression\"),  # negative feedback\n]\n\nfor src, tgt, w, reg_type in regulatory_edges:\n    # Regulatory edges are DIRECTED\n    eid = G.add_edge(src, tgt, weight=w, edge_directed=True,\n                     layer=(\"regulatory\",)[0])\n    G.set_edge_attrs(eid,\n        regulation_type=reg_type,\n        binding_site=\"promoter\",\n        confidence=w\n    )\n    # Also annotate with Kivel\u00e4 role\n    G.set_edge_kivela_role(eid, \"intra\", (\"regulatory\",))\n\n# === Phenotype Layer (UNDIRECTED associations) ===\nphenotype_edges = [\n    (\"GENE_A\", \"inflammation\", 0.9),\n    (\"GENE_A\", \"immune_response\", 0.7),\n    (\"GENE_C\", \"cell_death\", 0.8),\n    (\"GENE_F\", \"proliferation\", 0.9),\n    (\"GENE_F\", \"inflammation\", 0.5),\n    (\"GENE_H\", \"cell_death\", 0.6),\n    (\"GENE_H\", \"immune_response\", 0.4),\n    (\"inflammation\", \"immune_response\", 0.8),\n    (\"cell_death\", \"inflammation\", 0.6),\n    (\"proliferation\", \"cell_death\", 0.4),\n]\n\nfor src, tgt, w in phenotype_edges:\n    eid = G.add_intra_edge_nl(src, tgt, (\"phenotype\",), weight=w)\n    G.set_edge_attrs(eid,\n        association_type=\"GWAS\" if \"GENE\" in src else \"comorbidity\",\n        p_value=10**(-w*10),\n        odds_ratio=1 + w*2\n    )\n\nG.mark(\"intra_edges_added\")\nprint(f\"\\nTotal edges after intra-layer: {G.number_of_edges()}\")\nfor layer in [(\"PPI\",), (\"metabolic\",), (\"regulatory\",), (\"phenotype\",)]:\n    edges = G.layer_edge_set(layer)\n    print(f\"  {layer[0]}: {len(edges)} edges\")\n</pre> # . Build Intra-Layer Edges with # # Binary Edge Expressiveness: # - Weighted edges # - Directed vs undirected; edge level and graph level; flexible directionality  # - Parallel edges # - Self-loops # - Edge attributes # - Hybrid edges (edge-edge; vertex-edge)  # === PPI Layer (UNDIRECTED, weighted) === ppi_edges = [     (\"GENE_A\", \"GENE_B\", 0.9),     (\"GENE_A\", \"GENE_C\", 0.8),     (\"GENE_A\", \"GENE_D\", 0.7),     (\"GENE_A\", \"GENE_E\", 0.6),     (\"GENE_B\", \"GENE_C\", 0.5),     (\"GENE_B\", \"GENE_F\", 0.8),     (\"GENE_C\", \"GENE_G\", 0.7),     (\"GENE_D\", \"GENE_H\", 0.6),     (\"GENE_E\", \"GENE_F\", 0.5),     (\"GENE_F\", \"GENE_G\", 0.9),     (\"GENE_F\", \"GENE_H\", 0.7),     (\"GENE_G\", \"GENE_I\", 0.6),     (\"GENE_H\", \"GENE_I\", 0.8),     (\"GENE_I\", \"GENE_J\", 0.9),     (\"GENE_J\", \"GENE_A\", 0.4), ]  for src, tgt, w in ppi_edges:     eid = G.add_intra_edge_nl(src, tgt, (\"PPI\",), weight=w)     # Add edge attributes     G.set_edge_attrs(eid,          interaction_type=\"physical\",         evidence_score=w,         detection_method=\"co-IP\" if w &gt; 0.7 else \"Y2H\",         pubmed_ids=[f\"PMID{np.random.randint(10000000, 99999999)}\"]     )  # === SELF-LOOP: Gene A auto-regulation === self_loop_eid = G.add_intra_edge_nl(\"GENE_A\", \"GENE_A\", (\"PPI\",), weight=0.3) G.set_edge_attrs(self_loop_eid,     interaction_type=\"homodimerization\",     evidence_score=0.3,     note=\"GENE_A forms homodimer\" ) print(f\"Self-loop added: {self_loop_eid}\")  # === PARALLEL EDGES: Multiple evidence types === # Two different experiments detected GENE_B - GENE_F interaction parallel_eid_1 = G.add_intra_edge_nl(\"GENE_B\", \"GENE_F\", (\"PPI\",), weight=0.75,                                       eid=\"GENE_B--GENE_F@PPI_coIP\") G.set_edge_attrs(parallel_eid_1, detection_method=\"co-IP\", experiment_id=\"EXP001\")  parallel_eid_2 = G.add_intra_edge_nl(\"GENE_B\", \"GENE_F\", (\"PPI\",), weight=0.65,                                       eid=\"GENE_B--GENE_F@PPI_Y2H\") G.set_edge_attrs(parallel_eid_2, detection_method=\"Y2H\", experiment_id=\"EXP002\")  print(f\"Parallel edges: {parallel_eid_1}, {parallel_eid_2}\")  # === Metabolic Layer (UNDIRECTED for enzyme-metabolite associations) === metabolic_edges = [     (\"GENE_B\", \"MET_1\", 1.0),     (\"GENE_B\", \"MET_2\", 1.0),     (\"MET_1\", \"MET_2\", 0.8),     (\"GENE_D\", \"MET_2\", 1.0),     (\"GENE_D\", \"MET_3\", 1.0),     (\"MET_2\", \"MET_3\", 0.9),     (\"GENE_G\", \"MET_3\", 1.0),     (\"GENE_G\", \"MET_4\", 1.0),     (\"MET_3\", \"MET_4\", 0.7),     (\"GENE_I\", \"MET_4\", 1.0),     (\"GENE_I\", \"MET_5\", 1.0),     (\"GENE_I\", \"MET_6\", 1.0),     (\"MET_4\", \"MET_5\", 0.6),     (\"MET_5\", \"MET_6\", 0.8), ]  for src, tgt, w in metabolic_edges:     eid = G.add_intra_edge_nl(src, tgt, (\"metabolic\",), weight=w)     # Determine if enzyme-metabolite or metabolite-metabolite     src_type = G.get_vertex_attrs(src).get(\"entity_type\")     tgt_type = G.get_vertex_attrs(tgt).get(\"entity_type\")     if src_type == \"gene\" or tgt_type == \"gene\":         G.set_edge_attrs(eid, reaction_type=\"catalysis\", reversible=False)     else:         G.set_edge_attrs(eid, reaction_type=\"conversion\", reversible=True)  # === Regulatory Layer (DIRECTED: TF -&gt; Target) === regulatory_edges = [     (\"GENE_A\", \"GENE_B\", 0.9, \"activation\"),     (\"GENE_A\", \"GENE_D\", 0.8, \"activation\"),     (\"GENE_A\", \"GENE_E\", 0.7, \"activation\"),     (\"GENE_C\", \"GENE_F\", 0.9, \"activation\"),     (\"GENE_C\", \"GENE_G\", 0.8, \"repression\"),  # repression     (\"GENE_C\", \"GENE_H\", 0.6, \"activation\"),     (\"GENE_F\", \"GENE_I\", 0.9, \"activation\"),     (\"GENE_F\", \"GENE_J\", 0.7, \"activation\"),     (\"GENE_H\", \"GENE_A\", 0.3, \"repression\"),  # negative feedback ]  for src, tgt, w, reg_type in regulatory_edges:     # Regulatory edges are DIRECTED     eid = G.add_edge(src, tgt, weight=w, edge_directed=True,                      layer=(\"regulatory\",)[0])     G.set_edge_attrs(eid,         regulation_type=reg_type,         binding_site=\"promoter\",         confidence=w     )     # Also annotate with Kivel\u00e4 role     G.set_edge_kivela_role(eid, \"intra\", (\"regulatory\",))  # === Phenotype Layer (UNDIRECTED associations) === phenotype_edges = [     (\"GENE_A\", \"inflammation\", 0.9),     (\"GENE_A\", \"immune_response\", 0.7),     (\"GENE_C\", \"cell_death\", 0.8),     (\"GENE_F\", \"proliferation\", 0.9),     (\"GENE_F\", \"inflammation\", 0.5),     (\"GENE_H\", \"cell_death\", 0.6),     (\"GENE_H\", \"immune_response\", 0.4),     (\"inflammation\", \"immune_response\", 0.8),     (\"cell_death\", \"inflammation\", 0.6),     (\"proliferation\", \"cell_death\", 0.4), ]  for src, tgt, w in phenotype_edges:     eid = G.add_intra_edge_nl(src, tgt, (\"phenotype\",), weight=w)     G.set_edge_attrs(eid,         association_type=\"GWAS\" if \"GENE\" in src else \"comorbidity\",         p_value=10**(-w*10),         odds_ratio=1 + w*2     )  G.mark(\"intra_edges_added\") print(f\"\\nTotal edges after intra-layer: {G.number_of_edges()}\") for layer in [(\"PPI\",), (\"metabolic\",), (\"regulatory\",), (\"phenotype\",)]:     edges = G.layer_edge_set(layer)     print(f\"  {layer[0]}: {len(edges)} edges\") <pre>Self-loop added: GENE_A--GENE_A@PPI\nParallel edges: GENE_B--GENE_F@PPI_coIP, GENE_B--GENE_F@PPI_Y2H\n\nTotal edges after intra-layer: 51\n  PPI: 18 edges\n  metabolic: 14 edges\n  regulatory: 9 edges\n  phenotype: 10 edges\n</pre> In\u00a0[8]: Copied! <pre># . Edge Attribute Views\n\nprint(\"=== Edge Attributes View ===\")\nedges_df = G.edges_view(include_weight=True, include_directed=True)\nprint(edges_df.head(20))\n\n# Filter edges by attribute\nprint(\"\\n=== Regulatory Activation Edges ===\")\nreg_edges = G.edge_attributes.filter(pl.col(\"regulation_type\") == \"activation\")\nprint(reg_edges)\n\n# Get edges by attribute value\nrepression_edges = G.get_edges_by_attr(\"regulation_type\", \"repression\")\nprint(f\"\\nRepression edges: {repression_edges}\")\n</pre> # . Edge Attribute Views  print(\"=== Edge Attributes View ===\") edges_df = G.edges_view(include_weight=True, include_directed=True) print(edges_df.head(20))  # Filter edges by attribute print(\"\\n=== Regulatory Activation Edges ===\") reg_edges = G.edge_attributes.filter(pl.col(\"regulation_type\") == \"activation\") print(reg_edges)  # Get edges by attribute value repression_edges = G.get_edges_by_attr(\"regulation_type\", \"repression\") print(f\"\\nRepression edges: {repression_edges}\") <pre>=== Edge Attributes View ===\nshape: (20, 26)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge_id     \u2506 kind  \u2506 directed \u2506 global_wei \u2506 \u2026 \u2506 associatio \u2506 p_value \u2506 odds_ratio \u2506 effective_ \u2502\n\u2502 ---         \u2506 ---   \u2506 ---      \u2506 ght        \u2506   \u2506 n_type     \u2506 ---     \u2506 ---        \u2506 weight     \u2502\n\u2502 str         \u2506 str   \u2506 bool     \u2506 ---        \u2506   \u2506 ---        \u2506 f64     \u2506 f64        \u2506 ---        \u2502\n\u2502             \u2506       \u2506          \u2506 f64        \u2506   \u2506 str        \u2506         \u2506            \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_A--GEN \u2506 intra \u2506 true     \u2506 0.9        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.9        \u2502\n\u2502 E_B@PPI     \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_A--GEN \u2506 intra \u2506 true     \u2506 0.8        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.8        \u2502\n\u2502 E_C@PPI     \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_A--GEN \u2506 intra \u2506 true     \u2506 0.7        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.7        \u2502\n\u2502 E_D@PPI     \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_A--GEN \u2506 intra \u2506 true     \u2506 0.6        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.6        \u2502\n\u2502 E_E@PPI     \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_B--GEN \u2506 intra \u2506 true     \u2506 0.5        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.5        \u2502\n\u2502 E_C@PPI     \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 \u2026           \u2506 \u2026     \u2506 \u2026        \u2506 \u2026          \u2506 \u2026 \u2506 \u2026          \u2506 \u2026       \u2506 \u2026          \u2506 \u2026          \u2502\n\u2502 GENE_A--GEN \u2506 intra \u2506 true     \u2506 0.3        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.3        \u2502\n\u2502 E_A@PPI     \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_B--GEN \u2506 intra \u2506 true     \u2506 0.75       \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.75       \u2502\n\u2502 E_F@PPI_coI \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 P           \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_B--GEN \u2506 intra \u2506 true     \u2506 0.65       \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 0.65       \u2502\n\u2502 E_F@PPI_Y2H \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_B--MET \u2506 intra \u2506 true     \u2506 1.0        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 1.0        \u2502\n\u2502 _1@metaboli \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 c           \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 GENE_B--MET \u2506 intra \u2506 true     \u2506 1.0        \u2506 \u2026 \u2506 null       \u2506 null    \u2506 null       \u2506 1.0        \u2502\n\u2502 _2@metaboli \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2502 c           \u2506       \u2506          \u2506            \u2506   \u2506            \u2506         \u2506            \u2506            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n=== Regulatory Activation Edges ===\nshape: (7, 16)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge_id \u2506 layer      \u2506 interactio \u2506 evidence_s \u2506 \u2026 \u2506 confidenc \u2506 associati \u2506 p_value \u2506 odds_rati \u2502\n\u2502 ---     \u2506 ---        \u2506 n_type     \u2506 core       \u2506   \u2506 e         \u2506 on_type   \u2506 ---     \u2506 o         \u2502\n\u2502 str     \u2506 str        \u2506 ---        \u2506 ---        \u2506   \u2506 ---       \u2506 ---       \u2506 f64     \u2506 ---       \u2502\n\u2502         \u2506            \u2506 str        \u2506 f64        \u2506   \u2506 f64       \u2506 str       \u2506         \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 edge_0  \u2506 regulatory \u2506 null       \u2506 null       \u2506 \u2026 \u2506 0.9       \u2506 null      \u2506 null    \u2506 null      \u2502\n\u2502 edge_1  \u2506 regulatory \u2506 null       \u2506 null       \u2506 \u2026 \u2506 0.8       \u2506 null      \u2506 null    \u2506 null      \u2502\n\u2502 edge_2  \u2506 regulatory \u2506 null       \u2506 null       \u2506 \u2026 \u2506 0.7       \u2506 null      \u2506 null    \u2506 null      \u2502\n\u2502 edge_3  \u2506 regulatory \u2506 null       \u2506 null       \u2506 \u2026 \u2506 0.9       \u2506 null      \u2506 null    \u2506 null      \u2502\n\u2502 edge_5  \u2506 regulatory \u2506 null       \u2506 null       \u2506 \u2026 \u2506 0.6       \u2506 null      \u2506 null    \u2506 null      \u2502\n\u2502 edge_6  \u2506 regulatory \u2506 null       \u2506 null       \u2506 \u2026 \u2506 0.9       \u2506 null      \u2506 null    \u2506 null      \u2502\n\u2502 edge_7  \u2506 regulatory \u2506 null       \u2506 null       \u2506 \u2026 \u2506 0.7       \u2506 null      \u2506 null    \u2506 null      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRepression edges: ['edge_4', 'edge_8']\n</pre> In\u00a0[9]: Copied! <pre># . Hyperedges: Protein Complexes (Undirected)\n\n# Protein complexes as undirected hyperedges\ncomplexes = [\n    {\n        \"name\": \"TF_complex_A\",\n        \"members\": [\"GENE_A\", \"GENE_B\", \"GENE_C\"],\n        \"function\": \"transcription_initiation\"\n    },\n    {\n        \"name\": \"signaling_hub\",\n        \"members\": [\"GENE_F\", \"GENE_G\", \"GENE_H\", \"GENE_I\"],\n        \"function\": \"signal_transduction\"\n    },\n    {\n        \"name\": \"metabolic_complex\",\n        \"members\": [\"GENE_B\", \"GENE_D\", \"MET_2\"],\n        \"function\": \"metabolon\"\n    }\n]\n\nfor cplx in complexes:\n    valid_members = [m for m in cplx[\"members\"] if m in G.entity_to_idx]\n    if len(valid_members) &gt;= 2:\n        heid = G.add_hyperedge(\n            members=valid_members,\n            edge_id=f\"complex_{cplx['name']}\",\n            weight=1.0\n        )\n        G.set_edge_attrs(heid,\n            complex_name=cplx[\"name\"],\n            function=cplx[\"function\"],\n            n_subunits=len(valid_members),\n            stoichiometry=\"1:1:1\"\n        )\n        print(f\"Added hyperedge: {heid} with {len(valid_members)} members\")\n\nprint(f\"\\nHyperedge definitions: {G.hyperedge_definitions}\")\n</pre> # . Hyperedges: Protein Complexes (Undirected)  # Protein complexes as undirected hyperedges complexes = [     {         \"name\": \"TF_complex_A\",         \"members\": [\"GENE_A\", \"GENE_B\", \"GENE_C\"],         \"function\": \"transcription_initiation\"     },     {         \"name\": \"signaling_hub\",         \"members\": [\"GENE_F\", \"GENE_G\", \"GENE_H\", \"GENE_I\"],         \"function\": \"signal_transduction\"     },     {         \"name\": \"metabolic_complex\",         \"members\": [\"GENE_B\", \"GENE_D\", \"MET_2\"],         \"function\": \"metabolon\"     } ]  for cplx in complexes:     valid_members = [m for m in cplx[\"members\"] if m in G.entity_to_idx]     if len(valid_members) &gt;= 2:         heid = G.add_hyperedge(             members=valid_members,             edge_id=f\"complex_{cplx['name']}\",             weight=1.0         )         G.set_edge_attrs(heid,             complex_name=cplx[\"name\"],             function=cplx[\"function\"],             n_subunits=len(valid_members),             stoichiometry=\"1:1:1\"         )         print(f\"Added hyperedge: {heid} with {len(valid_members)} members\")  print(f\"\\nHyperedge definitions: {G.hyperedge_definitions}\") <pre>Added hyperedge: complex_TF_complex_A with 3 members\nAdded hyperedge: complex_signaling_hub with 4 members\nAdded hyperedge: complex_metabolic_complex with 3 members\n\nHyperedge definitions: {'complex_TF_complex_A': {'directed': False, 'members': {'GENE_C', 'GENE_A', 'GENE_B'}}, 'complex_signaling_hub': {'directed': False, 'members': {'GENE_H', 'GENE_I', 'GENE_G', 'GENE_F'}}, 'complex_metabolic_complex': {'directed': False, 'members': {'MET_2', 'GENE_D', 'GENE_B'}}}\n</pre> In\u00a0[10]: Copied! <pre># 0. Hyperedges: Multi-Substrate Reactions (Directed)\n\n# Directed hyperedges for metabolic reactions\n# head = substrates/enzymes, tail = products\n\ndirected_reactions = [\n    {\n        \"name\": \"glycolysis_step1\",\n        \"head\": [\"MET_1\", \"GENE_B\"],  # substrate + enzyme\n        \"tail\": [\"MET_2\"],             # product\n        \"stoich\": {\"MET_1\": -1, \"MET_2\": 1}\n    },\n    {\n        \"name\": \"glycolysis_step2\", \n        \"head\": [\"MET_2\", \"GENE_D\"],\n        \"tail\": [\"MET_3\"],\n        \"stoich\": {\"MET_2\": -1, \"MET_3\": 1}\n    },\n    {\n        \"name\": \"branch_point\",\n        \"head\": [\"MET_3\", \"GENE_G\"],\n        \"tail\": [\"MET_4\", \"MET_5\"],  # two products\n        \"stoich\": {\"MET_3\": -1, \"MET_4\": 0.5, \"MET_5\": 0.5}\n    }\n]\n\nfor rxn in directed_reactions:\n    valid_head = [h for h in rxn[\"head\"] if h in G.entity_to_idx]\n    valid_tail = [t for t in rxn[\"tail\"] if t in G.entity_to_idx]\n    \n    if valid_head and valid_tail:\n        heid = G.add_hyperedge(\n            head=valid_head,\n            tail=valid_tail,\n            edge_id=f\"rxn_{rxn['name']}\",\n            weight=1.0\n        )\n        G.set_edge_attrs(heid,\n            reaction_name=rxn[\"name\"],\n            EC_number=f\"EC:1.1.1.{np.random.randint(1,100)}\",\n            delta_G=-np.random.uniform(5, 30)\n        )\n        # Set stoichiometric coefficients\n        G.set_hyperedge_coeffs(heid, rxn[\"stoich\"])\n        print(f\"Added directed hyperedge: {heid}\")\n\nG.mark(\"hyperedges_added\")\n</pre> # 0. Hyperedges: Multi-Substrate Reactions (Directed)  # Directed hyperedges for metabolic reactions # head = substrates/enzymes, tail = products  directed_reactions = [     {         \"name\": \"glycolysis_step1\",         \"head\": [\"MET_1\", \"GENE_B\"],  # substrate + enzyme         \"tail\": [\"MET_2\"],             # product         \"stoich\": {\"MET_1\": -1, \"MET_2\": 1}     },     {         \"name\": \"glycolysis_step2\",          \"head\": [\"MET_2\", \"GENE_D\"],         \"tail\": [\"MET_3\"],         \"stoich\": {\"MET_2\": -1, \"MET_3\": 1}     },     {         \"name\": \"branch_point\",         \"head\": [\"MET_3\", \"GENE_G\"],         \"tail\": [\"MET_4\", \"MET_5\"],  # two products         \"stoich\": {\"MET_3\": -1, \"MET_4\": 0.5, \"MET_5\": 0.5}     } ]  for rxn in directed_reactions:     valid_head = [h for h in rxn[\"head\"] if h in G.entity_to_idx]     valid_tail = [t for t in rxn[\"tail\"] if t in G.entity_to_idx]          if valid_head and valid_tail:         heid = G.add_hyperedge(             head=valid_head,             tail=valid_tail,             edge_id=f\"rxn_{rxn['name']}\",             weight=1.0         )         G.set_edge_attrs(heid,             reaction_name=rxn[\"name\"],             EC_number=f\"EC:1.1.1.{np.random.randint(1,100)}\",             delta_G=-np.random.uniform(5, 30)         )         # Set stoichiometric coefficients         G.set_hyperedge_coeffs(heid, rxn[\"stoich\"])         print(f\"Added directed hyperedge: {heid}\")  G.mark(\"hyperedges_added\") <pre>Added directed hyperedge: rxn_glycolysis_step1\nAdded directed hyperedge: rxn_glycolysis_step2\nAdded directed hyperedge: rxn_branch_point\n</pre> In\u00a0[11]: Copied! <pre>import annnet.adapters.networkx_adapter as anx\nimport networkx as nx\n\n# Obtain a simple NX view (collapse Multi* edges with sensible aggregations)\nnxG, manifest = anx.to_nx(G, directed=True, hyperedge_mode=\"skip\") # skip, expand or reify\npos = nx.spring_layout(nxG, seed=42)\nplt.figure(figsize=(6,4))\nnx.draw(nxG, pos, with_labels=True, node_size=800)\nnx.draw_networkx_edge_labels(nxG, pos, edge_labels=nx.get_edge_attributes(nxG, 'weight'))\nplt.title('Demo graph (simple NX view)')\nplt.show()\n</pre> import annnet.adapters.networkx_adapter as anx import networkx as nx  # Obtain a simple NX view (collapse Multi* edges with sensible aggregations) nxG, manifest = anx.to_nx(G, directed=True, hyperedge_mode=\"skip\") # skip, expand or reify pos = nx.spring_layout(nxG, seed=42) plt.figure(figsize=(6,4)) nx.draw(nxG, pos, with_labels=True, node_size=800) nx.draw_networkx_edge_labels(nxG, pos, edge_labels=nx.get_edge_attributes(nxG, 'weight')) plt.title('Demo graph (simple NX view)') plt.show() In\u00a0[12]: Copied! <pre># 1. Edge Entities (Reactions as Nodes)\n\n# Create edge entities - reactions that can connect to other reactions\nreaction_entities = [\n    {\"id\": \"RXN_glycolysis_1\", \"enzyme\": \"GENE_B\", \"pathway\": \"glycolysis\"},\n    {\"id\": \"RXN_glycolysis_2\", \"enzyme\": \"GENE_D\", \"pathway\": \"glycolysis\"},\n    {\"id\": \"RXN_lipid_1\", \"enzyme\": \"GENE_G\", \"pathway\": \"lipid\"},\n]\n\nfor rxn in reaction_entities:\n    G.add_edge_entity(rxn[\"id\"],\n        entity_type=\"reaction\",\n        enzyme=rxn[\"enzyme\"],\n        pathway=rxn[\"pathway\"]\n    )\n\n# Connect substrates -&gt; reaction -&gt; products using vertex-edge edges\n# MET_1 -&gt; RXN_glycolysis_1 -&gt; MET_2\nG.add_edge(\"MET_1\", \"RXN_glycolysis_1\", edge_type=\"vertex_edge\", \n           weight=1.0, relation=\"substrate\")\nG.add_edge(\"RXN_glycolysis_1\", \"MET_2\", edge_type=\"vertex_edge\",\n           weight=1.0, relation=\"product\")\nG.add_edge(\"GENE_B\", \"RXN_glycolysis_1\", edge_type=\"vertex_edge\",\n           weight=1.0, relation=\"catalyzes\")\n\n# Chain reactions together\nG.add_edge(\"RXN_glycolysis_1\", \"RXN_glycolysis_2\", edge_type=\"vertex_edge\",\n           weight=1.0, relation=\"feeds_into\")\n\nprint(f\"Edge entities: {[e for e, t in G.entity_types.items() if t == 'edge']}\")\nG.mark(\"edge_entities_added\")\n</pre> # 1. Edge Entities (Reactions as Nodes)  # Create edge entities - reactions that can connect to other reactions reaction_entities = [     {\"id\": \"RXN_glycolysis_1\", \"enzyme\": \"GENE_B\", \"pathway\": \"glycolysis\"},     {\"id\": \"RXN_glycolysis_2\", \"enzyme\": \"GENE_D\", \"pathway\": \"glycolysis\"},     {\"id\": \"RXN_lipid_1\", \"enzyme\": \"GENE_G\", \"pathway\": \"lipid\"}, ]  for rxn in reaction_entities:     G.add_edge_entity(rxn[\"id\"],         entity_type=\"reaction\",         enzyme=rxn[\"enzyme\"],         pathway=rxn[\"pathway\"]     )  # Connect substrates -&gt; reaction -&gt; products using vertex-edge edges # MET_1 -&gt; RXN_glycolysis_1 -&gt; MET_2 G.add_edge(\"MET_1\", \"RXN_glycolysis_1\", edge_type=\"vertex_edge\",             weight=1.0, relation=\"substrate\") G.add_edge(\"RXN_glycolysis_1\", \"MET_2\", edge_type=\"vertex_edge\",            weight=1.0, relation=\"product\") G.add_edge(\"GENE_B\", \"RXN_glycolysis_1\", edge_type=\"vertex_edge\",            weight=1.0, relation=\"catalyzes\")  # Chain reactions together G.add_edge(\"RXN_glycolysis_1\", \"RXN_glycolysis_2\", edge_type=\"vertex_edge\",            weight=1.0, relation=\"feeds_into\")  print(f\"Edge entities: {[e for e, t in G.entity_types.items() if t == 'edge']}\") G.mark(\"edge_entities_added\") <pre>Edge entities: ['RXN_glycolysis_1', 'RXN_glycolysis_2', 'RXN_lipid_1']\n</pre> In\u00a0[13]: Copied! <pre># 2. Inter-Layer Coupling Edges\n\nomega = 1.0  # coupling strength\n\n# PPI &lt;-&gt; regulatory (all genes)\nfor g in genes:\n    G.add_coupling_edge_nl(g, (\"PPI\",), (\"regulatory\",), weight=omega)\n\n# PPI &lt;-&gt; metabolic (enzymes only)\nfor e in enzymes:\n    G.add_coupling_edge_nl(e, (\"PPI\",), (\"metabolic\",), weight=omega)\n\n# regulatory &lt;-&gt; metabolic (enzymes only)\nfor e in enzymes:\n    G.add_coupling_edge_nl(e, (\"regulatory\",), (\"metabolic\",), weight=omega)\n\n# PPI &lt;-&gt; phenotype (disease genes)\nfor g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:\n    G.add_coupling_edge_nl(g, (\"PPI\",), (\"phenotype\",), weight=omega)\n\n# regulatory &lt;-&gt; phenotype (disease genes)\nfor g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:\n    G.add_coupling_edge_nl(g, (\"regulatory\",), (\"phenotype\",), weight=omega)\n\ncoupling_edges = [e for e, k in G.edge_kind.items() if k == \"coupling\"]\nprint(f\"Total edges after coupling: {G.number_of_edges()}\")\nprint(f\"Coupling edges: {len(coupling_edges)}\")\nG.mark(\"coupling_edges_added\")\n</pre> # 2. Inter-Layer Coupling Edges  omega = 1.0  # coupling strength  # PPI &lt;-&gt; regulatory (all genes) for g in genes:     G.add_coupling_edge_nl(g, (\"PPI\",), (\"regulatory\",), weight=omega)  # PPI &lt;-&gt; metabolic (enzymes only) for e in enzymes:     G.add_coupling_edge_nl(e, (\"PPI\",), (\"metabolic\",), weight=omega)  # regulatory &lt;-&gt; metabolic (enzymes only) for e in enzymes:     G.add_coupling_edge_nl(e, (\"regulatory\",), (\"metabolic\",), weight=omega)  # PPI &lt;-&gt; phenotype (disease genes) for g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:     G.add_coupling_edge_nl(g, (\"PPI\",), (\"phenotype\",), weight=omega)  # regulatory &lt;-&gt; phenotype (disease genes) for g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:     G.add_coupling_edge_nl(g, (\"regulatory\",), (\"phenotype\",), weight=omega)  coupling_edges = [e for e, k in G.edge_kind.items() if k == \"coupling\"] print(f\"Total edges after coupling: {G.number_of_edges()}\") print(f\"Coupling edges: {len(coupling_edges)}\") G.mark(\"coupling_edges_added\") <pre>Total edges after coupling: 87\nCoupling edges: 26\n</pre> In\u00a0[14]: Copied! <pre># 3. Slices: Named Subgraph Partitions\n\n# Create slices from layers\nfor layer in [\"PPI\", \"metabolic\", \"regulatory\", \"phenotype\"]:\n    G.create_slice_from_layer(\n        slice_id=f\"layer_{layer}\",\n        layer_tuple=(layer,),\n        source=\"layer_extraction\",\n        description=f\"All entities in {layer} layer\"\n    )\n\n# Create functional slices\nG.add_slice(\"hub_genes\", description=\"High-degree genes\")\nfor g in [\"GENE_A\", \"GENE_F\"]:  # known hubs\n    G._slices[\"hub_genes\"][\"vertices\"].add(g)\n\nG.add_slice(\"disease_associated\", description=\"Phenotype-linked genes\")\nfor g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:\n    G._slices[\"disease_associated\"][\"vertices\"].add(g)\n\nG.add_slice(\"enzymes_only\", description=\"Metabolic enzymes\")\nfor e in enzymes:\n    G._slices[\"enzymes_only\"][\"vertices\"].add(e)\n\n# Set slice attributes\nG.set_slice_attrs(\"hub_genes\", centrality_threshold=0.8, n_hubs=2)\nG.set_slice_attrs(\"disease_associated\", disease=\"inflammatory\", source=\"DisGeNET\")\n\nprint(\"=== Slices View ===\")\nprint(G.slices_view())\n\nprint(\"\\n=== Slice Contents ===\")\nfor sid in G.list_slices():\n    info = G.get_slice_info(sid)\n    print(f\"  {sid}: {len(info['vertices'])} vertices, {len(info['edges'])} edges\")\n</pre> # 3. Slices: Named Subgraph Partitions  # Create slices from layers for layer in [\"PPI\", \"metabolic\", \"regulatory\", \"phenotype\"]:     G.create_slice_from_layer(         slice_id=f\"layer_{layer}\",         layer_tuple=(layer,),         source=\"layer_extraction\",         description=f\"All entities in {layer} layer\"     )  # Create functional slices G.add_slice(\"hub_genes\", description=\"High-degree genes\") for g in [\"GENE_A\", \"GENE_F\"]:  # known hubs     G._slices[\"hub_genes\"][\"vertices\"].add(g)  G.add_slice(\"disease_associated\", description=\"Phenotype-linked genes\") for g in [\"GENE_A\", \"GENE_C\", \"GENE_F\", \"GENE_H\"]:     G._slices[\"disease_associated\"][\"vertices\"].add(g)  G.add_slice(\"enzymes_only\", description=\"Metabolic enzymes\") for e in enzymes:     G._slices[\"enzymes_only\"][\"vertices\"].add(e)  # Set slice attributes G.set_slice_attrs(\"hub_genes\", centrality_threshold=0.8, n_hubs=2) G.set_slice_attrs(\"disease_associated\", disease=\"inflammatory\", source=\"DisGeNET\")  print(\"=== Slices View ===\") print(G.slices_view())  print(\"\\n=== Slice Contents ===\") for sid in G.list_slices():     info = G.get_slice_info(sid)     print(f\"  {sid}: {len(info['vertices'])} vertices, {len(info['edges'])} edges\") <pre>=== Slices View ===\nshape: (3, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 slice_id           \u2506 description         \u2506 centrality_thresho \u2506 n_hubs \u2506 disease      \u2506 source   \u2502\n\u2502 ---                \u2506 ---                 \u2506 ld                 \u2506 ---    \u2506 ---          \u2506 ---      \u2502\n\u2502 str                \u2506 str                 \u2506 ---                \u2506 i64    \u2506 str          \u2506 str      \u2502\n\u2502                    \u2506                     \u2506 f64                \u2506        \u2506              \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 hub_genes          \u2506 High-degree genes   \u2506 0.8                \u2506 2      \u2506 null         \u2506 null     \u2502\n\u2502 disease_associated \u2506 Phenotype-linked    \u2506 null               \u2506 null   \u2506 inflammatory \u2506 DisGeNET \u2502\n\u2502                    \u2506 genes               \u2506                    \u2506        \u2506              \u2506          \u2502\n\u2502 enzymes_only       \u2506 Metabolic enzymes   \u2506 null               \u2506 null   \u2506 null         \u2506 null     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n=== Slice Contents ===\n  layer_PPI: 10 vertices, 18 edges\n  layer_metabolic: 10 vertices, 14 edges\n  layer_regulatory: 10 vertices, 9 edges\n  layer_phenotype: 8 vertices, 10 edges\n  hub_genes: 2 vertices, 0 edges\n  disease_associated: 4 vertices, 0 edges\n  enzymes_only: 4 vertices, 0 edges\n</pre> In\u00a0[15]: Copied! <pre># 4. Slice Set Operations\n\n# Union of slices\nhub_disease_union = G.slice_union([\"hub_genes\", \"disease_associated\"])\nprint(f\"Hub \u222a Disease: {hub_disease_union['vertices']}\")\n\n# Intersection\nhub_disease_intersection = G.slice_intersection([\"hub_genes\", \"disease_associated\"])\nprint(f\"Hub \u2229 Disease: {hub_disease_intersection['vertices']}\")\n\n# Difference\ndisease_not_hub = G.slice_difference(\"disease_associated\", \"hub_genes\")\nprint(f\"Disease \\\\ Hub: {disease_not_hub['vertices']}\")\n\n# Create new slice from operation\nG.create_slice_from_operation(\n    \"hub_disease_overlap\",\n    hub_disease_intersection,\n    operation=\"intersection\",\n    description=\"Genes that are both hubs and disease-associated\"\n)\n\n# Layer algebra\nlayer_union = G.layer_union([(\"PPI\",), (\"regulatory\",)])\nprint(f\"\\nPPI \u222a regulatory: {len(layer_union['vertices'])} vertices\")\n\nlayer_intersection = G.layer_intersection([(\"PPI\",), (\"regulatory\",)])\nprint(f\"PPI \u2229 regulatory: {len(layer_intersection['vertices'])} vertices\")\n</pre> # 4. Slice Set Operations  # Union of slices hub_disease_union = G.slice_union([\"hub_genes\", \"disease_associated\"]) print(f\"Hub \u222a Disease: {hub_disease_union['vertices']}\")  # Intersection hub_disease_intersection = G.slice_intersection([\"hub_genes\", \"disease_associated\"]) print(f\"Hub \u2229 Disease: {hub_disease_intersection['vertices']}\")  # Difference disease_not_hub = G.slice_difference(\"disease_associated\", \"hub_genes\") print(f\"Disease \\\\ Hub: {disease_not_hub['vertices']}\")  # Create new slice from operation G.create_slice_from_operation(     \"hub_disease_overlap\",     hub_disease_intersection,     operation=\"intersection\",     description=\"Genes that are both hubs and disease-associated\" )  # Layer algebra layer_union = G.layer_union([(\"PPI\",), (\"regulatory\",)]) print(f\"\\nPPI \u222a regulatory: {len(layer_union['vertices'])} vertices\")  layer_intersection = G.layer_intersection([(\"PPI\",), (\"regulatory\",)]) print(f\"PPI \u2229 regulatory: {len(layer_intersection['vertices'])} vertices\")  <pre>Hub \u222a Disease: {'GENE_C', 'GENE_A', 'GENE_H', 'GENE_F'}\nHub \u2229 Disease: {'GENE_A', 'GENE_F'}\nDisease \\ Hub: {'GENE_C', 'GENE_H'}\n\nPPI \u222a regulatory: 10 vertices\nPPI \u2229 regulatory: 10 vertices\n</pre> In\u00a0[16]: Copied! <pre># 5. Per-Slice Edge Weights\n\n# Same edge can have different weights in different contexts\n# Create context slices\nG.add_slice(\"healthy_context\", condition=\"healthy\")\nG.add_slice(\"disease_context\", condition=\"inflammatory\")\n\n# Get an edge ID\ntest_edge = list(G.edge_definitions.keys())[0]\nprint(f\"Testing per-slice weights on edge: {test_edge}\")\n\n# Set different weights for different contexts\nG.set_edge_slice_attrs(\"healthy_context\", test_edge, weight=0.5, context_note=\"baseline\")\nG.set_edge_slice_attrs(\"disease_context\", test_edge, weight=2.0, context_note=\"upregulated\")\n\n# Query effective weights\nw_healthy = G.get_effective_edge_weight(test_edge, slice=\"healthy_context\")\nw_disease = G.get_effective_edge_weight(test_edge, slice=\"disease_context\")\nw_global = G.get_effective_edge_weight(test_edge)\n\nprint(f\"Weight in healthy context: {w_healthy}\")\nprint(f\"Weight in disease context: {w_disease}\")\nprint(f\"Global weight: {w_global}\")\n</pre> # 5. Per-Slice Edge Weights  # Same edge can have different weights in different contexts # Create context slices G.add_slice(\"healthy_context\", condition=\"healthy\") G.add_slice(\"disease_context\", condition=\"inflammatory\")  # Get an edge ID test_edge = list(G.edge_definitions.keys())[0] print(f\"Testing per-slice weights on edge: {test_edge}\")  # Set different weights for different contexts G.set_edge_slice_attrs(\"healthy_context\", test_edge, weight=0.5, context_note=\"baseline\") G.set_edge_slice_attrs(\"disease_context\", test_edge, weight=2.0, context_note=\"upregulated\")  # Query effective weights w_healthy = G.get_effective_edge_weight(test_edge, slice=\"healthy_context\") w_disease = G.get_effective_edge_weight(test_edge, slice=\"disease_context\") w_global = G.get_effective_edge_weight(test_edge)  print(f\"Weight in healthy context: {w_healthy}\") print(f\"Weight in disease context: {w_disease}\") print(f\"Global weight: {w_global}\")   <pre>Testing per-slice weights on edge: GENE_A--GENE_B@PPI\nWeight in healthy context: 0.5\nWeight in disease context: 2.0\nGlobal weight: 0.9\n</pre> In\u00a0[17]: Copied! <pre># 6. AnnData-like API\n\nprint(\"=== AnnData-like API ===\")\n\n# X() - incidence matrix\nX = G.X()\nprint(f\"G.X() shape: {X.shape}, nnz: {X.nnz}\")\nprint(f\"  (entities x edges incidence matrix)\")\n\n# obs - vertex attributes (observations)\nobs = G.obs\nprint(f\"\\nG.obs (vertex attributes):\")\nprint(obs.head())\n\n# var - edge attributes (variables)\nvar = G.var\nprint(f\"\\nG.var (edge attributes):\")\nprint(var.head())\n\n# uns - unstructured metadata\nuns = G.uns\nprint(f\"\\nG.uns (graph attributes):\")\nprint(uns)\n</pre> # 6. AnnData-like API  print(\"=== AnnData-like API ===\")  # X() - incidence matrix X = G.X() print(f\"G.X() shape: {X.shape}, nnz: {X.nnz}\") print(f\"  (entities x edges incidence matrix)\")  # obs - vertex attributes (observations) obs = G.obs print(f\"\\nG.obs (vertex attributes):\") print(obs.head())  # var - edge attributes (variables) var = G.var print(f\"\\nG.var (edge attributes):\") print(var.head())  # uns - unstructured metadata uns = G.uns print(f\"\\nG.uns (graph attributes):\") print(uns)  <pre>=== AnnData-like API ===\nG.X() shape: (100, 300), nnz: 155\n  (entities x edges incidence matrix)\n\nG.obs (vertex attributes):\nshape: (5, 15)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex_id \u2506 entity_type \u2506 is_tf \u2506 is_enzyme \u2506 \u2026 \u2506 concentrati \u2506 category \u2506 MeSH_id \u2506 severity_sc \u2502\n\u2502 ---       \u2506 ---         \u2506 ---   \u2506 ---       \u2506   \u2506 on_uM       \u2506 ---      \u2506 ---     \u2506 ore         \u2502\n\u2502 str       \u2506 str         \u2506 bool  \u2506 bool      \u2506   \u2506 ---         \u2506 str      \u2506 str     \u2506 ---         \u2502\n\u2502           \u2506             \u2506       \u2506           \u2506   \u2506 f64         \u2506          \u2506         \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_A    \u2506 gene        \u2506 true  \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_B    \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_C    \u2506 gene        \u2506 true  \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_D    \u2506 gene        \u2506 false \u2506 true      \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2502 GENE_E    \u2506 gene        \u2506 false \u2506 false     \u2506 \u2026 \u2506 null        \u2506 null     \u2506 null    \u2506 null        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nG.var (edge attributes):\nshape: (5, 27)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge_id      \u2506 layer \u2506 interaction \u2506 evidence_sc \u2506 \u2026 \u2506 entity_type \u2506 enzyme \u2506 pathway \u2506 relation \u2502\n\u2502 ---          \u2506 ---   \u2506 _type       \u2506 ore         \u2506   \u2506 ---         \u2506 ---    \u2506 ---     \u2506 ---      \u2502\n\u2502 str          \u2506 str   \u2506 ---         \u2506 ---         \u2506   \u2506 str         \u2506 str    \u2506 str     \u2506 str      \u2502\n\u2502              \u2506       \u2506 str         \u2506 f64         \u2506   \u2506             \u2506        \u2506         \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_A--GENE \u2506 PPI   \u2506 physical    \u2506 0.9         \u2506 \u2026 \u2506 null        \u2506 null   \u2506 null    \u2506 null     \u2502\n\u2502 _B@PPI       \u2506       \u2506             \u2506             \u2506   \u2506             \u2506        \u2506         \u2506          \u2502\n\u2502 GENE_A--GENE \u2506 PPI   \u2506 physical    \u2506 0.8         \u2506 \u2026 \u2506 null        \u2506 null   \u2506 null    \u2506 null     \u2502\n\u2502 _C@PPI       \u2506       \u2506             \u2506             \u2506   \u2506             \u2506        \u2506         \u2506          \u2502\n\u2502 GENE_A--GENE \u2506 PPI   \u2506 physical    \u2506 0.7         \u2506 \u2026 \u2506 null        \u2506 null   \u2506 null    \u2506 null     \u2502\n\u2502 _D@PPI       \u2506       \u2506             \u2506             \u2506   \u2506             \u2506        \u2506         \u2506          \u2502\n\u2502 GENE_A--GENE \u2506 PPI   \u2506 physical    \u2506 0.6         \u2506 \u2026 \u2506 null        \u2506 null   \u2506 null    \u2506 null     \u2502\n\u2502 _E@PPI       \u2506       \u2506             \u2506             \u2506   \u2506             \u2506        \u2506         \u2506          \u2502\n\u2502 GENE_B--GENE \u2506 PPI   \u2506 physical    \u2506 0.5         \u2506 \u2026 \u2506 null        \u2506 null   \u2506 null    \u2506 null     \u2502\n\u2502 _C@PPI       \u2506       \u2506             \u2506             \u2506   \u2506             \u2506        \u2506         \u2506          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nG.uns (graph attributes):\n{'name': 'Multi-Omic Disease Network', 'organism': 'Homo sapiens', 'disease_context': 'inflammatory_pathway', 'version': '1.0'}\n</pre> In\u00a0[18]: Copied! <pre># 7. Managers' APIs\n\nprint(\"=== Manager APIs ===\")\n\n# Slice manager\nslices_mgr = G.slices\nprint(f\"G.slices: {type(slices_mgr)}\")\n\n# Layer manager\nlayers_mgr = G.layers\nprint(f\"G.layers: {type(layers_mgr)}\")\n\n# Index manager\nidx_mgr = G.idx\nprint(f\"G.idx: {type(idx_mgr)}\")\n\n# Cache manager\ncache_mgr = G.cache\nprint(f\"G.cache: {type(cache_mgr)}\")\n\n# Use index manager for lookups\nprint(f\"\\nIndex lookups via G.idx:\")\nprint(f\"  GENE_A row index: {G.entity_to_idx.get('GENE_A')}\")\nprint(f\"  Edge 0 ID: {G.idx_to_edge.get(0)}\")\n</pre> # 7. Managers' APIs  print(\"=== Manager APIs ===\")  # Slice manager slices_mgr = G.slices print(f\"G.slices: {type(slices_mgr)}\")  # Layer manager layers_mgr = G.layers print(f\"G.layers: {type(layers_mgr)}\")  # Index manager idx_mgr = G.idx print(f\"G.idx: {type(idx_mgr)}\")  # Cache manager cache_mgr = G.cache print(f\"G.cache: {type(cache_mgr)}\")  # Use index manager for lookups print(f\"\\nIndex lookups via G.idx:\") print(f\"  GENE_A row index: {G.entity_to_idx.get('GENE_A')}\") print(f\"  Edge 0 ID: {G.idx_to_edge.get(0)}\")  <pre>=== Manager APIs ===\nG.slices: &lt;class 'annnet.core._SliceManager.SliceManager'&gt;\nG.layers: &lt;class 'annnet.core._LayerManager.LayerManager'&gt;\nG.idx: &lt;class 'annnet.core._IndexManager.IndexManager'&gt;\nG.cache: &lt;class 'annnet.core._CacheManager.CacheManager'&gt;\n\nIndex lookups via G.idx:\n  GENE_A row index: 0\n  Edge 0 ID: GENE_A--GENE_B@PPI\n</pre> In\u00a0[21]: Copied! <pre># 8. Build Supra-Adjacency and Supra-Laplacian\n\n# Build vertex-layer index\nn_supra = G.ensure_vertex_layer_index()\nprint(f\"Supra-graph size: {n_supra} nodes\")\n\n# Supra-adjacency matrix\nA_supra = G.supra_adjacency()\nprint(f\"Supra-adjacency: {A_supra.shape}, nnz={A_supra.nnz}\")\n\n# Supra-Laplacian (combinatorial)\nL_supra = G.supra_laplacian(kind=\"comb\")\nprint(f\"Supra-Laplacian (combinatorial): {L_supra.shape}\")\n\n# Normalized Laplacian\nL_norm = G.supra_laplacian(kind=\"norm\")\nprint(f\"Supra-Laplacian (normalized): {L_norm.shape}\")\n\n# Verify Laplacian property (row sums = 0)\nrow_sums = np.abs(L_supra.sum(axis=1).A.ravel())\nprint(f\"Max row sum (should be ~0): {row_sums.max():.2e}\")\n\n# Transition matrix (random walk)\nP = G.transition_matrix()\nprint(f\"Transition matrix: {P.shape}\")\n\n# 9. Spectral Analysis\n\n# Compute smallest eigenvalues\nk = min(10, n_supra - 1)\neigenvalues, eigenvectors = eigsh(L_supra.astype(float), k=k, which=\"SM\")\n\n# Sort\nidx = np.argsort(eigenvalues)\neigenvalues = eigenvalues[idx]\neigenvectors = eigenvectors[:, idx]\n\nprint(\"Smallest eigenvalues of supra-Laplacian:\")\nfor i, ev in enumerate(eigenvalues):\n    print(f\"  \u03bb_{i} = {ev:.6f}\")\n\n# Algebraic connectivity\nlambda2, fiedler = G.algebraic_connectivity()\nprint(f\"\\nAlgebraic connectivity (\u03bb\u2082): {lambda2:.6f}\")\n\nprint('===========================================\\n')\n\n# Via AnnNet built in method\nvals, vecs = G.k_smallest_laplacian_eigs(k=6)\nprint(f\"6 smallest eigenvalues: {vals}\")\n</pre> # 8. Build Supra-Adjacency and Supra-Laplacian  # Build vertex-layer index n_supra = G.ensure_vertex_layer_index() print(f\"Supra-graph size: {n_supra} nodes\")  # Supra-adjacency matrix A_supra = G.supra_adjacency() print(f\"Supra-adjacency: {A_supra.shape}, nnz={A_supra.nnz}\")  # Supra-Laplacian (combinatorial) L_supra = G.supra_laplacian(kind=\"comb\") print(f\"Supra-Laplacian (combinatorial): {L_supra.shape}\")  # Normalized Laplacian L_norm = G.supra_laplacian(kind=\"norm\") print(f\"Supra-Laplacian (normalized): {L_norm.shape}\")  # Verify Laplacian property (row sums = 0) row_sums = np.abs(L_supra.sum(axis=1).A.ravel()) print(f\"Max row sum (should be ~0): {row_sums.max():.2e}\")  # Transition matrix (random walk) P = G.transition_matrix() print(f\"Transition matrix: {P.shape}\")  # 9. Spectral Analysis  # Compute smallest eigenvalues k = min(10, n_supra - 1) eigenvalues, eigenvectors = eigsh(L_supra.astype(float), k=k, which=\"SM\")  # Sort idx = np.argsort(eigenvalues) eigenvalues = eigenvalues[idx] eigenvectors = eigenvectors[:, idx]  print(\"Smallest eigenvalues of supra-Laplacian:\") for i, ev in enumerate(eigenvalues):     print(f\"  \u03bb_{i} = {ev:.6f}\")  # Algebraic connectivity lambda2, fiedler = G.algebraic_connectivity() print(f\"\\nAlgebraic connectivity (\u03bb\u2082): {lambda2:.6f}\")  print('===========================================\\n')  # Via AnnNet built in method vals, vecs = G.k_smallest_laplacian_eigs(k=6) print(f\"6 smallest eigenvalues: {vals}\") <pre>Supra-graph size: 58 nodes\nSupra-adjacency: (58, 58), nnz=149\nSupra-Laplacian (combinatorial): (58, 58)\nSupra-Laplacian (normalized): (58, 58)\nMax row sum (should be ~0): 8.88e-16\nTransition matrix: (58, 58)\nSmallest eigenvalues of supra-Laplacian:\n  \u03bb_0 = 0.000000\n  \u03bb_1 = 0.373097\n  \u03bb_2 = 0.477402\n  \u03bb_3 = 0.712494\n  \u03bb_4 = 0.752686\n  \u03bb_5 = 0.905949\n  \u03bb_6 = 0.924666\n  \u03bb_7 = 1.119068\n  \u03bb_8 = 1.223944\n  \u03bb_9 = 1.497997\n\nAlgebraic connectivity (\u03bb\u2082): 0.373097\n===========================================\n\n6 smallest eigenvalues: [2.49800181e-16 3.73096685e-01 4.77402436e-01 7.12494350e-01\n 7.52685709e-01 9.05949334e-01]\n</pre> In\u00a0[22]: Copied! <pre># . Lazy NetworkX Proxy (G.nx)\n\nprint(\"=== Lazy NetworkX Proxy ===\")\nprint(\"Using G.nx.algorithm(G, ...) pattern\")\n\n# Degree centrality via lazy proxy\ndegree_cent = G.nx.degree_centrality(G)\ntop_degree = sorted(degree_cent.items(), key=lambda x: -x[1])[:5]\nprint(f\"\\nTop 5 by degree centrality:\")\nfor node, cent in top_degree:\n    print(f\"  {node}: {cent:.4f}\")\n\n# Betweenness centrality\nbetweenness = G.nx.betweenness_centrality(G)\ntop_between = sorted(betweenness.items(), key=lambda x: -x[1])[:5]\nprint(f\"\\nTop 5 by betweenness centrality:\")\nfor node, cent in top_between:\n    print(f\"  {node}: {cent:.4f}\")\n\n# PageRank\npagerank = G.nx.pagerank(G, alpha=0.85)\ntop_pr = sorted(pagerank.items(), key=lambda x: -x[1])[:5]\nprint(f\"\\nTop 5 by PageRank:\")\nfor node, pr in top_pr:\n    print(f\"  {node}: {pr:.4f}\")\n\n\n# Shortest path\n\npath = G.nx.shortest_path(G, \"GENE_A\", \"GENE_F\")\nsp = []\nfor i in path:\n    sp.append(G.idx.row_to_entity(i))\nprint(f\"\\nShortest path GENE_A \u2192 inflammation: {(sp)}\")\n\n# Community detection (Louvain)\n\ncommunities = G.nx.louvain_communities(G, seed=79)\nprint(f\"\\nLouvain communities: {len(communities)}\")\nfor i, comm in enumerate(communities[:4]):\n    print(f\"  Community {i}: {list(comm)[:10]}...\")\n</pre> # . Lazy NetworkX Proxy (G.nx)  print(\"=== Lazy NetworkX Proxy ===\") print(\"Using G.nx.algorithm(G, ...) pattern\")  # Degree centrality via lazy proxy degree_cent = G.nx.degree_centrality(G) top_degree = sorted(degree_cent.items(), key=lambda x: -x[1])[:5] print(f\"\\nTop 5 by degree centrality:\") for node, cent in top_degree:     print(f\"  {node}: {cent:.4f}\")  # Betweenness centrality betweenness = G.nx.betweenness_centrality(G) top_between = sorted(betweenness.items(), key=lambda x: -x[1])[:5] print(f\"\\nTop 5 by betweenness centrality:\") for node, cent in top_between:     print(f\"  {node}: {cent:.4f}\")  # PageRank pagerank = G.nx.pagerank(G, alpha=0.85) top_pr = sorted(pagerank.items(), key=lambda x: -x[1])[:5] print(f\"\\nTop 5 by PageRank:\") for node, pr in top_pr:     print(f\"  {node}: {pr:.4f}\")   # Shortest path  path = G.nx.shortest_path(G, \"GENE_A\", \"GENE_F\") sp = [] for i in path:     sp.append(G.idx.row_to_entity(i)) print(f\"\\nShortest path GENE_A \u2192 inflammation: {(sp)}\")  # Community detection (Louvain)  communities = G.nx.louvain_communities(G, seed=79) print(f\"\\nLouvain communities: {len(communities)}\") for i, comm in enumerate(communities[:4]):     print(f\"  Community {i}: {list(comm)[:10]}...\") <pre>=== Lazy NetworkX Proxy ===\nUsing G.nx.algorithm(G, ...) pattern\n\nTop 5 by degree centrality:\n  1: 1.1429\n  0: 1.0952\n  5: 1.0952\n  6: 0.9524\n  7: 0.9048\n\nTop 5 by betweenness centrality:\n  0: 0.1704\n  1: 0.1654\n  5: 0.1243\n  7: 0.1036\n  11: 0.0902\n\nTop 5 by PageRank:\n  15: 0.0842\n  14: 0.0781\n  5: 0.0647\n  19: 0.0643\n  8: 0.0518\n\nShortest path GENE_A \u2192 inflammation: ['GENE_A', 'GENE_B', 'GENE_F']\n\nLouvain communities: 4\n  Community 0: [9]...\n  Community 1: [1, 3, 10, 11, 12, 20, 21]...\n  Community 2: [5, 6, 7, 8, 13, 14, 15]...\n  Community 3: [0, 2, 4, 16, 17, 18, 19]...\n</pre> <pre>/mnt/c/Users/pc/Desktop/annnet/annnet/core/lazy_proxies/nx_lazyproxy.py:1993: RuntimeWarning: Graph-NX conversion is lossy: multiple slices flattened into single NX graph.\n  nxG = self._convert_to_nx(\n</pre> In\u00a0[23]: Copied! <pre># . Lazy igraph Proxy (G.ig)\n\nprint(\"=== Lazy igraph Proxy ===\")\n\n# Transitivity via lazy proxy\ntransitivity = G.ig.transitivity_undirected()\nprint(f\"Global transitivity: {transitivity:.4f}\")\n\n# Diameter\ndiameter = G.ig.diameter(G)\nprint(f\"Diameter: {diameter}\")\n</pre> # . Lazy igraph Proxy (G.ig)  print(\"=== Lazy igraph Proxy ===\")  # Transitivity via lazy proxy transitivity = G.ig.transitivity_undirected() print(f\"Global transitivity: {transitivity:.4f}\")  # Diameter diameter = G.ig.diameter(G) print(f\"Diameter: {diameter}\") <pre>=== Lazy igraph Proxy ===\nGlobal transitivity: 0.3043\nDiameter: 6\n</pre> <pre>/mnt/c/Users/pc/Desktop/annnet/annnet/core/lazy_proxies/ig_lazyproxy.py:243: RuntimeWarning: Graph-igraph conversion is lossy: hyperedges dropped (hyperedge_mode='skip'); multiple slices flattened into single igraph graph.\n  igG = self._convert_to_ig(\n</pre> In\u00a0[24]: Copied! <pre># . Fiedler Vector Analysis (Community Structure)\n\nfiedler_vec = eigenvectors[:, 1]\n\n# Map back to (vertex, layer) pairs\nfiedler_mapping = {}\nfor i, (v, layer) in enumerate(G._row_to_nl):\n    fiedler_mapping[(v, layer[0])] = fiedler_vec[i]\n\n# Create DataFrame\nfiedler_data = [\n    {\"vertex\": v, \"layer\": L, \"fiedler_value\": val}\n    for (v, L), val in fiedler_mapping.items()\n]\nfiedler_df = pl.DataFrame(fiedler_data).sort(\"fiedler_value\")\n\nprint(\"Fiedler vector extremes:\")\nprint(\"\\nMost negative (Cluster A):\")\nprint(fiedler_df.head(10))\nprint(\"\\nMost positive (Cluster B):\")\nprint(fiedler_df.tail(10))\n\n# Binary partition\ncluster_A = [(v, L) for (v, L), val in fiedler_mapping.items() if val &lt; 0]\ncluster_B = [(v, L) for (v, L), val in fiedler_mapping.items() if val &gt;= 0]\n\nprint(f\"\\nCluster A: {len(cluster_A)} vertex-layer pairs\")\nprint(f\"Cluster B: {len(cluster_B)} vertex-layer pairs\")\n</pre> # . Fiedler Vector Analysis (Community Structure)  fiedler_vec = eigenvectors[:, 1]  # Map back to (vertex, layer) pairs fiedler_mapping = {} for i, (v, layer) in enumerate(G._row_to_nl):     fiedler_mapping[(v, layer[0])] = fiedler_vec[i]  # Create DataFrame fiedler_data = [     {\"vertex\": v, \"layer\": L, \"fiedler_value\": val}     for (v, L), val in fiedler_mapping.items() ] fiedler_df = pl.DataFrame(fiedler_data).sort(\"fiedler_value\")  print(\"Fiedler vector extremes:\") print(\"\\nMost negative (Cluster A):\") print(fiedler_df.head(10)) print(\"\\nMost positive (Cluster B):\") print(fiedler_df.tail(10))  # Binary partition cluster_A = [(v, L) for (v, L), val in fiedler_mapping.items() if val &lt; 0] cluster_B = [(v, L) for (v, L), val in fiedler_mapping.items() if val &gt;= 0]  print(f\"\\nCluster A: {len(cluster_A)} vertex-layer pairs\") print(f\"Cluster B: {len(cluster_B)} vertex-layer pairs\") <pre>Fiedler vector extremes:\n\nMost negative (Cluster A):\nshape: (10, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex \u2506 layer      \u2506 fiedler_value \u2502\n\u2502 ---    \u2506 ---        \u2506 ---           \u2502\n\u2502 str    \u2506 str        \u2506 f64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 MET_6  \u2506 metabolic  \u2506 -0.470531     \u2502\n\u2502 MET_5  \u2506 metabolic  \u2506 -0.426893     \u2502\n\u2502 GENE_I \u2506 metabolic  \u2506 -0.329888     \u2502\n\u2502 MET_4  \u2506 metabolic  \u2506 -0.264929     \u2502\n\u2502 GENE_I \u2506 regulatory \u2506 -0.203147     \u2502\n\u2502 GENE_I \u2506 PPI        \u2506 -0.160861     \u2502\n\u2502 GENE_G \u2506 metabolic  \u2506 -0.131431     \u2502\n\u2502 GENE_J \u2506 PPI        \u2506 -0.099689     \u2502\n\u2502 GENE_J \u2506 regulatory \u2506 -0.088367     \u2502\n\u2502 MET_3  \u2506 metabolic  \u2506 -0.082807     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nMost positive (Cluster B):\nshape: (10, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex          \u2506 layer      \u2506 fiedler_value \u2502\n\u2502 ---             \u2506 ---        \u2506 ---           \u2502\n\u2502 str             \u2506 str        \u2506 f64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_A          \u2506 PPI        \u2506 0.102629      \u2502\n\u2502 GENE_B          \u2506 regulatory \u2506 0.110285      \u2502\n\u2502 proliferation   \u2506 phenotype  \u2506 0.131864      \u2502\n\u2502 GENE_A          \u2506 regulatory \u2506 0.136882      \u2502\n\u2502 cell_death      \u2506 phenotype  \u2506 0.137223      \u2502\n\u2502 GENE_E          \u2506 PPI        \u2506 0.160979      \u2502\n\u2502 GENE_A          \u2506 phenotype  \u2506 0.164777      \u2502\n\u2502 inflammation    \u2506 phenotype  \u2506 0.174215      \u2502\n\u2502 immune_response \u2506 phenotype  \u2506 0.193451      \u2502\n\u2502 GENE_E          \u2506 regulatory \u2506 0.193531      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCluster A: 13 vertex-layer pairs\nCluster B: 45 vertex-layer pairs\n</pre> In\u00a0[25]: Copied! <pre># . Diffusion Simulation\n\n# Initial perturbation: activate GENE_A in regulatory layer\nx0 = np.zeros(n_supra)\n\nfor i, (v, layer) in enumerate(G._row_to_nl):\n    if v == \"GENE_A\" and layer == (\"regulatory\",):\n        x0[i] = 1.0\n        print(f\"Initial perturbation at index {i}: ({v}, {layer[0]})\")\n        break\n\n# Diffusion parameters\ntau = 0.1\nn_steps = 50\n\n# Store trajectory\ntrajectory = [x0.copy()]\nx = x0.copy()\n\nfor step in range(n_steps):\n    x = x - tau * (L_supra @ x)\n    trajectory.append(x.copy())\n\ntrajectory = np.array(trajectory)\nprint(f\"Trajectory shape: {trajectory.shape}\")\n\n# Alternative: use library method\nx_one_step = G.diffusion_step(x0, tau=0.1, kind=\"comb\")\nprint(f\"One diffusion step via G.diffusion_step(): ||x||={np.linalg.norm(x_one_step):.4f}\")\n\n# Random walk step\np_rw = G.random_walk_step(x0)\nprint(f\"Random walk step: sum={p_rw.sum():.4f}\")\n</pre> # . Diffusion Simulation  # Initial perturbation: activate GENE_A in regulatory layer x0 = np.zeros(n_supra)  for i, (v, layer) in enumerate(G._row_to_nl):     if v == \"GENE_A\" and layer == (\"regulatory\",):         x0[i] = 1.0         print(f\"Initial perturbation at index {i}: ({v}, {layer[0]})\")         break  # Diffusion parameters tau = 0.1 n_steps = 50  # Store trajectory trajectory = [x0.copy()] x = x0.copy()  for step in range(n_steps):     x = x - tau * (L_supra @ x)     trajectory.append(x.copy())  trajectory = np.array(trajectory) print(f\"Trajectory shape: {trajectory.shape}\")  # Alternative: use library method x_one_step = G.diffusion_step(x0, tau=0.1, kind=\"comb\") print(f\"One diffusion step via G.diffusion_step(): ||x||={np.linalg.norm(x_one_step):.4f}\")  # Random walk step p_rw = G.random_walk_step(x0) print(f\"Random walk step: sum={p_rw.sum():.4f}\") <pre>Initial perturbation at index 3: (GENE_A, regulatory)\nTrajectory shape: (51, 58)\nOne diffusion step via G.diffusion_step(): ||x||=0.5667\nRandom walk step: sum=1.0000\n</pre> In\u00a0[26]: Copied! <pre># . Analyze Diffusion Results\n\nx_final = trajectory[-1]\n\n# Map back to (vertex, layer)\nfinal_activation = {}\nfor i, (v, layer) in enumerate(G._row_to_nl):\n    final_activation[(v, layer[0])] = x_final[i]\n\nactivation_df = pl.DataFrame([\n    {\"vertex\": v, \"layer\": L, \"activation\": val}\n    for (v, L), val in final_activation.items()\n]).sort(\"activation\", descending=True)\n\nprint(\"Top activated nodes after diffusion:\")\nprint(activation_df.head(15))\n\n# Activation by layer\nlayer_activation = activation_df.group_by(\"layer\").agg(\n    pl.col(\"activation\").mean().alias(\"mean\"),\n    pl.col(\"activation\").max().alias(\"max\"),\n    pl.col(\"activation\").sum().alias(\"total\"),\n)\nprint(\"\\nActivation by layer:\")\nprint(layer_activation)\n</pre> # . Analyze Diffusion Results  x_final = trajectory[-1]  # Map back to (vertex, layer) final_activation = {} for i, (v, layer) in enumerate(G._row_to_nl):     final_activation[(v, layer[0])] = x_final[i]  activation_df = pl.DataFrame([     {\"vertex\": v, \"layer\": L, \"activation\": val}     for (v, L), val in final_activation.items() ]).sort(\"activation\", descending=True)  print(\"Top activated nodes after diffusion:\") print(activation_df.head(15))  # Activation by layer layer_activation = activation_df.group_by(\"layer\").agg(     pl.col(\"activation\").mean().alias(\"mean\"),     pl.col(\"activation\").max().alias(\"max\"),     pl.col(\"activation\").sum().alias(\"total\"), ) print(\"\\nActivation by layer:\") print(layer_activation) <pre>Top activated nodes after diffusion:\nshape: (15, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex       \u2506 layer      \u2506 activation \u2502\n\u2502 ---          \u2506 ---        \u2506 ---        \u2502\n\u2502 str          \u2506 str        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GENE_E       \u2506 regulatory \u2506 0.033098   \u2502\n\u2502 GENE_E       \u2506 PPI        \u2506 0.031736   \u2502\n\u2502 GENE_A       \u2506 regulatory \u2506 0.030288   \u2502\n\u2502 GENE_A       \u2506 phenotype  \u2506 0.029867   \u2502\n\u2502 GENE_B       \u2506 regulatory \u2506 0.029683   \u2502\n\u2502 \u2026            \u2506 \u2026          \u2506 \u2026          \u2502\n\u2502 inflammation \u2506 phenotype  \u2506 0.028869   \u2502\n\u2502 GENE_D       \u2506 PPI        \u2506 0.028859   \u2502\n\u2502 GENE_D       \u2506 metabolic  \u2506 0.028293   \u2502\n\u2502 MET_2        \u2506 metabolic  \u2506 0.02829    \u2502\n\u2502 GENE_B       \u2506 PPI        \u2506 0.028287   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nActivation by layer:\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 layer      \u2506 mean     \u2506 max      \u2506 total    \u2502\n\u2502 ---        \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n\u2502 str        \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 metabolic  \u2506 0.024079 \u2506 0.029346 \u2506 0.240788 \u2502\n\u2502 default    \u2506 0.0      \u2506 0.0      \u2506 0.0      \u2502\n\u2502 regulatory \u2506 0.026925 \u2506 0.033098 \u2506 0.269252 \u2502\n\u2502 PPI        \u2506 0.026882 \u2506 0.031736 \u2506 0.26882  \u2502\n\u2502 phenotype  \u2506 0.027643 \u2506 0.029867 \u2506 0.221141 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> In\u00a0[27]: Copied! <pre># . History &amp; Versioning\n\nprint(\"=== Mutation History ===\")\nprint(f\"Total events: {len(G._history)}\")\nprint(f\"Current version: {G._version}\")\n\n# View history as DataFrame\nhistory_df = pl.DataFrame(G._history, infer_schema_length=10000)\nprint(f\"\\nHistory columns: {history_df.columns}\")\n\n# Show checkpoints\nmarks = history_df.filter(pl.col(\"op\") == \"mark\")\nprint(f\"\\nCheckpoints:\")\nprint(marks.select([\"version\", \"ts_utc\", \"label\"]))\n\n# Operation counts\nop_counts = history_df.group_by(\"op\").agg(pl.count().alias(\"count\")).sort(\"count\", descending=True)\nprint(f\"\\nOperations by type:\")\nprint(op_counts.head(10))\n</pre> # . History &amp; Versioning  print(\"=== Mutation History ===\") print(f\"Total events: {len(G._history)}\") print(f\"Current version: {G._version}\")  # View history as DataFrame history_df = pl.DataFrame(G._history, infer_schema_length=10000) print(f\"\\nHistory columns: {history_df.columns}\")  # Show checkpoints marks = history_df.filter(pl.col(\"op\") == \"mark\") print(f\"\\nCheckpoints:\") print(marks.select([\"version\", \"ts_utc\", \"label\"]))  # Operation counts op_counts = history_df.group_by(\"op\").agg(pl.count().alias(\"count\")).sort(\"count\", descending=True) print(f\"\\nOperations by type:\") print(op_counts.head(10))    <pre>=== Mutation History ===\nTotal events: 240\nCurrent version: 240\n\nHistory columns: ['version', 'ts_utc', 'mono_ns', 'op', 'label', 'vertex_id', 'slice', 'attributes', 'result', 'edge_id', 'attrs', 'source', 'target', 'weight', 'edge_type', 'propagate', 'slice_weight', 'directed', 'edge_directed', 'members', 'head', 'tail', 'edge_entity_id', 'slice_id']\n\nCheckpoints:\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 version \u2506 ts_utc                      \u2506 label                \u2502\n\u2502 ---     \u2506 ---                         \u2506 ---                  \u2502\n\u2502 i64     \u2506 str                         \u2506 str                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1       \u2506 2025-12-04T18:53:18.395057Z \u2506 initialization       \u2502\n\u2502 22      \u2506 2025-12-04T18:53:19.215207Z \u2506 vertices_added       \u2502\n\u2502 176     \u2506 2025-12-04T18:53:20.701496Z \u2506 intra_edges_added    \u2502\n\u2502 189     \u2506 2025-12-04T18:53:22.336055Z \u2506 hyperedges_added     \u2502\n\u2502 204     \u2506 2025-12-04T18:53:23.848297Z \u2506 edge_entities_added  \u2502\n\u2502 231     \u2506 2025-12-04T18:53:24.497284Z \u2506 coupling_edges_added \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nOperations by type:\nshape: (8, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 op                   \u2506 count \u2502\n\u2502 ---                  \u2506 ---   \u2502\n\u2502 str                  \u2506 u32   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 set_edge_attrs       \u2506 115   \u2502\n\u2502 add_edge             \u2506 81    \u2502\n\u2502 add_vertex           \u2506 20    \u2502\n\u2502 set_slice_attrs      \u2506 7     \u2502\n\u2502 mark                 \u2506 6     \u2502\n\u2502 add_hyperedge        \u2506 6     \u2502\n\u2502 add_edge_entity      \u2506 3     \u2502\n\u2502 set_edge_slice_attrs \u2506 2     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> <pre>/tmp/ipykernel_10618/353137708.py:17: DeprecationWarning: `pl.count()` is deprecated. Please use `pl.len()` instead.\n(Deprecated in version 0.20.5)\n  op_counts = history_df.group_by(\"op\").agg(pl.count().alias(\"count\")).sort(\"count\", descending=True)\n</pre> In\u00a0[28]: Copied! <pre># . Summary Statistics\n\nprint(\"=\" * 70)\nprint(\"MULTILAYER NETWORK ANALYSIS - COMPLETE SUMMARY\")\nprint(\"=\" * 70)\n\n# Entity counts\nentity_counts = defaultdict(int)\nfor v in G.vertices():\n    etype = G.get_vertex_attrs(v).get(\"entity_type\", \"unknown\")\n    entity_counts[etype] += 1\n\nprint(\"\\n Entity Counts:\")\nfor etype, count in sorted(entity_counts.items()):\n    print(f\"  {etype}: {count}\")\n\n# Edge statistics\nprint(f\"\\n Edge Statistics:\")\nprint(f\"  Total edges: {G.number_of_edges()}\")\nprint(f\"  Binary edges: {len(G.edge_definitions)}\")\nprint(f\"  Hyperedges: {len(G.hyperedge_definitions)}\")\nprint(f\"  Edge entities: {len([e for e, t in G.entity_types.items() if t == 'edge'])}\")\nprint(f\"  Coupling edges: {len([e for e, k in G.edge_kind.items() if k == 'coupling'])}\")\n\n# Directionality\ndirected_edges = G.get_directed_edges()\nundirected_edges = G.get_undirected_edges()\nprint(f\"  Directed: {len(directed_edges)}\")\nprint(f\"  Undirected: {len(undirected_edges)}\")\n\n# Layer statistics\nprint(f\"\\n Layer Statistics:\")\nfor layer in G.elem_layers[\"omic\"]:\n    n_verts = len(G.layer_vertex_set((layer,)))\n    n_edges = len(G.layer_edge_set((layer,)))\n    print(f\"  {layer}: {n_verts} vertices, {n_edges} edges\")\n\n# Supra statistics\nprint(f\"\\n Supra-Graph:\")\nprint(f\"  Nodes (vertex-layer pairs): {n_supra}\")\nprint(f\"  Algebraic connectivity: {lambda2:.6f}\")\n\n# Slice statistics\nprint(f\"\\n Slices: {len(G.list_slices())}\")\n\n# Memory\nmem = G.memory_usage()\nprint(f\"\\n Memory: {mem / 1024:.2f} KB\")\n\n# History\nprint(f\"\\n History: {len(G._history)} events, version {G._version}\")\n</pre> # . Summary Statistics  print(\"=\" * 70) print(\"MULTILAYER NETWORK ANALYSIS - COMPLETE SUMMARY\") print(\"=\" * 70)  # Entity counts entity_counts = defaultdict(int) for v in G.vertices():     etype = G.get_vertex_attrs(v).get(\"entity_type\", \"unknown\")     entity_counts[etype] += 1  print(\"\\n Entity Counts:\") for etype, count in sorted(entity_counts.items()):     print(f\"  {etype}: {count}\")  # Edge statistics print(f\"\\n Edge Statistics:\") print(f\"  Total edges: {G.number_of_edges()}\") print(f\"  Binary edges: {len(G.edge_definitions)}\") print(f\"  Hyperedges: {len(G.hyperedge_definitions)}\") print(f\"  Edge entities: {len([e for e, t in G.entity_types.items() if t == 'edge'])}\") print(f\"  Coupling edges: {len([e for e, k in G.edge_kind.items() if k == 'coupling'])}\")  # Directionality directed_edges = G.get_directed_edges() undirected_edges = G.get_undirected_edges() print(f\"  Directed: {len(directed_edges)}\") print(f\"  Undirected: {len(undirected_edges)}\")  # Layer statistics print(f\"\\n Layer Statistics:\") for layer in G.elem_layers[\"omic\"]:     n_verts = len(G.layer_vertex_set((layer,)))     n_edges = len(G.layer_edge_set((layer,)))     print(f\"  {layer}: {n_verts} vertices, {n_edges} edges\")  # Supra statistics print(f\"\\n Supra-Graph:\") print(f\"  Nodes (vertex-layer pairs): {n_supra}\") print(f\"  Algebraic connectivity: {lambda2:.6f}\")  # Slice statistics print(f\"\\n Slices: {len(G.list_slices())}\")  # Memory mem = G.memory_usage() print(f\"\\n Memory: {mem / 1024:.2f} KB\")  # History print(f\"\\n History: {len(G._history)} events, version {G._version}\") <pre>======================================================================\nMULTILAYER NETWORK ANALYSIS - COMPLETE SUMMARY\n======================================================================\n\n Entity Counts:\n  gene: 10\n  metabolite: 6\n  phenotype: 4\n\n Edge Statistics:\n  Total edges: 87\n  Binary edges: 87\n  Hyperedges: 6\n  Edge entities: 3\n  Coupling edges: 26\n  Directed: 84\n  Undirected: 3\n\n Layer Statistics:\n  PPI: 10 vertices, 18 edges\n  metabolic: 10 vertices, 14 edges\n  regulatory: 10 vertices, 9 edges\n  phenotype: 8 vertices, 10 edges\n  hub_genes: 0 vertices, 0 edges\n  disease_associated: 0 vertices, 0 edges\n  enzymes_only: 0 vertices, 0 edges\n  healthy_context: 0 vertices, 0 edges\n  disease_context: 0 vertices, 0 edges\n\n Supra-Graph:\n  Nodes (vertex-layer pairs): 58\n  Algebraic connectivity: 0.373097\n\n Slices: 10\n\n Memory: 29.02 KB\n\n History: 240 events, version 240\n</pre> In\u00a0[29]: Copied! <pre># . Visualization\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Plot 1: Eigenvalue spectrum\n# Axes indexing changes from axes[0, 0] to axes[0]\nax = axes[0]\nax.bar(range(len(eigenvalues)), eigenvalues, color='steelblue')\nax.axhline(y=eigenvalues[1], color='red', linestyle='--', label=f'\u03bb\u2082={eigenvalues[1]:.3f}')\nax.set_xlabel('Eigenvalue index')\nax.set_ylabel('Eigenvalue')\nax.set_title('Supra-Laplacian Spectrum')\nax.legend()\n\n# Plot 2: Fiedler vector\n# Axes indexing changes from axes[0, 1] to axes[1]\nax = axes[1]\ncolors = ['red' if f &lt; 0 else 'blue' for f in fiedler_vec]\nax.scatter(range(len(fiedler_vec)), np.sort(fiedler_vec), c=colors, alpha=0.6, s=30)\nax.axhline(y=0, color='black', linestyle='-', linewidth=0.5)\nax.set_xlabel('Node index (sorted)')\nax.set_ylabel('Fiedler value')\nax.set_title('Fiedler Vector (Spectral Partition)')\n\n# 3. Remove Plot 3 and Plot 4 code entirely\n\nplt.tight_layout()\nplt.show()\n</pre> # . Visualization  fig, axes = plt.subplots(1, 2, figsize=(14, 5))  # Plot 1: Eigenvalue spectrum # Axes indexing changes from axes[0, 0] to axes[0] ax = axes[0] ax.bar(range(len(eigenvalues)), eigenvalues, color='steelblue') ax.axhline(y=eigenvalues[1], color='red', linestyle='--', label=f'\u03bb\u2082={eigenvalues[1]:.3f}') ax.set_xlabel('Eigenvalue index') ax.set_ylabel('Eigenvalue') ax.set_title('Supra-Laplacian Spectrum') ax.legend()  # Plot 2: Fiedler vector # Axes indexing changes from axes[0, 1] to axes[1] ax = axes[1] colors = ['red' if f &lt; 0 else 'blue' for f in fiedler_vec] ax.scatter(range(len(fiedler_vec)), np.sort(fiedler_vec), c=colors, alpha=0.6, s=30) ax.axhline(y=0, color='black', linestyle='-', linewidth=0.5) ax.set_xlabel('Node index (sorted)') ax.set_ylabel('Fiedler value') ax.set_title('Fiedler Vector (Spectral Partition)')  # 3. Remove Plot 3 and Plot 4 code entirely  plt.tight_layout() plt.show() In\u00a0[30]: Copied! <pre># . Cytoscape layer visualization\n\nfrom annnet.adapters import cx2_adapter as cx\nimport json\n\nG.create_slice_from_layer(\"ppi_only\", (\"PPI\",), include_inter=False, include_coupling=False)\nppi_subgraph = G.subgraph_from_slice(\"ppi_only\")\n\nsbuc = cx.to_cx2(ppi_subgraph)\n\noutput_file = \"sbuc.cx2\"\n\nwith open(output_file, \"w\") as f:\n    json.dump(sbuc, f)\n\nprint(f\"Saved to {output_file}\")\n</pre> # . Cytoscape layer visualization  from annnet.adapters import cx2_adapter as cx import json  G.create_slice_from_layer(\"ppi_only\", (\"PPI\",), include_inter=False, include_coupling=False) ppi_subgraph = G.subgraph_from_slice(\"ppi_only\")  sbuc = cx.to_cx2(ppi_subgraph)  output_file = \"sbuc.cx2\"  with open(output_file, \"w\") as f:     json.dump(sbuc, f)  print(f\"Saved to {output_file}\") <pre>Saved to sbuc.cx2\n</pre> In\u00a0[31]: Copied! <pre># . SBML import and Cytoscape\n\n\nfrom annnet.adapters import SBML_adapter as sb\n\n# From SBML\ngg = sb.from_sbml(\"Haridansyah2019.sbml\")\n\n\n#To cx2 (Cytoscape exchange 2)\nH2 = cx.to_cx2(gg, hyperedges= \"expand\")\noutput_file = \"Haridansyah2019.cx2\"\n\nwith open(output_file, \"w\") as f:\n    json.dump(H2, f)\n\nprint(f\"Saved to {output_file}\")\n</pre> # . SBML import and Cytoscape   from annnet.adapters import SBML_adapter as sb  # From SBML gg = sb.from_sbml(\"Haridansyah2019.sbml\")   #To cx2 (Cytoscape exchange 2) H2 = cx.to_cx2(gg, hyperedges= \"expand\") output_file = \"Haridansyah2019.cx2\"  with open(output_file, \"w\") as f:     json.dump(H2, f)  print(f\"Saved to {output_file}\") <pre>Saved to Haridansyah2019.cx2\n</pre> In\u00a0[32]: Copied! <pre># . Lossless write/read as .annnet:\n\nG.write(\"SBUC.annnet\", overwrite=True)\n</pre> # . Lossless write/read as .annnet:  G.write(\"SBUC.annnet\", overwrite=True) In\u00a0[33]: Copied! <pre>G2 = Graph.read(\"SBUC.annnet\")\n</pre> G2 = Graph.read(\"SBUC.annnet\") In\u00a0[34]: Copied! <pre>assert G2.V == G.V\nassert G2.E == G.E\nprint(\"Lossless roundtrip Ok\")\n</pre> assert G2.V == G.V assert G2.E == G.E print(\"Lossless roundtrip Ok\") <pre>Lossless roundtrip Ok\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/SBUC/#annnet-introduction-multilayer-network-analysis-in-systems-biology","title":"AnnNet Introduction - Multilayer Network Analysis in Systems Biology\u00b6","text":""},{"location":"reference/","title":"API Reference","text":"<p>This section is curated around how you use annnet in practice. Use the left navigation (or search) to jump directly to a concept or symbol.</p>"},{"location":"reference/#how-it-is-organized","title":"How It Is Organized","text":"<ul> <li>Annotated Network: the <code>AnnNet</code> core class plus the attribute tables and   topology/indexing mixins that define the primary API surface.</li> <li>Slices: subgraph membership and slice-specific attributes.</li> <li>Layers: multilayer semantics (aspects, layer tuples, and per-layer attributes).</li> <li>Algorithms: traversal helpers and lazy proxy hooks for optional backends.</li> <li>Storage (.annnet): lossless on-disk storage and Parquet GraphDir.</li> <li>Interoperability: adapters and file-format IO (NetworkX, igraph, graph-tool, PyG,   SBML, SIF, GraphML, CX2, JSON/CSV/Excel, etc.).</li> </ul>"},{"location":"reference/#navigation-tips","title":"Navigation Tips","text":"<ul> <li>Each page documents public members (names that do not start with <code>_</code>).</li> <li>Advanced or internal pieces are explicitly called out when they are part of the   public surface (e.g., lazy proxies).</li> <li>If you cannot find a symbol, check the section that matches its domain or use search.</li> </ul>"},{"location":"reference/algorithms/","title":"Algorithms","text":""},{"location":"reference/algorithms/#traversal","title":"Traversal","text":"Internal helpers"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal","title":"<code>annnet.algorithms.traversal.Traversal</code>","text":""},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal-functions","title":"Functions","text":""},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.neighbors","title":"<code>neighbors(entity_id)</code>","text":"<p>Neighbors of an entity (vertex or edge-entity).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Adjacent entities. For hyperedges, uses head/tail orientation.</p>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.out_neighbors","title":"<code>out_neighbors(vertex_id)</code>","text":"<p>Out-neighbors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.successors","title":"<code>successors(vertex_id)</code>","text":"<p>Successors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.in_neighbors","title":"<code>in_neighbors(vertex_id)</code>","text":"<p>In-neighbors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.predecessors","title":"<code>predecessors(vertex_id)</code>","text":"<p>In-neighbors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal-functions","title":"Functions","text":""},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.neighbors","title":"<code>neighbors(entity_id)</code>","text":"<p>Neighbors of an entity (vertex or edge-entity).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Adjacent entities. For hyperedges, uses head/tail orientation.</p>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.out_neighbors","title":"<code>out_neighbors(vertex_id)</code>","text":"<p>Out-neighbors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.successors","title":"<code>successors(vertex_id)</code>","text":"<p>Successors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.in_neighbors","title":"<code>in_neighbors(vertex_id)</code>","text":"<p>In-neighbors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#annnet.algorithms.traversal.Traversal.predecessors","title":"<code>predecessors(vertex_id)</code>","text":"<p>In-neighbors of a vertex under directed semantics.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/algorithms/#lazy-proxies-networkx-igraph-graph-tool","title":"Lazy Proxies (NetworkX, igraph, graph-tool)","text":"<p>These proxies provide a thin, lazy bridge to optional backends. Internal proxy classes and helper functions are intentionally hidden from this reference; see the source if you need implementation details.</p>"},{"location":"reference/algorithms/#annnet.core.lazy_proxies.nx_lazyproxy._LazyNXProxy","title":"<code>annnet.core.lazy_proxies.nx_lazyproxy._LazyNXProxy</code>","text":"<p>Lazy NetworkX proxy attached to an AnnNet instance.</p> <p>This proxy lets you call NetworkX algorithms as <code>G.nx.&lt;algo&gt;(...)</code>. On first use (or after a graph mutation), AnnNet is converted to a NetworkX graph and cached; subsequent calls reuse the cached backend until the AnnNet version changes.</p> <p>Conversion produces a manifest dictionary that preserves information NetworkX cannot represent (e.g., hyperedges, per-edge directedness, slices, multilayer metadata, stable edge IDs). The manifest is JSON-serializable and can be persisted with <code>annnet.adapters.networkx_adapter.save_manifest</code>.</p> Notes <ul> <li>Requires the optional <code>networkx</code> dependency.</li> <li>The typical usage pattern is <code>G.nx.algorithm(...)</code>, which lazily converts,   runs the NetworkX algorithm, and returns its output.</li> </ul>"},{"location":"reference/algorithms/#annnet.core.lazy_proxies.ig_lazyproxy._LazyIGProxy","title":"<code>annnet.core.lazy_proxies.ig_lazyproxy._LazyIGProxy</code>","text":"<p>Lazy igraph proxy attached to an AnnNet instance.</p> <p>This proxy lets you call igraph algorithms as <code>G.ig.&lt;algo&gt;(...)</code>. On first use (or after a graph mutation), AnnNet is converted to an igraph graph and cached; subsequent calls reuse the cached backend until the AnnNet version changes.</p> <p>Conversion produces a manifest dictionary that preserves information igraph cannot represent (e.g., hyperedges, per-edge directedness, slices, multilayer metadata, stable edge IDs). The manifest is JSON-serializable and can be persisted by the adapter.</p> Notes <ul> <li>Requires the optional <code>python-igraph</code> dependency.</li> <li>The typical usage pattern is <code>G.ig.algorithm(...)</code>, which lazily converts,   runs the igraph algorithm, and returns its output.</li> <li><code>_ig_simple=True</code> collapses parallel edges to a simple graph; <code>_ig_edge_aggs</code>   controls aggregation (e.g., <code>{\"weight\":\"min\",\"capacity\":\"sum\"}</code>).</li> </ul>"},{"location":"reference/algorithms/#annnet.core.lazy_proxies.gt_lazyproxy._LazyGTProxy","title":"<code>annnet.core.lazy_proxies.gt_lazyproxy._LazyGTProxy</code>","text":"<p>Lazy graph-tool proxy attached to an AnnNet instance.</p> <p>This proxy lets you call graph-tool algorithms via namespaces such as: <code>G.gt.topology.shortest_distance(...)</code>, <code>G.gt.centrality.betweenness(...)</code>, and <code>G.gt.flow.push_relabel_max_flow(...)</code>.</p> <p>On first use (or after a graph mutation), AnnNet is converted to a graph-tool graph and cached; subsequent calls reuse the cached backend until the AnnNet version changes. Conversion produces a manifest dictionary that preserves information graph-tool cannot represent (e.g., hyperedges, per-edge directedness, slices, multilayer metadata, stable edge IDs). The manifest is JSON-serializable and can be persisted by the adapter.</p> Notes <ul> <li>Requires the optional <code>graph-tool</code> dependency (not on PyPI).</li> <li>The typical usage pattern is <code>G.gt.&lt;namespace&gt;.&lt;algo&gt;(...)</code>, which lazily   converts, runs the graph-tool algorithm, and returns its output.</li> </ul>"},{"location":"reference/annnet_core/","title":"AnnNet Core + Attributes","text":"<p>The <code>AnnNet</code> class is the primary annotated network object. It composes multiple mixins that provide topology management, attribute tables, bulk operations, history, and cache control.</p>"},{"location":"reference/annnet_core/#annnet","title":"AnnNet","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet","title":"<code>annnet.core.graph.AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.directed","title":"<code>directed = directed</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_RESERVED","title":"<code>_vertex_RESERVED = set(_vertex_RESERVED)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._EDGE_RESERVED","title":"<code>_EDGE_RESERVED = set(_EDGE_RESERVED)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._slice_RESERVED","title":"<code>_slice_RESERVED = set(_slice_RESERVED)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.entity_to_idx","title":"<code>entity_to_idx = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.idx_to_entity","title":"<code>idx_to_entity = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.entity_types","title":"<code>entity_types = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_to_idx","title":"<code>edge_to_idx = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.idx_to_edge","title":"<code>idx_to_edge = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_definitions","title":"<code>edge_definitions = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_weights","title":"<code>edge_weights = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_directed","title":"<code>edge_directed = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_direction_policy","title":"<code>edge_direction_policy = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_key_fields","title":"<code>_vertex_key_fields = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_key_index","title":"<code>_vertex_key_index = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._num_entities","title":"<code>_num_entities = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._num_edges","title":"<code>_num_edges = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._annotations_backend","title":"<code>_annotations_backend = annotations_backend</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.hyperedge_definitions","title":"<code>hyperedge_definitions = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.graph_attributes","title":"<code>graph_attributes = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._next_edge_id","title":"<code>_next_edge_id = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._slices","title":"<code>_slices = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._default_slice","title":"<code>_default_slice = 'default'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.slice_edge_weights","title":"<code>slice_edge_weights = defaultdict(dict)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._current_slice","title":"<code>_current_slice = self._default_slice</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._matrix","title":"<code>_matrix = sp.dok_matrix((n, e), dtype=(np.float32))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._grow_rows_to","title":"<code>_grow_rows_to = _grow_rows_to</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._grow_cols_to","title":"<code>_grow_cols_to = _grow_cols_to</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._history_enabled","title":"<code>_history_enabled = True</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._history","title":"<code>_history = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._version","title":"<code>_version = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._history_clock0","title":"<code>_history_clock0 = time.perf_counter_ns()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._snapshots","title":"<code>_snapshots = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.aspects","title":"<code>aspects = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.elem_layers","title":"<code>elem_layers = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._all_layers","title":"<code>_all_layers = ()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._V","title":"<code>_V = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._VM","title":"<code>_VM = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.vertex_aligned","title":"<code>vertex_aligned = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._nl_to_row","title":"<code>_nl_to_row = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._row_to_nl","title":"<code>_row_to_nl = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._legacy_single_aspect_enabled","title":"<code>_legacy_single_aspect_enabled = True</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_kind","title":"<code>edge_kind = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_layers","title":"<code>edge_layers = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._aspect_attrs","title":"<code>_aspect_attrs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._layer_attrs","title":"<code>_layer_attrs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_layer_attrs","title":"<code>_vertex_layer_attrs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.V","title":"<code>V</code>  <code>property</code>","text":"<p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.E","title":"<code>E</code>  <code>property</code>","text":"<p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.num_vertices","title":"<code>num_vertices</code>  <code>property</code>","text":"<p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.num_edges","title":"<code>num_edges</code>  <code>property</code>","text":"<p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.nv","title":"<code>nv</code>  <code>property</code>","text":"<p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.ne","title":"<code>ne</code>  <code>property</code>","text":"<p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.nx","title":"<code>nx</code>  <code>property</code>","text":"<p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.ig","title":"<code>ig</code>  <code>property</code>","text":"<p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.gt","title":"<code>gt</code>  <code>property</code>","text":"<p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.obs","title":"<code>obs</code>  <code>property</code>","text":"<p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.var","title":"<code>var</code>  <code>property</code>","text":"<p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.uns","title":"<code>uns</code>  <code>property</code>","text":"<p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.slices","title":"<code>slices</code>  <code>property</code>","text":"<p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.layers","title":"<code>layers</code>  <code>property</code>","text":"<p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.idx","title":"<code>idx</code>  <code>property</code>","text":"<p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.cache","title":"<code>cache</code>  <code>property</code>","text":"<p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._init_annotation_tables","title":"<code>_init_annotation_tables(annotations)</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_vertex","title":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code>","text":"<p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_vertices","title":"<code>add_vertices(vertices, slice=None, **attributes)</code>","text":"<p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_edge_entity","title":"<code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code>","text":"<p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_edge","title":"<code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code>","text":"<p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_parallel_edge","title":"<code>add_parallel_edge(source, target, weight=1.0, **attributes)</code>","text":"<p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_hyperedge","title":"<code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code>","text":"<p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.set_hyperedge_coeffs","title":"<code>set_hyperedge_coeffs(edge_id, coeffs)</code>","text":"<p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_edge_to_slice","title":"<code>add_edge_to_slice(lid, eid)</code>","text":"<p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.make_undirected","title":"<code>make_undirected(*, drop_flexible=True, update_default=True)</code>","text":"<p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.remove_edge","title":"<code>remove_edge(edge_id)</code>","text":"<p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.remove_vertex","title":"<code>remove_vertex(vertex_id)</code>","text":"<p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.remove_slice","title":"<code>remove_slice(slice_id)</code>","text":"<p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_vertex","title":"<code>get_vertex(index)</code>","text":"<p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_edge","title":"<code>get_edge(index)</code>","text":"<p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.incident_edges","title":"<code>incident_edges(vertex_id)</code>","text":"<p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.has_edge","title":"<code>has_edge(source=None, target=None, edge_id=None)</code>","text":"<p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.has_vertex","title":"<code>has_vertex(vertex_id)</code>","text":"<p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_edge_ids","title":"<code>get_edge_ids(source, target)</code>","text":"<p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.degree","title":"<code>degree(entity_id)</code>","text":"<p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.vertices","title":"<code>vertices()</code>","text":"<p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edges","title":"<code>edges()</code>","text":"<p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_list","title":"<code>edge_list()</code>","text":"<p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_directed_edges","title":"<code>get_directed_edges()</code>","text":"<p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_undirected_edges","title":"<code>get_undirected_edges()</code>","text":"<p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.number_of_vertices","title":"<code>number_of_vertices()</code>","text":"<p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.number_of_edges","title":"<code>number_of_edges()</code>","text":"<p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.global_entity_count","title":"<code>global_entity_count()</code>","text":"<p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.global_edge_count","title":"<code>global_edge_count()</code>","text":"<p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.in_edges","title":"<code>in_edges(vertices)</code>","text":"<p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.out_edges","title":"<code>out_edges(vertices)</code>","text":"<p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_or_create_vertex_by_attrs","title":"<code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code>","text":"<p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.vertex_key_tuple","title":"<code>vertex_key_tuple(vertex_id)</code>","text":"<p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.X","title":"<code>X()</code>","text":"<p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.write","title":"<code>write(path, **kwargs)</code>","text":"<p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.read","title":"<code>read(path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.view","title":"<code>view(vertices=None, edges=None, slices=None, predicate=None)</code>","text":"<p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.snapshot","title":"<code>snapshot(label=None)</code>","text":"<p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.diff","title":"<code>diff(a, b=None)</code>","text":"<p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.list_snapshots","title":"<code>list_snapshots()</code>","text":"<p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/annnet_core/#edge-types","title":"Edge Types","text":""},{"location":"reference/annnet_core/#annnet.core.graph.EdgeType","title":"<code>annnet.core.graph.EdgeType</code>","text":""},{"location":"reference/annnet_core/#topology-indexing","title":"Topology &amp; Indexing","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager","title":"<code>annnet.core._Index.IndexManager</code>","text":"<p>Namespace for index operations. Provides clean API over existing dicts.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entity_to_row","title":"<code>entity_to_row(entity_id)</code>","text":"<p>Map an entity ID to its matrix row index.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Row index for the entity.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the entity is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.row_to_entity","title":"<code>row_to_entity(row)</code>","text":"<p>Map a matrix row index to its entity ID.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>Row index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Entity identifier.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the row index is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entities_to_rows","title":"<code>entities_to_rows(entity_ids)</code>","text":"<p>Batch convert entity IDs to row indices.</p> <p>Parameters:</p> Name Type Description Default <code>entity_ids</code> <code>Iterable[str]</code> <p>Entity identifiers.</p> required <p>Returns:</p> Type Description <code>list[int]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.rows_to_entities","title":"<code>rows_to_entities(rows)</code>","text":"<p>Batch convert row indices to entity IDs.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>Iterable[int]</code> <p>Row indices.</p> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.edge_to_col","title":"<code>edge_to_col(edge_id)</code>","text":"<p>Map an edge ID to its matrix column index.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Column index for the edge.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.col_to_edge","title":"<code>col_to_edge(col)</code>","text":"<p>Map a matrix column index to its edge ID.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>int</code> <p>Column index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Edge identifier.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the column index is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.edges_to_cols","title":"<code>edges_to_cols(edge_ids)</code>","text":"<p>Batch convert edge IDs to column indices.</p> <p>Parameters:</p> Name Type Description Default <code>edge_ids</code> <code>Iterable[str]</code> <p>Edge identifiers.</p> required <p>Returns:</p> Type Description <code>list[int]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.cols_to_edges","title":"<code>cols_to_edges(cols)</code>","text":"<p>Batch convert column indices to edge IDs.</p> <p>Parameters:</p> Name Type Description Default <code>cols</code> <code>Iterable[int]</code> <p>Column indices.</p> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entity_type","title":"<code>entity_type(entity_id)</code>","text":"<p>Get the entity type for an ID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>'vertex'</code> or <code>'edge'</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the entity is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.is_vertex","title":"<code>is_vertex(entity_id)</code>","text":"<p>Check whether an entity ID refers to a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.is_edge_entity","title":"<code>is_edge_entity(entity_id)</code>","text":"<p>Check whether an entity ID refers to an edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.has_entity","title":"<code>has_entity(entity_id)</code>","text":"<p>Check if an ID exists as any entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.has_vertex","title":"<code>has_vertex(vertex_id)</code>","text":"<p>Check if an ID exists and is a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.has_edge_id","title":"<code>has_edge_id(edge_id)</code>","text":"<p>Check if an edge ID exists.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.edge_count","title":"<code>edge_count()</code>","text":"<p>Return the number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entity_count","title":"<code>entity_count()</code>","text":"<p>Return the number of entities (vertices + edge-entities).</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.vertex_count","title":"<code>vertex_count()</code>","text":"<p>Return the number of true vertices (excludes edge-entities).</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.stats","title":"<code>stats()</code>","text":"<p>Return index statistics for entities and edges.</p> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping","title":"<code>annnet.core._Index.IndexMapping</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._get_next_edge_id","title":"<code>_get_next_edge_id()</code>","text":"<p>INTERNAL: Generate a unique edge ID for parallel edges.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fresh <code>edge_&lt;n&gt;</code> identifier (monotonic counter).</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._ensure_vertex_table","title":"<code>_ensure_vertex_table()</code>","text":"<p>INTERNAL: Ensure the vertex attribute table exists with a canonical schema.</p> Notes <ul> <li>Creates an empty Polars DF [DataFrame] with a single <code>Utf8</code> <code>vertex_id</code> column if missing or malformed.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._ensure_vertex_row","title":"<code>_ensure_vertex_row(vertex_id)</code>","text":"<p>INTERNAL: Ensure a row for <code>vertex_id</code> exists in the vertex attribute DF.</p> Notes <ul> <li>Appends a new row with <code>vertex_id</code> and <code>None</code> for other columns if absent.</li> <li>Preserves existing schema and columns.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._vertex_key_enabled","title":"<code>_vertex_key_enabled()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._build_key_from_attrs","title":"<code>_build_key_from_attrs(attrs)</code>","text":"<p>Return tuple of field values in declared order, or None if any missing.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._current_key_of_vertex","title":"<code>_current_key_of_vertex(vertex_id)</code>","text":"<p>Read the current key tuple of a vertex from vertex_attributes (None if incomplete).</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._gen_vertex_id_from_key","title":"<code>_gen_vertex_id_from_key(key_tuple)</code>","text":"<p>Deterministic, human-readable vertex_id from a composite key.</p>"},{"location":"reference/annnet_core/#attribute-tables","title":"Attribute Tables","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass","title":"<code>annnet.core._Annotation.AttributesClass</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_graph_attribute","title":"<code>set_graph_attribute(key, value)</code>","text":"<p>Set a graph-level attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>value</code> <code>Any</code> <p>Attribute value.</p> required"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_graph_attribute","title":"<code>get_graph_attribute(key, default=None)</code>","text":"<p>Get a graph-level attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if the attribute is missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_vertex_attrs","title":"<code>set_vertex_attrs(vertex_id, **attrs)</code>","text":"<p>Upsert pure vertex attributes (non-structural) into the vertex table.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_vertex_attrs_bulk","title":"<code>set_vertex_attrs_bulk(updates)</code>","text":"<p>Upsert vertex attributes in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, dict] | Iterable[tuple[str, dict]]</code> <p>Mapping or iterable of <code>(vertex_id, attrs)</code> pairs.</p> required"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_vertex","title":"<code>get_attr_vertex(vertex_id, key, default=None)</code>","text":"<p>Get a single vertex attribute (scalar) or default if missing.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_vertex_attribute","title":"<code>get_vertex_attribute(vertex_id, attribute)</code>","text":"<p>(Legacy alias) Get a single vertex attribute from the Polars DF [DataFrame].</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <code>attribute</code> <code>str or Enum</code> <p>Column name or enum with <code>.value</code>.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>Scalar value if present, else None.</p> See Also <p>get_attr_vertex</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_attrs","title":"<code>set_edge_attrs(edge_id, **attrs)</code>","text":"<p>Upsert pure edge attributes (non-structural) into the edge DF.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_attrs_bulk","title":"<code>set_edge_attrs_bulk(updates)</code>","text":"<p>Upsert edge attributes in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, dict] | Iterable[tuple[str, dict]]</code> <p>Mapping or iterable of <code>(edge_id, attrs)</code> pairs.</p> required"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_edge","title":"<code>get_attr_edge(edge_id, key, default=None)</code>","text":"<p>Get a single edge attribute (scalar) or default if missing.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edge_attribute","title":"<code>get_edge_attribute(edge_id, attribute)</code>","text":"<p>(Legacy alias) Get a single edge attribute from the Polars DF [DataFrame].</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>attribute</code> <code>str or Enum</code> <p>Column name or enum with <code>.value</code>.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>Scalar value if present, else None.</p> See Also <p>get_attr_edge</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_slice_attrs","title":"<code>set_slice_attrs(slice_id, **attrs)</code>","text":"<p>Upsert pure slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_slice_attr","title":"<code>get_slice_attr(slice_id, key, default=None)</code>","text":"<p>Get a single slice attribute (scalar) or default if missing.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_slice_attrs","title":"<code>set_edge_slice_attrs(slice_id, edge_id, **attrs)</code>","text":"<p>Upsert per-slice attributes for a specific edge.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored except <code>weight</code>.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edge_slice_attr","title":"<code>get_edge_slice_attr(slice_id, edge_id, key, default=None)</code>","text":"<p>Get a per-slice attribute for an edge.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_slice_edge_weight","title":"<code>set_slice_edge_weight(slice_id, edge_id, weight)</code>","text":"<p>Set a legacy per-slice weight override for an edge.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>weight</code> <code>float</code> <p>Weight override.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice or edge does not exist.</p> See Also <p>get_effective_edge_weight</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_effective_edge_weight","title":"<code>get_effective_edge_weight(edge_id, slice=None)</code>","text":"<p>Resolve the effective weight for an edge, optionally within a slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>slice</code> <code>str</code> <p>If provided, return the slice override if present; otherwise global weight.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Effective weight.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.audit_attributes","title":"<code>audit_attributes()</code>","text":"<p>Audit attribute tables for extra/missing rows and invalid edge-slice pairs.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Summary with keys: - <code>extra_vertex_rows</code> - <code>extra_edge_rows</code> - <code>missing_vertex_rows</code> - <code>missing_edge_rows</code> - <code>invalid_edge_slice_rows</code></p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._dtype_for_value","title":"<code>_dtype_for_value(v, *, prefer='polars')</code>","text":"<p>INTERNAL: Infer an appropriate dtype class for value <code>v</code>.</p> <ul> <li>If Polars is available and prefer='polars', returns Polars dtype objects.</li> <li>Otherwise returns Narwhals dtype classes.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._is_null_dtype","title":"<code>_is_null_dtype(dtype)</code>","text":"<p>Check if a dtype represents a null/unknown type.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._ensure_attr_columns","title":"<code>_ensure_attr_columns(df, attrs)</code>","text":"<p>Create/align attribute columns and dtypes to accept <code>attrs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>IntoDataFrame</code> <p>Existing attribute table (any supported backend).</p> required <code>attrs</code> <code>dict</code> <p>Incoming key/value pairs to upsert.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Narwhals DataFrame with columns added/cast so inserts/updates work.</p> Notes <ul> <li>New columns are created with the inferred dtype.</li> <li>If a column is Unknown (null-ish) and the incoming value is not,   it is cast to the inferred dtype.</li> <li>If dtypes conflict, both sides upcast to String to avoid schema errors.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._sanitize_value_for_nw","title":"<code>_sanitize_value_for_nw(v)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._is_binary_type","title":"<code>_is_binary_type(dt)</code>","text":"<p>INTERNAL: Robustly identify binary types across backends.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._safe_nw_cast","title":"<code>_safe_nw_cast(column_expr, target_dtype)</code>","text":"<p>INTERNAL: Attempt cast; fallback to String on engine rejection.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._upsert_row","title":"<code>_upsert_row(df, idx, attrs)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._upsert_rows_bulk","title":"<code>_upsert_rows_bulk(df, updates)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._variables_watched_by_vertices","title":"<code>_variables_watched_by_vertices()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._incident_flexible_edges","title":"<code>_incident_flexible_edges(v)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._apply_flexible_direction","title":"<code>_apply_flexible_direction(edge_id)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edge_attrs","title":"<code>get_edge_attrs(edge)</code>","text":"<p>Return the full attribute dict for a single edge.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>int | str</code> <p>Edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Attribute dictionary for that edge. Empty if not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_vertex_attrs","title":"<code>get_vertex_attrs(vertex)</code>","text":"<p>Return the full attribute dict for a single vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex</code> <code>str</code> <p>Vertex ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Attribute dictionary for that vertex. Empty if not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_edges","title":"<code>get_attr_edges(indexes=None)</code>","text":"<p>Retrieve edge attributes as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>Iterable[int] | None</code> <p>Edge indices to retrieve. If None, returns all edges.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of <code>edge_id</code> to attribute dictionaries.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_vertices","title":"<code>get_attr_vertices(vertices=None)</code>","text":"<p>Retrieve vertex (vertex) attributes as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | None</code> <p>Vertex IDs to retrieve. If None, returns all vertices.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of <code>vertex_id</code> to attribute dictionaries.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_from_edges","title":"<code>get_attr_from_edges(key, default=None)</code>","text":"<p>Extract a specific attribute column for all edges.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute column name to extract.</p> required <code>default</code> <code>Any</code> <p>Value to use if the column or value is missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Mapping of <code>edge_id</code> to attribute values.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edges_by_attr","title":"<code>get_edges_by_attr(key, value)</code>","text":"<p>Retrieve all edges where a given attribute equals a specific value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute column name to filter on.</p> required <code>value</code> <code>Any</code> <p>Value to match.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs where the attribute equals <code>value</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_graph_attributes","title":"<code>get_graph_attributes()</code>","text":"<p>Return a shallow copy of the graph-level attributes dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Shallow copy of global graph metadata.</p> Notes <p>Returned value is a shallow copy to prevent external mutation.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_slice_attrs_bulk","title":"<code>set_edge_slice_attrs_bulk(slice_id, items)</code>","text":"<p>Upsert edge-slice attributes for a single slice in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>items</code> <code>Iterable[tuple[str, dict]] | dict[str, dict]</code> <p>Iterable or mapping of <code>(edge_id, attrs)</code> pairs.</p> required"},{"location":"reference/annnet_core/#bulk-operations","title":"Bulk Operations","text":""},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps","title":"<code>annnet.core._BulkOps.BulkOps</code>","text":""},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_vertices_bulk","title":"<code>add_vertices_bulk(vertices, slice=None)</code>","text":"<p>Bulk add vertices with a Polars fast path when available.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>Falls back to Narwhals-based logic when Polars is unavailable.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_vertices_bulk_nw","title":"<code>add_vertices_bulk_nw(vertices, slice=None)</code>","text":"<p>Bulk add vertices using Narwhals-compatible operations.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add.</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>This path is slower than the Polars fast path but preserves behavior.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_edges_bulk","title":"<code>add_edges_bulk(edges, *, slice=None, default_weight=1.0, default_edge_type='regular', default_propagate='none', default_slice_weight=None, default_edge_directed=None)</code>","text":"<p>Bulk add or update binary edges (and vertex-edge edges).</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable</code> <p>Each item can be: - <code>(source, target)</code> - <code>(source, target, weight)</code> - dict with keys <code>source</code>, <code>target</code>, and optional edge fields.</p> required <code>slice</code> <code>str</code> <p>Default slice to place edges into.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight for edges missing an explicit weight.</p> <code>1.0</code> <code>default_edge_type</code> <code>str</code> <p>Default edge type when not provided.</p> <code>'regular'</code> <code>default_propagate</code> <code>(none, shared, all)</code> <p>Default slice propagation mode.</p> <code>'none'</code> <code>default_slice_weight</code> <code>float</code> <p>Default per-slice weight override.</p> <code>None</code> <code>default_edge_directed</code> <code>bool</code> <p>Default per-edge directedness override.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs for created/updated edges.</p> Notes <p>Behavior mirrors <code>add_edge()</code> but grows the matrix once to reduce overhead.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_hyperedges_bulk","title":"<code>add_hyperedges_bulk(hyperedges, *, slice=None, default_weight=1.0, default_edge_directed=None)</code>","text":"<p>Bulk add or update hyperedges.</p> <p>Parameters:</p> Name Type Description Default <code>hyperedges</code> <code>Iterable[dict]</code> <p>Each item can be: - <code>{'members': [...], 'edge_id': ..., 'weight': ..., 'slice': ..., 'attributes': {...}}</code> - <code>{'head': [...], 'tail': [...], ...}</code></p> required <code>slice</code> <code>str</code> <p>Default slice for hyperedges missing an explicit slice.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight for hyperedges missing an explicit weight.</p> <code>1.0</code> <code>default_edge_directed</code> <code>bool</code> <p>Default directedness override.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Hyperedge IDs for created/updated hyperedges.</p> Notes <p>Behavior mirrors <code>add_hyperedge()</code> but grows the matrix once to reduce overhead.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_edges_to_slice_bulk","title":"<code>add_edges_to_slice_bulk(slice_id, edge_ids)</code>","text":"<p>Add many edges to a slice and attach all incident vertices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_ids</code> <code>Iterable[str]</code> <p>Edge identifiers to add.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>No weights are changed in this operation.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_edge_entities_bulk","title":"<code>add_edge_entities_bulk(items, slice=None)</code>","text":"<p>Bulk add edge-entities (vertex-edge hybrids).</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable</code> <p>Accepts: - iterable of string IDs - iterable of <code>(edge_entity_id, attrs)</code> tuples - iterable of dicts with key <code>edge_entity_id</code> (or <code>id</code>)</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>Attribute inserts are batched for efficiency.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.set_vertex_key","title":"<code>set_vertex_key(*fields)</code>","text":"<p>Declare composite key fields and rebuild the uniqueness index.</p> <p>Parameters:</p> Name Type Description Default <code>*fields</code> <code>str</code> <p>Ordered field names used to build a composite key.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If duplicates exist among already-populated vertices.</p> Notes <p>Vertices missing some key fields are skipped during indexing.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.remove_edges","title":"<code>remove_edges(edge_ids)</code>","text":"<p>Remove many edges in one pass.</p> <p>Parameters:</p> Name Type Description Default <code>edge_ids</code> <code>Iterable[str]</code> <p>Edge identifiers to remove.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This is faster than calling <code>remove_edge</code> in a loop.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.remove_vertices","title":"<code>remove_vertices(vertex_ids)</code>","text":"<p>Remove many vertices (and their incident edges) in one pass.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_ids</code> <code>Iterable[str]</code> <p>Vertex identifiers to remove.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This is faster than calling <code>remove_vertex</code> in a loop.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps._remove_edges_bulk","title":"<code>_remove_edges_bulk(edge_ids)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps._remove_vertices_bulk","title":"<code>_remove_vertices_bulk(vertex_ids)</code>","text":""},{"location":"reference/annnet_core/#history","title":"History","text":""},{"location":"reference/annnet_core/#annnet.core._History.History","title":"<code>annnet.core._History.History</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._utcnow_iso","title":"<code>_utcnow_iso()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._jsonify","title":"<code>_jsonify(x)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._log_event","title":"<code>_log_event(op, **fields)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._log_mutation","title":"<code>_log_mutation(name=None)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._install_history_hooks","title":"<code>_install_history_hooks()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History.history","title":"<code>history(as_df=False)</code>","text":"<p>Return the append-only mutation history.</p> <p>Parameters:</p> Name Type Description Default <code>as_df</code> <code>bool</code> <p>If True, return a DataFrame; otherwise return a list of dicts.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[dict] | DataFrame</code> <p>Event records including <code>version</code>, <code>ts_utc</code>, <code>mono_ns</code>, <code>op</code>, and captured arguments/results.</p> Notes <p>Ordering is guaranteed by <code>version</code> and <code>mono_ns</code>. The log is in-memory until exported.</p>"},{"location":"reference/annnet_core/#annnet.core._History.History.export_history","title":"<code>export_history(path)</code>","text":"<p>Write the mutation history to disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output path. Supported extensions: <code>.parquet</code>, <code>.ndjson</code>/<code>.jsonl</code>, <code>.json</code>, <code>.csv</code>. Unknown extensions default to Parquet.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of events written. Returns 0 if the history is empty.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the file cannot be written.</p> Notes <p>Unknown extensions default to Parquet by appending <code>.parquet</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._History.History.enable_history","title":"<code>enable_history(flag=True)</code>","text":"<p>Enable or disable in-memory mutation logging.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>When True, start/continue logging; when False, pause logging.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._History.History.clear_history","title":"<code>clear_history()</code>","text":"<p>Clear the in-memory mutation log.</p> <p>Returns:</p> Type Description <code>None</code> Notes <p>This does not delete any files previously exported.</p>"},{"location":"reference/annnet_core/#annnet.core._History.History.mark","title":"<code>mark(label)</code>","text":"<p>Insert a manual marker into the mutation history.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable tag for the marker event.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>The event is recorded with <code>op='mark'</code> alongside standard fields (<code>version</code>, <code>ts_utc</code>, <code>mono_ns</code>). Logging must be enabled for the marker to be recorded.</p>"},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff","title":"<code>annnet.core._History.GraphDiff</code>","text":"<p>Represents the difference between two graph states.</p> <p>Attributes:</p> Name Type Description <code>vertices_added</code> <code>set</code> <p>Vertices in b but not in a</p> <code>vertices_removed</code> <code>set</code> <p>Vertices in a but not in b</p> <code>edges_added</code> <code>set</code> <p>Edges in b but not in a</p> <code>edges_removed</code> <code>set</code> <p>Edges in a but not in b</p> <code>slices_added</code> <code>set</code> <p>slices in b but not in a</p> <code>slices_removed</code> <code>set</code> <p>slices in a but not in b</p>"},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.snapshot_a","title":"<code>snapshot_a = snapshot_a</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.snapshot_b","title":"<code>snapshot_b = snapshot_b</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.vertices_added","title":"<code>vertices_added = snapshot_b['vertex_ids'] - snapshot_a['vertex_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.vertices_removed","title":"<code>vertices_removed = snapshot_a['vertex_ids'] - snapshot_b['vertex_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.edges_added","title":"<code>edges_added = snapshot_b['edge_ids'] - snapshot_a['edge_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.edges_removed","title":"<code>edges_removed = snapshot_a['edge_ids'] - snapshot_b['edge_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.slices_added","title":"<code>slices_added = snapshot_b['slice_ids'] - snapshot_a['slice_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.slices_removed","title":"<code>slices_removed = snapshot_a['slice_ids'] - snapshot_b['slice_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.__init__","title":"<code>__init__(snapshot_a, snapshot_b)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of differences.</p> <p>Returns:</p> Type Description <code>str</code> <p>Summary text describing added/removed vertices, edges, and slices.</p>"},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.is_empty","title":"<code>is_empty()</code>","text":"<p>Check whether the diff contains no changes.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.__repr__","title":"<code>__repr__()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the diff to a serializable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_core/#cache-operations","title":"Cache &amp; Operations","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager","title":"<code>annnet.core._Cache.CacheManager</code>","text":"<p>Cache manager for materialized views (CSR/CSC).</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csr","title":"<code>_csr = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csc","title":"<code>_csc = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._adjacency","title":"<code>_adjacency = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csr_version","title":"<code>_csr_version = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csc_version","title":"<code>_csc_version = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._adjacency_version","title":"<code>_adjacency_version = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.csr","title":"<code>csr</code>  <code>property</code>","text":"<p>Return the CSR (Compressed Sparse Row) matrix.</p> <p>Returns:</p> Type Description <code>csr_matrix</code> Notes <p>Built and cached on first access.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.csc","title":"<code>csc</code>  <code>property</code>","text":"<p>Return the CSC (Compressed Sparse Column) matrix.</p> <p>Returns:</p> Type Description <code>csc_matrix</code> Notes <p>Built and cached on first access.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.adjacency","title":"<code>adjacency</code>  <code>property</code>","text":"<p>Return the adjacency matrix computed from incidence.</p> <p>Returns:</p> Type Description <code>spmatrix</code> Notes <p>For incidence matrix <code>B</code>, adjacency is computed as <code>A = B @ B.T</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.has_csr","title":"<code>has_csr()</code>","text":"<p>Check whether a valid CSR cache exists.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.has_csc","title":"<code>has_csc()</code>","text":"<p>Check whether a valid CSC cache exists.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.has_adjacency","title":"<code>has_adjacency()</code>","text":"<p>Check whether a valid adjacency cache exists.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.get_csr","title":"<code>get_csr()</code>","text":"<p>Return the cached CSR matrix.</p> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.get_csc","title":"<code>get_csc()</code>","text":"<p>Return the cached CSC matrix.</p> <p>Returns:</p> Type Description <code>csc_matrix</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.get_adjacency","title":"<code>get_adjacency()</code>","text":"<p>Return the cached adjacency matrix.</p> <p>Returns:</p> Type Description <code>spmatrix</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.invalidate","title":"<code>invalidate(formats=None)</code>","text":"<p>Invalidate cached formats.</p> <p>Parameters:</p> Name Type Description Default <code>formats</code> <code>list[str]</code> <p>Formats to invalidate (<code>'csr'</code>, <code>'csc'</code>, <code>'adjacency'</code>). If None, invalidate all.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.build","title":"<code>build(formats=None)</code>","text":"<p>Pre-build specified formats (eager caching).</p> <p>Parameters:</p> Name Type Description Default <code>formats</code> <code>list[str]</code> <p>Formats to build (<code>'csr'</code>, <code>'csc'</code>, <code>'adjacency'</code>). If None, build all.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.clear","title":"<code>clear()</code>","text":"<p>Clear all caches.</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.info","title":"<code>info()</code>","text":"<p>Get cache status and memory usage.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Status and size information for each cached format.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations","title":"<code>annnet.core._Cache.Operations</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.Operations-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.edge_subgraph","title":"<code>edge_subgraph(edges)</code>","text":"<p>Create a subgraph containing only a specified subset of edges.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable[str] | Iterable[int]</code> <p>Edge identifiers or edge indices to retain.</p> required <p>Returns:</p> Type Description <code>AnnNet</code> <p>Subgraph containing selected edges and their incident vertices.</p> Notes <p>Hyperedges are supported and retain all member vertices.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.subgraph","title":"<code>subgraph(vertices)</code>","text":"<p>Create a vertex-induced subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex identifiers to retain.</p> required <p>Returns:</p> Type Description <code>AnnNet</code> <p>Subgraph containing only the specified vertices and their internal edges.</p> Notes <p>For hyperedges, all member vertices must be included to retain the edge.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.extract_subgraph","title":"<code>extract_subgraph(vertices=None, edges=None)</code>","text":"<p>Create a subgraph based on vertex and/or edge filters.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | None</code> <p>Vertex IDs to include. If None, no vertex filtering is applied.</p> <code>None</code> <code>edges</code> <code>Iterable[str] | Iterable[int] | None</code> <p>Edge IDs or indices to include. If None, no edge filtering is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Filtered subgraph.</p> Notes <p>This is a convenience method that delegates to <code>subgraph()</code> and <code>edge_subgraph()</code> internally.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.reverse","title":"<code>reverse()</code>","text":"<p>Return a new graph with all directed edges reversed.</p> <p>Returns:</p> Type Description <code>AnnNet</code> <p>A new <code>AnnNet</code> instance with reversed directionality where applicable.</p> Behavior <ul> <li>Binary edges: direction is flipped by swapping source and target.</li> <li>Directed hyperedges: <code>head</code> and <code>tail</code> sets are swapped.</li> <li>Undirected edges/hyperedges: unaffected.</li> <li>Edge attributes and metadata are preserved.</li> </ul> Notes <ul> <li>This operation does not modify the original graph.</li> <li>If the graph is undirected (<code>self.directed == False</code>), the result is   identical to the original.</li> <li>For mixed graphs (directed + undirected edges), only the directed   ones are reversed.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.subgraph_from_slice","title":"<code>subgraph_from_slice(slice_id, *, resolve_slice_weights=True)</code>","text":"<p>Create a subgraph induced by a single slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>resolve_slice_weights</code> <code>bool</code> <p>If True, use per-slice edge weights when available.</p> <code>True</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Subgraph containing the slice vertices and edges.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations._row_attrs","title":"<code>_row_attrs(df, key_col, key)</code>","text":"<p>INTERNAL: return a dict of attributes for the row in <code>df</code> where <code>key_col == key</code>, excluding the key column itself. If not found or df empty, return {}. Caches per (id(df), key_col) for speed; cache auto-refreshes when the df object changes.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.copy","title":"<code>copy(history=False)</code>","text":"<p>Deep copy of the entire AnnNet.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>bool</code> <p>If True, copy the mutation history and snapshot timeline. If False, the new graph starts with a clean history.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>A new graph with full structural and attribute fidelity.</p> Notes <p>O(N) Python, O(nnz) matrix; this path is optimized for speed.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.memory_usage","title":"<code>memory_usage()</code>","text":"<p>Approximate total memory usage in bytes.</p> <p>Returns:</p> Type Description <code>int</code> <p>Estimated bytes for the incidence matrix, dictionaries, and attribute DFs.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.get_vertex_incidence_matrix_as_lists","title":"<code>get_vertex_incidence_matrix_as_lists(values=False)</code>","text":"<p>Materialize the vertex\u2013edge incidence structure as Python lists.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(bool, optional(default=False))</code> <ul> <li>If <code>False</code>, returns edge indices incident to each vertex.</li> <li>If <code>True</code>, returns the matrix values (usually weights or 1/0) for each incident edge instead of the indices.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>A mapping from <code>vertex_id</code> - list of incident edges (indices or values), where: - Keys are vertex IDs. - Values are lists of edge indices (if <code>values=False</code>) or numeric values from the incidence matrix (if <code>values=True</code>).</p> Notes <ul> <li>Internally uses the sparse incidence matrix <code>self._matrix</code>, which is stored as a SciPy CSR (compressed sparse row) matrix or similar.</li> <li>The incidence matrix <code>M</code> is defined as:<ul> <li>Rows: vertices</li> <li>Columns: edges</li> <li>Entry <code>M[i, j]</code> non-zero \u21e8 vertex <code>i</code> is incident to edge <code>j</code>.</li> </ul> </li> <li>This is a convenient method when you want a native-Python structure for downstream use (e.g., exporting, iterating, or visualization).</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.vertex_incidence_matrix","title":"<code>vertex_incidence_matrix(values=False, sparse=False)</code>","text":"<p>Return the vertex\u2013edge incidence matrix in sparse or dense form.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(bool, optional(default=False))</code> <p>If <code>True</code>, include the numeric values stored in the matrix (e.g., weights or signed incidence values). If <code>False</code>, convert the matrix to a binary mask (1 if incident, 0 if not).</p> <code>False</code> <code>sparse</code> <code>(bool, optional(default=False))</code> <ul> <li>If <code>True</code>, return the underlying sparse matrix (CSR).</li> <li>If <code>False</code>, return a dense NumPy ndarray.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>csr_matrix | ndarray</code> <p>The vertex\u2013edge incidence matrix <code>M</code>: - Rows correspond to vertices. - Columns correspond to edges. - <code>M[i, j]</code> \u2260 0 indicates that vertex <code>i</code> is incident to edge <code>j</code>.</p> Notes <ul> <li>If <code>values=False</code>, the returned matrix is binarized before returning.</li> <li>Use <code>sparse=True</code> for large graphs to avoid memory blowups.</li> <li>This is the canonical low-level structure that most algorithms (e.g., spectral clustering, Laplacian construction, hypergraph analytics) rely on.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.__hash__","title":"<code>__hash__()</code>","text":"<p>Return a stable hash representing the current graph structure and metadata.</p> <p>Returns:</p> Type Description <code>int</code> <p>A hash value that uniquely (within high probability) identifies the graph based on its topology and attributes.</p> Behavior <ul> <li>Includes the set of vertices, edges, and directedness in the hash.</li> <li>Includes graph-level attributes (if any) to capture metadata changes.</li> <li>Does not depend on memory addresses or internal object IDs, so the same graph serialized/deserialized or reconstructed with identical structure will produce the same hash.</li> </ul> Notes <ul> <li>This method enables <code>AnnNet</code> objects to be used in hash-based containers (like <code>set</code> or <code>dict</code> keys).</li> <li>If the graph is mutated after hashing (e.g., vertices or edges are added or removed), the hash will no longer reflect the new state.</li> <li>The method uses a deterministic representation: sorted vertex/edge sets ensure that ordering does not affect the hash.</li> </ul>"},{"location":"reference/annnet_core/#views","title":"Views","text":"Internal helpers <p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p> <p>Namespace for index operations. Provides clean API over existing dicts.</p> <p>Represents the difference between two graph states.</p> <p>Attributes:</p> Name Type Description <code>vertices_added</code> <code>set</code> <p>Vertices in b but not in a</p> <code>vertices_removed</code> <code>set</code> <p>Vertices in a but not in b</p> <code>edges_added</code> <code>set</code> <p>Edges in b but not in a</p> <code>edges_removed</code> <code>set</code> <p>Edges in a but not in b</p> <code>slices_added</code> <code>set</code> <p>slices in b but not in a</p> <code>slices_removed</code> <code>set</code> <p>slices in a but not in b</p> <p>Cache manager for materialized views (CSR/CSC).</p> <p>Lazy view into a graph with deferred operations.</p> <p>Provides filtered access to graph components without copying the underlying data. Views can be materialized into concrete subgraphs when needed.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>AnnNet</code> <p>Parent graph instance</p> required <code>vertices</code> <code>list[str] | set[str] | callable | None</code> <p>vertex IDs to include, or predicate function</p> <code>None</code> <code>edges</code> <code>list[str] | set[str] | callable | None</code> <p>Edge IDs to include, or predicate function</p> <code>None</code> <code>slices</code> <code>str | list[str] | None</code> <p>slice ID(s) to include</p> <code>None</code> <code>predicate</code> <code>callable | None</code> <p>Additional filter: predicate(vertex_id) -&gt; bool</p> <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView","title":"<code>annnet.core._Views.GraphView</code>","text":"<p>Lazy view into a graph with deferred operations.</p> <p>Provides filtered access to graph components without copying the underlying data. Views can be materialized into concrete subgraphs when needed.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>AnnNet</code> <p>Parent graph instance</p> required <code>vertices</code> <code>list[str] | set[str] | callable | None</code> <p>vertex IDs to include, or predicate function</p> <code>None</code> <code>edges</code> <code>list[str] | set[str] | callable | None</code> <p>Edge IDs to include, or predicate function</p> <code>None</code> <code>slices</code> <code>str | list[str] | None</code> <p>slice ID(s) to include</p> <code>None</code> <code>predicate</code> <code>callable | None</code> <p>Additional filter: predicate(vertex_id) -&gt; bool</p> <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._graph","title":"<code>_graph = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._vertices_filter","title":"<code>_vertices_filter = vertices</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._edges_filter","title":"<code>_edges_filter = edges</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._predicate","title":"<code>_predicate = predicate</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._slices","title":"<code>_slices = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._vertex_ids_cache","title":"<code>_vertex_ids_cache = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._edge_ids_cache","title":"<code>_edge_ids_cache = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._computed","title":"<code>_computed = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.obs","title":"<code>obs</code>  <code>property</code>","text":"<p>Return the filtered vertex attribute table for this view.</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.vertex_attributes</code> and filters by the view's vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.var","title":"<code>var</code>  <code>property</code>","text":"<p>Return the filtered edge attribute table for this view.</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.edge_attributes</code> and filters by the view's edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.X","title":"<code>X</code>  <code>property</code>","text":"<p>Return the filtered incidence matrix subview.</p> <p>Returns:</p> Type Description <code>dok_matrix</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.vertex_ids","title":"<code>vertex_ids</code>  <code>property</code>","text":"<p>Get filtered vertex IDs (cached).</p> <p>Returns:</p> Type Description <code>set[str] | None</code> <p>None means no vertex filter (full graph).</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.edge_ids","title":"<code>edge_ids</code>  <code>property</code>","text":"<p>Get filtered edge IDs (cached).</p> <p>Returns:</p> Type Description <code>set[str] | None</code> <p>None means no edge filter (full graph).</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.vertex_count","title":"<code>vertex_count</code>  <code>property</code>","text":"<p>Return the number of vertices in this view.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.edge_count","title":"<code>edge_count</code>  <code>property</code>","text":"<p>Return the number of edges in this view.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.__init__","title":"<code>__init__(graph, vertices=None, edges=None, slices=None, predicate=None)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._compute_ids","title":"<code>_compute_ids()</code>","text":"<p>Compute and cache filtered vertex and edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.edges_df","title":"<code>edges_df(**kwargs)</code>","text":"<p>Return an edge DataFrame view filtered to this view's edges.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Passed through to <code>AnnNet.edges_view()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.edges_view()</code> and then filters by the view's edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.vertices_df","title":"<code>vertices_df(**kwargs)</code>","text":"<p>Return a vertex DataFrame view filtered to this view's vertices.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Passed through to <code>AnnNet.vertices_view()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.vertices_view()</code> and then filters by the view's vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.materialize","title":"<code>materialize(copy_attributes=True)</code>","text":"<p>Create a concrete subgraph from this view.</p> <p>Parameters:</p> Name Type Description Default <code>copy_attributes</code> <code>bool</code> <p>If True, copy vertex/edge attributes into the new graph.</p> <code>True</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Materialized subgraph.</p> Notes <p>Uses <code>AnnNet.add_vertex()</code>, <code>add_edge()</code>, <code>add_hyperedge()</code>, and <code>get_*_attrs()</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.subview","title":"<code>subview(vertices=None, edges=None, slices=None, predicate=None)</code>","text":"<p>Create a new GraphView by further restricting this view.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | callable | None</code> <p>Vertex IDs or predicate; intersects with current view if provided.</p> <code>None</code> <code>edges</code> <code>Iterable[str] | callable | None</code> <p>Edge IDs or predicate; intersects with current view if provided.</p> <code>None</code> <code>slices</code> <code>Iterable[str] | None</code> <p>Slice IDs to include. Defaults to current view's slices if None.</p> <code>None</code> <code>predicate</code> <code>callable | None</code> <p>Additional vertex predicate applied in conjunction with existing filters.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> Notes <p>Predicates are combined with logical AND.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of this view.</p> <p>Returns:</p> Type Description <code>str</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.__repr__","title":"<code>__repr__()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.__len__","title":"<code>__len__()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass","title":"<code>annnet.core._Views.ViewsClass</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.edges_view","title":"<code>edges_view(slice=None, include_directed=True, include_weight=True, resolved_weight=True, copy=True)</code>","text":"<p>Build a DataFrame view of edges with optional slice join.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice ID to join per-slice attributes.</p> <code>None</code> <code>include_directed</code> <code>bool</code> <p>Include directedness column.</p> <code>True</code> <code>include_weight</code> <code>bool</code> <p>Include global weight column.</p> <code>True</code> <code>resolved_weight</code> <code>bool</code> <p>Include effective weight (slice override if present).</p> <code>True</code> <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame if True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Vectorized implementation avoids per-edge scans.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.vertices_view","title":"<code>vertices_view(copy=True)</code>","text":"<p>Read-only vertex attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> <p>Columns include <code>vertex_id</code> plus pure attributes.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.slices_view","title":"<code>slices_view(copy=True)</code>","text":"<p>Read-only slice attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> <p>Columns include <code>slice_id</code> plus pure attributes.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.aspects_view","title":"<code>aspects_view(copy=True)</code>","text":"<p>Return a view of Kivela aspects and their metadata.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Columns include <code>aspect</code>, <code>elem_layers</code>, and any aspect attribute keys.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.layers_view","title":"<code>layers_view(copy=True)</code>","text":"<p>Return a read-only table of multi-aspect layers.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Columns include <code>layer_tuple</code>, <code>layer_id</code>, aspect columns, layer attributes, and prefixed elementary layer attributes.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.directed","title":"<code>directed = directed</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_RESERVED","title":"<code>_vertex_RESERVED = set(_vertex_RESERVED)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._EDGE_RESERVED","title":"<code>_EDGE_RESERVED = set(_EDGE_RESERVED)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._slice_RESERVED","title":"<code>_slice_RESERVED = set(_slice_RESERVED)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.entity_to_idx","title":"<code>entity_to_idx = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.idx_to_entity","title":"<code>idx_to_entity = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.entity_types","title":"<code>entity_types = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_to_idx","title":"<code>edge_to_idx = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.idx_to_edge","title":"<code>idx_to_edge = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_definitions","title":"<code>edge_definitions = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_weights","title":"<code>edge_weights = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_directed","title":"<code>edge_directed = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_direction_policy","title":"<code>edge_direction_policy = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_key_fields","title":"<code>_vertex_key_fields = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_key_index","title":"<code>_vertex_key_index = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._num_entities","title":"<code>_num_entities = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._num_edges","title":"<code>_num_edges = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._annotations_backend","title":"<code>_annotations_backend = annotations_backend</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.hyperedge_definitions","title":"<code>hyperedge_definitions = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.graph_attributes","title":"<code>graph_attributes = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._next_edge_id","title":"<code>_next_edge_id = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._slices","title":"<code>_slices = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._default_slice","title":"<code>_default_slice = 'default'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.slice_edge_weights","title":"<code>slice_edge_weights = defaultdict(dict)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._current_slice","title":"<code>_current_slice = self._default_slice</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._matrix","title":"<code>_matrix = sp.dok_matrix((n, e), dtype=(np.float32))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._grow_rows_to","title":"<code>_grow_rows_to = _grow_rows_to</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._grow_cols_to","title":"<code>_grow_cols_to = _grow_cols_to</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._history_enabled","title":"<code>_history_enabled = True</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._history","title":"<code>_history = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._version","title":"<code>_version = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._history_clock0","title":"<code>_history_clock0 = time.perf_counter_ns()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._snapshots","title":"<code>_snapshots = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.aspects","title":"<code>aspects = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.elem_layers","title":"<code>elem_layers = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._all_layers","title":"<code>_all_layers = ()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._V","title":"<code>_V = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._VM","title":"<code>_VM = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.vertex_aligned","title":"<code>vertex_aligned = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._nl_to_row","title":"<code>_nl_to_row = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._row_to_nl","title":"<code>_row_to_nl = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._legacy_single_aspect_enabled","title":"<code>_legacy_single_aspect_enabled = True</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_kind","title":"<code>edge_kind = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_layers","title":"<code>edge_layers = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._aspect_attrs","title":"<code>_aspect_attrs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._layer_attrs","title":"<code>_layer_attrs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._vertex_layer_attrs","title":"<code>_vertex_layer_attrs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.V","title":"<code>V</code>  <code>property</code>","text":"<p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.E","title":"<code>E</code>  <code>property</code>","text":"<p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.num_vertices","title":"<code>num_vertices</code>  <code>property</code>","text":"<p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.num_edges","title":"<code>num_edges</code>  <code>property</code>","text":"<p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.nv","title":"<code>nv</code>  <code>property</code>","text":"<p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.ne","title":"<code>ne</code>  <code>property</code>","text":"<p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.nx","title":"<code>nx</code>  <code>property</code>","text":"<p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.ig","title":"<code>ig</code>  <code>property</code>","text":"<p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.gt","title":"<code>gt</code>  <code>property</code>","text":"<p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.obs","title":"<code>obs</code>  <code>property</code>","text":"<p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.var","title":"<code>var</code>  <code>property</code>","text":"<p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.uns","title":"<code>uns</code>  <code>property</code>","text":"<p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.slices","title":"<code>slices</code>  <code>property</code>","text":"<p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.layers","title":"<code>layers</code>  <code>property</code>","text":"<p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.idx","title":"<code>idx</code>  <code>property</code>","text":"<p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.cache","title":"<code>cache</code>  <code>property</code>","text":"<p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._init_annotation_tables","title":"<code>_init_annotation_tables(annotations)</code>","text":""},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_vertex","title":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code>","text":"<p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_vertices","title":"<code>add_vertices(vertices, slice=None, **attributes)</code>","text":"<p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_edge_entity","title":"<code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code>","text":"<p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_edge","title":"<code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code>","text":"<p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_parallel_edge","title":"<code>add_parallel_edge(source, target, weight=1.0, **attributes)</code>","text":"<p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_hyperedge","title":"<code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code>","text":"<p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.set_hyperedge_coeffs","title":"<code>set_hyperedge_coeffs(edge_id, coeffs)</code>","text":"<p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.add_edge_to_slice","title":"<code>add_edge_to_slice(lid, eid)</code>","text":"<p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.make_undirected","title":"<code>make_undirected(*, drop_flexible=True, update_default=True)</code>","text":"<p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.remove_edge","title":"<code>remove_edge(edge_id)</code>","text":"<p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.remove_vertex","title":"<code>remove_vertex(vertex_id)</code>","text":"<p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.remove_slice","title":"<code>remove_slice(slice_id)</code>","text":"<p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_vertex","title":"<code>get_vertex(index)</code>","text":"<p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_edge","title":"<code>get_edge(index)</code>","text":"<p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.incident_edges","title":"<code>incident_edges(vertex_id)</code>","text":"<p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.has_edge","title":"<code>has_edge(source=None, target=None, edge_id=None)</code>","text":"<p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.has_vertex","title":"<code>has_vertex(vertex_id)</code>","text":"<p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_edge_ids","title":"<code>get_edge_ids(source, target)</code>","text":"<p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.degree","title":"<code>degree(entity_id)</code>","text":"<p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.vertices","title":"<code>vertices()</code>","text":"<p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edges","title":"<code>edges()</code>","text":"<p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.edge_list","title":"<code>edge_list()</code>","text":"<p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_directed_edges","title":"<code>get_directed_edges()</code>","text":"<p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_undirected_edges","title":"<code>get_undirected_edges()</code>","text":"<p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.number_of_vertices","title":"<code>number_of_vertices()</code>","text":"<p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.number_of_edges","title":"<code>number_of_edges()</code>","text":"<p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.global_entity_count","title":"<code>global_entity_count()</code>","text":"<p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.global_edge_count","title":"<code>global_edge_count()</code>","text":"<p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.in_edges","title":"<code>in_edges(vertices)</code>","text":"<p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.out_edges","title":"<code>out_edges(vertices)</code>","text":"<p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.get_or_create_vertex_by_attrs","title":"<code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code>","text":"<p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.vertex_key_tuple","title":"<code>vertex_key_tuple(vertex_id)</code>","text":"<p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.X","title":"<code>X()</code>","text":"<p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.write","title":"<code>write(path, **kwargs)</code>","text":"<p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.read","title":"<code>read(path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.view","title":"<code>view(vertices=None, edges=None, slices=None, predicate=None)</code>","text":"<p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.snapshot","title":"<code>snapshot(label=None)</code>","text":"<p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.diff","title":"<code>diff(a, b=None)</code>","text":"<p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/annnet_core/#annnet.core.graph.AnnNet.list_snapshots","title":"<code>list_snapshots()</code>","text":"<p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entity_to_row","title":"<code>entity_to_row(entity_id)</code>","text":"<p>Map an entity ID to its matrix row index.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Row index for the entity.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the entity is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.row_to_entity","title":"<code>row_to_entity(row)</code>","text":"<p>Map a matrix row index to its entity ID.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>Row index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Entity identifier.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the row index is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entities_to_rows","title":"<code>entities_to_rows(entity_ids)</code>","text":"<p>Batch convert entity IDs to row indices.</p> <p>Parameters:</p> Name Type Description Default <code>entity_ids</code> <code>Iterable[str]</code> <p>Entity identifiers.</p> required <p>Returns:</p> Type Description <code>list[int]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.rows_to_entities","title":"<code>rows_to_entities(rows)</code>","text":"<p>Batch convert row indices to entity IDs.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>Iterable[int]</code> <p>Row indices.</p> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.edge_to_col","title":"<code>edge_to_col(edge_id)</code>","text":"<p>Map an edge ID to its matrix column index.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Column index for the edge.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.col_to_edge","title":"<code>col_to_edge(col)</code>","text":"<p>Map a matrix column index to its edge ID.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>int</code> <p>Column index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Edge identifier.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the column index is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.edges_to_cols","title":"<code>edges_to_cols(edge_ids)</code>","text":"<p>Batch convert edge IDs to column indices.</p> <p>Parameters:</p> Name Type Description Default <code>edge_ids</code> <code>Iterable[str]</code> <p>Edge identifiers.</p> required <p>Returns:</p> Type Description <code>list[int]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.cols_to_edges","title":"<code>cols_to_edges(cols)</code>","text":"<p>Batch convert column indices to edge IDs.</p> <p>Parameters:</p> Name Type Description Default <code>cols</code> <code>Iterable[int]</code> <p>Column indices.</p> required <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entity_type","title":"<code>entity_type(entity_id)</code>","text":"<p>Get the entity type for an ID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>'vertex'</code> or <code>'edge'</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the entity is not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.is_vertex","title":"<code>is_vertex(entity_id)</code>","text":"<p>Check whether an entity ID refers to a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.is_edge_entity","title":"<code>is_edge_entity(entity_id)</code>","text":"<p>Check whether an entity ID refers to an edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.has_entity","title":"<code>has_entity(entity_id)</code>","text":"<p>Check if an ID exists as any entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.has_vertex","title":"<code>has_vertex(vertex_id)</code>","text":"<p>Check if an ID exists and is a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.has_edge_id","title":"<code>has_edge_id(edge_id)</code>","text":"<p>Check if an edge ID exists.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.edge_count","title":"<code>edge_count()</code>","text":"<p>Return the number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.entity_count","title":"<code>entity_count()</code>","text":"<p>Return the number of entities (vertices + edge-entities).</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.vertex_count","title":"<code>vertex_count()</code>","text":"<p>Return the number of true vertices (excludes edge-entities).</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexManager.stats","title":"<code>stats()</code>","text":"<p>Return index statistics for entities and edges.</p> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._get_next_edge_id","title":"<code>_get_next_edge_id()</code>","text":"<p>INTERNAL: Generate a unique edge ID for parallel edges.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fresh <code>edge_&lt;n&gt;</code> identifier (monotonic counter).</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._ensure_vertex_table","title":"<code>_ensure_vertex_table()</code>","text":"<p>INTERNAL: Ensure the vertex attribute table exists with a canonical schema.</p> Notes <ul> <li>Creates an empty Polars DF [DataFrame] with a single <code>Utf8</code> <code>vertex_id</code> column if missing or malformed.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._ensure_vertex_row","title":"<code>_ensure_vertex_row(vertex_id)</code>","text":"<p>INTERNAL: Ensure a row for <code>vertex_id</code> exists in the vertex attribute DF.</p> Notes <ul> <li>Appends a new row with <code>vertex_id</code> and <code>None</code> for other columns if absent.</li> <li>Preserves existing schema and columns.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._vertex_key_enabled","title":"<code>_vertex_key_enabled()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._build_key_from_attrs","title":"<code>_build_key_from_attrs(attrs)</code>","text":"<p>Return tuple of field values in declared order, or None if any missing.</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._current_key_of_vertex","title":"<code>_current_key_of_vertex(vertex_id)</code>","text":"<p>Read the current key tuple of a vertex from vertex_attributes (None if incomplete).</p>"},{"location":"reference/annnet_core/#annnet.core._Index.IndexMapping._gen_vertex_id_from_key","title":"<code>_gen_vertex_id_from_key(key_tuple)</code>","text":"<p>Deterministic, human-readable vertex_id from a composite key.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_graph_attribute","title":"<code>set_graph_attribute(key, value)</code>","text":"<p>Set a graph-level attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>value</code> <code>Any</code> <p>Attribute value.</p> required"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_graph_attribute","title":"<code>get_graph_attribute(key, default=None)</code>","text":"<p>Get a graph-level attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if the attribute is missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_vertex_attrs","title":"<code>set_vertex_attrs(vertex_id, **attrs)</code>","text":"<p>Upsert pure vertex attributes (non-structural) into the vertex table.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_vertex_attrs_bulk","title":"<code>set_vertex_attrs_bulk(updates)</code>","text":"<p>Upsert vertex attributes in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, dict] | Iterable[tuple[str, dict]]</code> <p>Mapping or iterable of <code>(vertex_id, attrs)</code> pairs.</p> required"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_vertex","title":"<code>get_attr_vertex(vertex_id, key, default=None)</code>","text":"<p>Get a single vertex attribute (scalar) or default if missing.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_vertex_attribute","title":"<code>get_vertex_attribute(vertex_id, attribute)</code>","text":"<p>(Legacy alias) Get a single vertex attribute from the Polars DF [DataFrame].</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <code>attribute</code> <code>str or Enum</code> <p>Column name or enum with <code>.value</code>.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>Scalar value if present, else None.</p> See Also <p>get_attr_vertex</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_attrs","title":"<code>set_edge_attrs(edge_id, **attrs)</code>","text":"<p>Upsert pure edge attributes (non-structural) into the edge DF.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_attrs_bulk","title":"<code>set_edge_attrs_bulk(updates)</code>","text":"<p>Upsert edge attributes in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, dict] | Iterable[tuple[str, dict]]</code> <p>Mapping or iterable of <code>(edge_id, attrs)</code> pairs.</p> required"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_edge","title":"<code>get_attr_edge(edge_id, key, default=None)</code>","text":"<p>Get a single edge attribute (scalar) or default if missing.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edge_attribute","title":"<code>get_edge_attribute(edge_id, attribute)</code>","text":"<p>(Legacy alias) Get a single edge attribute from the Polars DF [DataFrame].</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>attribute</code> <code>str or Enum</code> <p>Column name or enum with <code>.value</code>.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>Scalar value if present, else None.</p> See Also <p>get_attr_edge</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_slice_attrs","title":"<code>set_slice_attrs(slice_id, **attrs)</code>","text":"<p>Upsert pure slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_slice_attr","title":"<code>get_slice_attr(slice_id, key, default=None)</code>","text":"<p>Get a single slice attribute (scalar) or default if missing.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_slice_attrs","title":"<code>set_edge_slice_attrs(slice_id, edge_id, **attrs)</code>","text":"<p>Upsert per-slice attributes for a specific edge.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>**attrs</code> <p>Attribute key/value pairs. Structural keys are ignored except <code>weight</code>.</p> <code>{}</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edge_slice_attr","title":"<code>get_edge_slice_attr(slice_id, edge_id, key, default=None)</code>","text":"<p>Get a per-slice attribute for an edge.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>key</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>Any</code> <p>Value to return if missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_slice_edge_weight","title":"<code>set_slice_edge_weight(slice_id, edge_id, weight)</code>","text":"<p>Set a legacy per-slice weight override for an edge.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>weight</code> <code>float</code> <p>Weight override.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice or edge does not exist.</p> See Also <p>get_effective_edge_weight</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_effective_edge_weight","title":"<code>get_effective_edge_weight(edge_id, slice=None)</code>","text":"<p>Resolve the effective weight for an edge, optionally within a slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <code>slice</code> <code>str</code> <p>If provided, return the slice override if present; otherwise global weight.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Effective weight.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.audit_attributes","title":"<code>audit_attributes()</code>","text":"<p>Audit attribute tables for extra/missing rows and invalid edge-slice pairs.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Summary with keys: - <code>extra_vertex_rows</code> - <code>extra_edge_rows</code> - <code>missing_vertex_rows</code> - <code>missing_edge_rows</code> - <code>invalid_edge_slice_rows</code></p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._dtype_for_value","title":"<code>_dtype_for_value(v, *, prefer='polars')</code>","text":"<p>INTERNAL: Infer an appropriate dtype class for value <code>v</code>.</p> <ul> <li>If Polars is available and prefer='polars', returns Polars dtype objects.</li> <li>Otherwise returns Narwhals dtype classes.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._is_null_dtype","title":"<code>_is_null_dtype(dtype)</code>","text":"<p>Check if a dtype represents a null/unknown type.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._ensure_attr_columns","title":"<code>_ensure_attr_columns(df, attrs)</code>","text":"<p>Create/align attribute columns and dtypes to accept <code>attrs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>IntoDataFrame</code> <p>Existing attribute table (any supported backend).</p> required <code>attrs</code> <code>dict</code> <p>Incoming key/value pairs to upsert.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Narwhals DataFrame with columns added/cast so inserts/updates work.</p> Notes <ul> <li>New columns are created with the inferred dtype.</li> <li>If a column is Unknown (null-ish) and the incoming value is not,   it is cast to the inferred dtype.</li> <li>If dtypes conflict, both sides upcast to String to avoid schema errors.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._sanitize_value_for_nw","title":"<code>_sanitize_value_for_nw(v)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._is_binary_type","title":"<code>_is_binary_type(dt)</code>","text":"<p>INTERNAL: Robustly identify binary types across backends.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._safe_nw_cast","title":"<code>_safe_nw_cast(column_expr, target_dtype)</code>","text":"<p>INTERNAL: Attempt cast; fallback to String on engine rejection.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._upsert_row","title":"<code>_upsert_row(df, idx, attrs)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._upsert_rows_bulk","title":"<code>_upsert_rows_bulk(df, updates)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._variables_watched_by_vertices","title":"<code>_variables_watched_by_vertices()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._incident_flexible_edges","title":"<code>_incident_flexible_edges(v)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass._apply_flexible_direction","title":"<code>_apply_flexible_direction(edge_id)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edge_attrs","title":"<code>get_edge_attrs(edge)</code>","text":"<p>Return the full attribute dict for a single edge.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>int | str</code> <p>Edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Attribute dictionary for that edge. Empty if not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_vertex_attrs","title":"<code>get_vertex_attrs(vertex)</code>","text":"<p>Return the full attribute dict for a single vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex</code> <code>str</code> <p>Vertex ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Attribute dictionary for that vertex. Empty if not found.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_edges","title":"<code>get_attr_edges(indexes=None)</code>","text":"<p>Retrieve edge attributes as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>Iterable[int] | None</code> <p>Edge indices to retrieve. If None, returns all edges.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of <code>edge_id</code> to attribute dictionaries.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_vertices","title":"<code>get_attr_vertices(vertices=None)</code>","text":"<p>Retrieve vertex (vertex) attributes as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | None</code> <p>Vertex IDs to retrieve. If None, returns all vertices.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of <code>vertex_id</code> to attribute dictionaries.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_attr_from_edges","title":"<code>get_attr_from_edges(key, default=None)</code>","text":"<p>Extract a specific attribute column for all edges.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute column name to extract.</p> required <code>default</code> <code>Any</code> <p>Value to use if the column or value is missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Mapping of <code>edge_id</code> to attribute values.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_edges_by_attr","title":"<code>get_edges_by_attr(key, value)</code>","text":"<p>Retrieve all edges where a given attribute equals a specific value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute column name to filter on.</p> required <code>value</code> <code>Any</code> <p>Value to match.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs where the attribute equals <code>value</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.get_graph_attributes","title":"<code>get_graph_attributes()</code>","text":"<p>Return a shallow copy of the graph-level attributes dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Shallow copy of global graph metadata.</p> Notes <p>Returned value is a shallow copy to prevent external mutation.</p>"},{"location":"reference/annnet_core/#annnet.core._Annotation.AttributesClass.set_edge_slice_attrs_bulk","title":"<code>set_edge_slice_attrs_bulk(slice_id, items)</code>","text":"<p>Upsert edge-slice attributes for a single slice in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>items</code> <code>Iterable[tuple[str, dict]] | dict[str, dict]</code> <p>Iterable or mapping of <code>(edge_id, attrs)</code> pairs.</p> required"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_vertices_bulk","title":"<code>add_vertices_bulk(vertices, slice=None)</code>","text":"<p>Bulk add vertices with a Polars fast path when available.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>Falls back to Narwhals-based logic when Polars is unavailable.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_vertices_bulk_nw","title":"<code>add_vertices_bulk_nw(vertices, slice=None)</code>","text":"<p>Bulk add vertices using Narwhals-compatible operations.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add.</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>This path is slower than the Polars fast path but preserves behavior.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_edges_bulk","title":"<code>add_edges_bulk(edges, *, slice=None, default_weight=1.0, default_edge_type='regular', default_propagate='none', default_slice_weight=None, default_edge_directed=None)</code>","text":"<p>Bulk add or update binary edges (and vertex-edge edges).</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable</code> <p>Each item can be: - <code>(source, target)</code> - <code>(source, target, weight)</code> - dict with keys <code>source</code>, <code>target</code>, and optional edge fields.</p> required <code>slice</code> <code>str</code> <p>Default slice to place edges into.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight for edges missing an explicit weight.</p> <code>1.0</code> <code>default_edge_type</code> <code>str</code> <p>Default edge type when not provided.</p> <code>'regular'</code> <code>default_propagate</code> <code>(none, shared, all)</code> <p>Default slice propagation mode.</p> <code>'none'</code> <code>default_slice_weight</code> <code>float</code> <p>Default per-slice weight override.</p> <code>None</code> <code>default_edge_directed</code> <code>bool</code> <p>Default per-edge directedness override.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs for created/updated edges.</p> Notes <p>Behavior mirrors <code>add_edge()</code> but grows the matrix once to reduce overhead.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_hyperedges_bulk","title":"<code>add_hyperedges_bulk(hyperedges, *, slice=None, default_weight=1.0, default_edge_directed=None)</code>","text":"<p>Bulk add or update hyperedges.</p> <p>Parameters:</p> Name Type Description Default <code>hyperedges</code> <code>Iterable[dict]</code> <p>Each item can be: - <code>{'members': [...], 'edge_id': ..., 'weight': ..., 'slice': ..., 'attributes': {...}}</code> - <code>{'head': [...], 'tail': [...], ...}</code></p> required <code>slice</code> <code>str</code> <p>Default slice for hyperedges missing an explicit slice.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight for hyperedges missing an explicit weight.</p> <code>1.0</code> <code>default_edge_directed</code> <code>bool</code> <p>Default directedness override.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Hyperedge IDs for created/updated hyperedges.</p> Notes <p>Behavior mirrors <code>add_hyperedge()</code> but grows the matrix once to reduce overhead.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_edges_to_slice_bulk","title":"<code>add_edges_to_slice_bulk(slice_id, edge_ids)</code>","text":"<p>Add many edges to a slice and attach all incident vertices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>edge_ids</code> <code>Iterable[str]</code> <p>Edge identifiers to add.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>No weights are changed in this operation.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.add_edge_entities_bulk","title":"<code>add_edge_entities_bulk(items, slice=None)</code>","text":"<p>Bulk add edge-entities (vertex-edge hybrids).</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable</code> <p>Accepts: - iterable of string IDs - iterable of <code>(edge_entity_id, attrs)</code> tuples - iterable of dicts with key <code>edge_entity_id</code> (or <code>id</code>)</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>Attribute inserts are batched for efficiency.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.set_vertex_key","title":"<code>set_vertex_key(*fields)</code>","text":"<p>Declare composite key fields and rebuild the uniqueness index.</p> <p>Parameters:</p> Name Type Description Default <code>*fields</code> <code>str</code> <p>Ordered field names used to build a composite key.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If duplicates exist among already-populated vertices.</p> Notes <p>Vertices missing some key fields are skipped during indexing.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.remove_edges","title":"<code>remove_edges(edge_ids)</code>","text":"<p>Remove many edges in one pass.</p> <p>Parameters:</p> Name Type Description Default <code>edge_ids</code> <code>Iterable[str]</code> <p>Edge identifiers to remove.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This is faster than calling <code>remove_edge</code> in a loop.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps.remove_vertices","title":"<code>remove_vertices(vertex_ids)</code>","text":"<p>Remove many vertices (and their incident edges) in one pass.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_ids</code> <code>Iterable[str]</code> <p>Vertex identifiers to remove.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This is faster than calling <code>remove_vertex</code> in a loop.</p>"},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps._remove_edges_bulk","title":"<code>_remove_edges_bulk(edge_ids)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._BulkOps.BulkOps._remove_vertices_bulk","title":"<code>_remove_vertices_bulk(vertex_ids)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._utcnow_iso","title":"<code>_utcnow_iso()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._jsonify","title":"<code>_jsonify(x)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._log_event","title":"<code>_log_event(op, **fields)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._log_mutation","title":"<code>_log_mutation(name=None)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History._install_history_hooks","title":"<code>_install_history_hooks()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.History.history","title":"<code>history(as_df=False)</code>","text":"<p>Return the append-only mutation history.</p> <p>Parameters:</p> Name Type Description Default <code>as_df</code> <code>bool</code> <p>If True, return a DataFrame; otherwise return a list of dicts.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[dict] | DataFrame</code> <p>Event records including <code>version</code>, <code>ts_utc</code>, <code>mono_ns</code>, <code>op</code>, and captured arguments/results.</p> Notes <p>Ordering is guaranteed by <code>version</code> and <code>mono_ns</code>. The log is in-memory until exported.</p>"},{"location":"reference/annnet_core/#annnet.core._History.History.export_history","title":"<code>export_history(path)</code>","text":"<p>Write the mutation history to disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output path. Supported extensions: <code>.parquet</code>, <code>.ndjson</code>/<code>.jsonl</code>, <code>.json</code>, <code>.csv</code>. Unknown extensions default to Parquet.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of events written. Returns 0 if the history is empty.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the file cannot be written.</p> Notes <p>Unknown extensions default to Parquet by appending <code>.parquet</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._History.History.enable_history","title":"<code>enable_history(flag=True)</code>","text":"<p>Enable or disable in-memory mutation logging.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>When True, start/continue logging; when False, pause logging.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._History.History.clear_history","title":"<code>clear_history()</code>","text":"<p>Clear the in-memory mutation log.</p> <p>Returns:</p> Type Description <code>None</code> Notes <p>This does not delete any files previously exported.</p>"},{"location":"reference/annnet_core/#annnet.core._History.History.mark","title":"<code>mark(label)</code>","text":"<p>Insert a manual marker into the mutation history.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable tag for the marker event.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>The event is recorded with <code>op='mark'</code> alongside standard fields (<code>version</code>, <code>ts_utc</code>, <code>mono_ns</code>). Logging must be enabled for the marker to be recorded.</p>"},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.snapshot_a","title":"<code>snapshot_a = snapshot_a</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.snapshot_b","title":"<code>snapshot_b = snapshot_b</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.vertices_added","title":"<code>vertices_added = snapshot_b['vertex_ids'] - snapshot_a['vertex_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.vertices_removed","title":"<code>vertices_removed = snapshot_a['vertex_ids'] - snapshot_b['vertex_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.edges_added","title":"<code>edges_added = snapshot_b['edge_ids'] - snapshot_a['edge_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.edges_removed","title":"<code>edges_removed = snapshot_a['edge_ids'] - snapshot_b['edge_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.slices_added","title":"<code>slices_added = snapshot_b['slice_ids'] - snapshot_a['slice_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.slices_removed","title":"<code>slices_removed = snapshot_a['slice_ids'] - snapshot_b['slice_ids']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.__init__","title":"<code>__init__(snapshot_a, snapshot_b)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of differences.</p> <p>Returns:</p> Type Description <code>str</code> <p>Summary text describing added/removed vertices, edges, and slices.</p>"},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.is_empty","title":"<code>is_empty()</code>","text":"<p>Check whether the diff contains no changes.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.__repr__","title":"<code>__repr__()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._History.GraphDiff.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the diff to a serializable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csr","title":"<code>_csr = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csc","title":"<code>_csc = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._adjacency","title":"<code>_adjacency = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csr_version","title":"<code>_csr_version = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._csc_version","title":"<code>_csc_version = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager._adjacency_version","title":"<code>_adjacency_version = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.csr","title":"<code>csr</code>  <code>property</code>","text":"<p>Return the CSR (Compressed Sparse Row) matrix.</p> <p>Returns:</p> Type Description <code>csr_matrix</code> Notes <p>Built and cached on first access.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.csc","title":"<code>csc</code>  <code>property</code>","text":"<p>Return the CSC (Compressed Sparse Column) matrix.</p> <p>Returns:</p> Type Description <code>csc_matrix</code> Notes <p>Built and cached on first access.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.adjacency","title":"<code>adjacency</code>  <code>property</code>","text":"<p>Return the adjacency matrix computed from incidence.</p> <p>Returns:</p> Type Description <code>spmatrix</code> Notes <p>For incidence matrix <code>B</code>, adjacency is computed as <code>A = B @ B.T</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.has_csr","title":"<code>has_csr()</code>","text":"<p>Check whether a valid CSR cache exists.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.has_csc","title":"<code>has_csc()</code>","text":"<p>Check whether a valid CSC cache exists.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.has_adjacency","title":"<code>has_adjacency()</code>","text":"<p>Check whether a valid adjacency cache exists.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.get_csr","title":"<code>get_csr()</code>","text":"<p>Return the cached CSR matrix.</p> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.get_csc","title":"<code>get_csc()</code>","text":"<p>Return the cached CSC matrix.</p> <p>Returns:</p> Type Description <code>csc_matrix</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.get_adjacency","title":"<code>get_adjacency()</code>","text":"<p>Return the cached adjacency matrix.</p> <p>Returns:</p> Type Description <code>spmatrix</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.invalidate","title":"<code>invalidate(formats=None)</code>","text":"<p>Invalidate cached formats.</p> <p>Parameters:</p> Name Type Description Default <code>formats</code> <code>list[str]</code> <p>Formats to invalidate (<code>'csr'</code>, <code>'csc'</code>, <code>'adjacency'</code>). If None, invalidate all.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.build","title":"<code>build(formats=None)</code>","text":"<p>Pre-build specified formats (eager caching).</p> <p>Parameters:</p> Name Type Description Default <code>formats</code> <code>list[str]</code> <p>Formats to build (<code>'csr'</code>, <code>'csc'</code>, <code>'adjacency'</code>). If None, build all.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.clear","title":"<code>clear()</code>","text":"<p>Clear all caches.</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_core/#annnet.core._Cache.CacheManager.info","title":"<code>info()</code>","text":"<p>Get cache status and memory usage.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Status and size information for each cached format.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.edge_subgraph","title":"<code>edge_subgraph(edges)</code>","text":"<p>Create a subgraph containing only a specified subset of edges.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable[str] | Iterable[int]</code> <p>Edge identifiers or edge indices to retain.</p> required <p>Returns:</p> Type Description <code>AnnNet</code> <p>Subgraph containing selected edges and their incident vertices.</p> Notes <p>Hyperedges are supported and retain all member vertices.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.subgraph","title":"<code>subgraph(vertices)</code>","text":"<p>Create a vertex-induced subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex identifiers to retain.</p> required <p>Returns:</p> Type Description <code>AnnNet</code> <p>Subgraph containing only the specified vertices and their internal edges.</p> Notes <p>For hyperedges, all member vertices must be included to retain the edge.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.extract_subgraph","title":"<code>extract_subgraph(vertices=None, edges=None)</code>","text":"<p>Create a subgraph based on vertex and/or edge filters.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | None</code> <p>Vertex IDs to include. If None, no vertex filtering is applied.</p> <code>None</code> <code>edges</code> <code>Iterable[str] | Iterable[int] | None</code> <p>Edge IDs or indices to include. If None, no edge filtering is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Filtered subgraph.</p> Notes <p>This is a convenience method that delegates to <code>subgraph()</code> and <code>edge_subgraph()</code> internally.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.reverse","title":"<code>reverse()</code>","text":"<p>Return a new graph with all directed edges reversed.</p> <p>Returns:</p> Type Description <code>AnnNet</code> <p>A new <code>AnnNet</code> instance with reversed directionality where applicable.</p> Behavior <ul> <li>Binary edges: direction is flipped by swapping source and target.</li> <li>Directed hyperedges: <code>head</code> and <code>tail</code> sets are swapped.</li> <li>Undirected edges/hyperedges: unaffected.</li> <li>Edge attributes and metadata are preserved.</li> </ul> Notes <ul> <li>This operation does not modify the original graph.</li> <li>If the graph is undirected (<code>self.directed == False</code>), the result is   identical to the original.</li> <li>For mixed graphs (directed + undirected edges), only the directed   ones are reversed.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.subgraph_from_slice","title":"<code>subgraph_from_slice(slice_id, *, resolve_slice_weights=True)</code>","text":"<p>Create a subgraph induced by a single slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>resolve_slice_weights</code> <code>bool</code> <p>If True, use per-slice edge weights when available.</p> <code>True</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Subgraph containing the slice vertices and edges.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations._row_attrs","title":"<code>_row_attrs(df, key_col, key)</code>","text":"<p>INTERNAL: return a dict of attributes for the row in <code>df</code> where <code>key_col == key</code>, excluding the key column itself. If not found or df empty, return {}. Caches per (id(df), key_col) for speed; cache auto-refreshes when the df object changes.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.copy","title":"<code>copy(history=False)</code>","text":"<p>Deep copy of the entire AnnNet.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>bool</code> <p>If True, copy the mutation history and snapshot timeline. If False, the new graph starts with a clean history.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>A new graph with full structural and attribute fidelity.</p> Notes <p>O(N) Python, O(nnz) matrix; this path is optimized for speed.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.memory_usage","title":"<code>memory_usage()</code>","text":"<p>Approximate total memory usage in bytes.</p> <p>Returns:</p> Type Description <code>int</code> <p>Estimated bytes for the incidence matrix, dictionaries, and attribute DFs.</p>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.get_vertex_incidence_matrix_as_lists","title":"<code>get_vertex_incidence_matrix_as_lists(values=False)</code>","text":"<p>Materialize the vertex\u2013edge incidence structure as Python lists.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(bool, optional(default=False))</code> <ul> <li>If <code>False</code>, returns edge indices incident to each vertex.</li> <li>If <code>True</code>, returns the matrix values (usually weights or 1/0) for each incident edge instead of the indices.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>A mapping from <code>vertex_id</code> - list of incident edges (indices or values), where: - Keys are vertex IDs. - Values are lists of edge indices (if <code>values=False</code>) or numeric values from the incidence matrix (if <code>values=True</code>).</p> Notes <ul> <li>Internally uses the sparse incidence matrix <code>self._matrix</code>, which is stored as a SciPy CSR (compressed sparse row) matrix or similar.</li> <li>The incidence matrix <code>M</code> is defined as:<ul> <li>Rows: vertices</li> <li>Columns: edges</li> <li>Entry <code>M[i, j]</code> non-zero \u21e8 vertex <code>i</code> is incident to edge <code>j</code>.</li> </ul> </li> <li>This is a convenient method when you want a native-Python structure for downstream use (e.g., exporting, iterating, or visualization).</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.vertex_incidence_matrix","title":"<code>vertex_incidence_matrix(values=False, sparse=False)</code>","text":"<p>Return the vertex\u2013edge incidence matrix in sparse or dense form.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(bool, optional(default=False))</code> <p>If <code>True</code>, include the numeric values stored in the matrix (e.g., weights or signed incidence values). If <code>False</code>, convert the matrix to a binary mask (1 if incident, 0 if not).</p> <code>False</code> <code>sparse</code> <code>(bool, optional(default=False))</code> <ul> <li>If <code>True</code>, return the underlying sparse matrix (CSR).</li> <li>If <code>False</code>, return a dense NumPy ndarray.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>csr_matrix | ndarray</code> <p>The vertex\u2013edge incidence matrix <code>M</code>: - Rows correspond to vertices. - Columns correspond to edges. - <code>M[i, j]</code> \u2260 0 indicates that vertex <code>i</code> is incident to edge <code>j</code>.</p> Notes <ul> <li>If <code>values=False</code>, the returned matrix is binarized before returning.</li> <li>Use <code>sparse=True</code> for large graphs to avoid memory blowups.</li> <li>This is the canonical low-level structure that most algorithms (e.g., spectral clustering, Laplacian construction, hypergraph analytics) rely on.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Cache.Operations.__hash__","title":"<code>__hash__()</code>","text":"<p>Return a stable hash representing the current graph structure and metadata.</p> <p>Returns:</p> Type Description <code>int</code> <p>A hash value that uniquely (within high probability) identifies the graph based on its topology and attributes.</p> Behavior <ul> <li>Includes the set of vertices, edges, and directedness in the hash.</li> <li>Includes graph-level attributes (if any) to capture metadata changes.</li> <li>Does not depend on memory addresses or internal object IDs, so the same graph serialized/deserialized or reconstructed with identical structure will produce the same hash.</li> </ul> Notes <ul> <li>This method enables <code>AnnNet</code> objects to be used in hash-based containers (like <code>set</code> or <code>dict</code> keys).</li> <li>If the graph is mutated after hashing (e.g., vertices or edges are added or removed), the hash will no longer reflect the new state.</li> <li>The method uses a deterministic representation: sorted vertex/edge sets ensure that ordering does not affect the hash.</li> </ul>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView-attributes","title":"Attributes","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._graph","title":"<code>_graph = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._vertices_filter","title":"<code>_vertices_filter = vertices</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._edges_filter","title":"<code>_edges_filter = edges</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._predicate","title":"<code>_predicate = predicate</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._slices","title":"<code>_slices = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._vertex_ids_cache","title":"<code>_vertex_ids_cache = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._edge_ids_cache","title":"<code>_edge_ids_cache = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._computed","title":"<code>_computed = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.obs","title":"<code>obs</code>  <code>property</code>","text":"<p>Return the filtered vertex attribute table for this view.</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.vertex_attributes</code> and filters by the view's vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.var","title":"<code>var</code>  <code>property</code>","text":"<p>Return the filtered edge attribute table for this view.</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.edge_attributes</code> and filters by the view's edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.X","title":"<code>X</code>  <code>property</code>","text":"<p>Return the filtered incidence matrix subview.</p> <p>Returns:</p> Type Description <code>dok_matrix</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.vertex_ids","title":"<code>vertex_ids</code>  <code>property</code>","text":"<p>Get filtered vertex IDs (cached).</p> <p>Returns:</p> Type Description <code>set[str] | None</code> <p>None means no vertex filter (full graph).</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.edge_ids","title":"<code>edge_ids</code>  <code>property</code>","text":"<p>Get filtered edge IDs (cached).</p> <p>Returns:</p> Type Description <code>set[str] | None</code> <p>None means no edge filter (full graph).</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.vertex_count","title":"<code>vertex_count</code>  <code>property</code>","text":"<p>Return the number of vertices in this view.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.edge_count","title":"<code>edge_count</code>  <code>property</code>","text":"<p>Return the number of edges in this view.</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.__init__","title":"<code>__init__(graph, vertices=None, edges=None, slices=None, predicate=None)</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView._compute_ids","title":"<code>_compute_ids()</code>","text":"<p>Compute and cache filtered vertex and edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.edges_df","title":"<code>edges_df(**kwargs)</code>","text":"<p>Return an edge DataFrame view filtered to this view's edges.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Passed through to <code>AnnNet.edges_view()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.edges_view()</code> and then filters by the view's edge IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.vertices_df","title":"<code>vertices_df(**kwargs)</code>","text":"<p>Return a vertex DataFrame view filtered to this view's vertices.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Passed through to <code>AnnNet.vertices_view()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Uses <code>AnnNet.vertices_view()</code> and then filters by the view's vertex IDs.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.materialize","title":"<code>materialize(copy_attributes=True)</code>","text":"<p>Create a concrete subgraph from this view.</p> <p>Parameters:</p> Name Type Description Default <code>copy_attributes</code> <code>bool</code> <p>If True, copy vertex/edge attributes into the new graph.</p> <code>True</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Materialized subgraph.</p> Notes <p>Uses <code>AnnNet.add_vertex()</code>, <code>add_edge()</code>, <code>add_hyperedge()</code>, and <code>get_*_attrs()</code>.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.subview","title":"<code>subview(vertices=None, edges=None, slices=None, predicate=None)</code>","text":"<p>Create a new GraphView by further restricting this view.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | callable | None</code> <p>Vertex IDs or predicate; intersects with current view if provided.</p> <code>None</code> <code>edges</code> <code>Iterable[str] | callable | None</code> <p>Edge IDs or predicate; intersects with current view if provided.</p> <code>None</code> <code>slices</code> <code>Iterable[str] | None</code> <p>Slice IDs to include. Defaults to current view's slices if None.</p> <code>None</code> <code>predicate</code> <code>callable | None</code> <p>Additional vertex predicate applied in conjunction with existing filters.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> Notes <p>Predicates are combined with logical AND.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of this view.</p> <p>Returns:</p> Type Description <code>str</code>"},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.__repr__","title":"<code>__repr__()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.GraphView.__len__","title":"<code>__len__()</code>","text":""},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass-functions","title":"Functions","text":""},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.edges_view","title":"<code>edges_view(slice=None, include_directed=True, include_weight=True, resolved_weight=True, copy=True)</code>","text":"<p>Build a DataFrame view of edges with optional slice join.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice ID to join per-slice attributes.</p> <code>None</code> <code>include_directed</code> <code>bool</code> <p>Include directedness column.</p> <code>True</code> <code>include_weight</code> <code>bool</code> <p>Include global weight column.</p> <code>True</code> <code>resolved_weight</code> <code>bool</code> <p>Include effective weight (slice override if present).</p> <code>True</code> <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame if True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Vectorized implementation avoids per-edge scans.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.vertices_view","title":"<code>vertices_view(copy=True)</code>","text":"<p>Read-only vertex attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> <p>Columns include <code>vertex_id</code> plus pure attributes.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.slices_view","title":"<code>slices_view(copy=True)</code>","text":"<p>Read-only slice attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> <p>Columns include <code>slice_id</code> plus pure attributes.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.aspects_view","title":"<code>aspects_view(copy=True)</code>","text":"<p>Return a view of Kivela aspects and their metadata.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Columns include <code>aspect</code>, <code>elem_layers</code>, and any aspect attribute keys.</p>"},{"location":"reference/annnet_core/#annnet.core._Views.ViewsClass.layers_view","title":"<code>layers_view(copy=True)</code>","text":"<p>Return a read-only table of multi-aspect layers.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Return a cloned DataFrame.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame - like</code> Notes <p>Columns include <code>layer_tuple</code>, <code>layer_id</code>, aspect columns, layer attributes, and prefixed elementary layer attributes.</p>"},{"location":"reference/annnet_layers/","title":"Layers","text":"<p>Layers provide multilayer semantics (aspects, layer tuples, and per-layer attributes). This page covers both the manager API and the mixin used by <code>AnnNet</code>.</p>"},{"location":"reference/annnet_layers/#layer-manager","title":"Layer Manager","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager","title":"<code>annnet.core._Layers.LayerManager</code>","text":"<p>Manager for Kivela multi-layer operations.</p> <p>Provides organized namespace for layer operations by delegating to AnnNet methods. All heavy lifting is done by the AnnNet class; this is just a clean API surface.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager-functions","title":"Functions","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.aspects","title":"<code>aspects()</code>","text":"<p>List aspect names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Aspect identifiers in configured order.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.elementary_layers","title":"<code>elementary_layers()</code>","text":"<p>Return elementary layer labels per aspect.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of aspect name to list of elementary labels.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.layer_tuples","title":"<code>layer_tuples()</code>","text":"<p>List all aspect-tuples (Cartesian product).</p> <p>Returns:</p> Type Description <code>list[tuple[str, ...]]</code> <p>All layer tuples in configured order.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.tuple_id","title":"<code>tuple_id(aa)</code>","text":"<p>Canonical string id for a layer tuple.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Aspect-tuple layer (e.g., <code>(\"t1\",\"F\")</code>).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Canonical id (single label for 1 aspect, or <code>\"\u00d7\"</code>-joined).</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.vertex_layers","title":"<code>vertex_layers(u)</code>","text":"<p>List all layer-tuples where vertex <code>u</code> is present.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, ...]]</code> <p>Layer tuples where <code>(u, aa)</code> is in <code>V_M</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.has_presence","title":"<code>has_presence(u, aa)</code>","text":"<p>Check whether <code>(u, aa)</code> is in <code>V_M</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_aspect_attrs","title":"<code>set_aspect_attrs(aspect, **attrs)</code>","text":"<p>Attach metadata to an aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.aspect_attrs","title":"<code>aspect_attrs(aspect)</code>","text":"<p>Get metadata dict for an aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_layer_attrs","title":"<code>set_layer_attrs(aa, **attrs)</code>","text":"<p>Attach metadata to a Kivela layer (aspect tuple).</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.layer_attrs","title":"<code>layer_attrs(aa)</code>","text":"<p>Get metadata dict for a Kivela layer (aspect tuple).</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_vertex_layer_attrs","title":"<code>set_vertex_layer_attrs(u, aa, **attrs)</code>","text":"<p>Attach metadata to a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.vertex_layer_attrs","title":"<code>vertex_layer_attrs(u, aa)</code>","text":"<p>Get metadata dict for a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.elem_layer_id","title":"<code>elem_layer_id(aspect, label)</code>","text":"<p>Canonical <code>\"{aspect}_{label}\"</code> id used in <code>layer_attributes</code>.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <p>Returns:</p> Type Description <code>str</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_elem_layer_attrs","title":"<code>set_elem_layer_attrs(aspect, label, **attrs)</code>","text":"<p>Upsert attributes for an elementary layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.elem_layer_attrs","title":"<code>elem_layer_attrs(aspect, label)</code>","text":"<p>Read attributes for an elementary layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.vertex_set","title":"<code>vertex_set(aa)</code>","text":"<p>Vertices present in a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.edge_set","title":"<code>edge_set(aa, include_inter=False, include_coupling=False)</code>","text":"<p>Edges associated with a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>aa</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>aa</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.union","title":"<code>union(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Set-union over Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.intersection","title":"<code>intersection(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Set-intersection over Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.difference","title":"<code>difference(layer_a, layer_b, include_inter=False, include_coupling=False)</code>","text":"<p>Set-difference over two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.to_slice","title":"<code>to_slice(aa, slice_id=None, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from a single Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier. Defaults to the canonical layer id.</p> <code>None</code> <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>aa</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>aa</code>.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p> <p>Examples:</p> <pre><code>G.layers.to_slice((\"t1\", \"F\"), slice_id=\"t1_F\")\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.union_to_slice","title":"<code>union_to_slice(layer_tuples, slice_id, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.intersection_to_slice","title":"<code>intersection_to_slice(layer_tuples, slice_id, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.difference_to_slice","title":"<code>difference_to_slice(layer_a, layer_b, slice_id, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from a set-difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph","title":"<code>subgraph(aa, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by a single layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>aa</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>aa</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph_union","title":"<code>subgraph_union(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Subgraph induced by the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph_intersection","title":"<code>subgraph_intersection(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Subgraph induced by the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph_difference","title":"<code>subgraph_difference(layer_a, layer_b, include_inter=False, include_coupling=False)</code>","text":"<p>Subgraph induced by a set-difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.intra_edges_tuple","title":"<code>intra_edges_tuple(aa)</code>","text":"<p>Edge IDs of intra edges inside a layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.inter_edges_between","title":"<code>inter_edges_between(aa, bb)</code>","text":"<p>Edge IDs of inter edges between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple A.</p> required <code>bb</code> <code>Iterable[str]</code> <p>Layer tuple B.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.coupling_edges_between","title":"<code>coupling_edges_between(aa, bb)</code>","text":"<p>Edge IDs of coupling edges between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple A.</p> required <code>bb</code> <code>Iterable[str]</code> <p>Layer tuple B.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.supra_adjacency","title":"<code>supra_adjacency(layers=None)</code>","text":"<p>Proxy to full supra adjacency over selected layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Layer subset. In single-aspect mode, string IDs are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.blocks","title":"<code>blocks(layers=None)</code>","text":"<p>Return supra block matrices.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Layer subset. In single-aspect mode, string IDs are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"intra\": A_intra, \"inter\": A_inter, \"coupling\": A_coupling}</code>.</p>"},{"location":"reference/annnet_layers/#layer-mixin","title":"Layer Mixin","text":"Internal helpers <p>Manager for Kivela multi-layer operations.</p> <p>Provides organized namespace for layer operations by delegating to AnnNet methods. All heavy lifting is done by the AnnNet class; this is just a clean API surface.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass","title":"<code>annnet.core._Layers.LayerClass</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass-functions","title":"Functions","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_aspects","title":"<code>set_aspects(aspects, elem_layers)</code>","text":"<p>Define multi-aspect structure.</p> <p>Parameters:</p> Name Type Description Default <code>aspects</code> <code>list[str]</code> <p>Aspect identifiers (e.g., <code>[\"time\", \"relation\"]</code>).</p> required <code>elem_layers</code> <code>dict[str, list[str]]</code> <p>Elementary labels per aspect (e.g., <code>{\"time\": [\"t1\",\"t2\"]}</code>).</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>aspects</code> is empty.</p> <p>Examples:</p> <pre><code>G.set_aspects([\"time\", \"relation\"], {\"time\": [\"t1\", \"t2\"], \"relation\": [\"F\", \"A\"]})\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._rebuild_all_layers_cache","title":"<code>_rebuild_all_layers_cache()</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_presence","title":"<code>add_presence(u, layer_tuple)</code>","text":"<p>Declare that a vertex is present in a layer tuple.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>u</code> is not a vertex.</p> <code>ValueError</code> <p>If <code>layer_tuple</code> is invalid for the configured aspects.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.remove_presence","title":"<code>remove_presence(u, layer_tuple)</code>","text":"<p>Remove presence <code>(u, aa)</code> if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>layer_tuple</code> is invalid for the configured aspects.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.has_presence","title":"<code>has_presence(u, layer_tuple)</code>","text":"<p>Check whether <code>(u, aa)</code> is in <code>V_M</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.iter_layers","title":"<code>iter_layers()</code>","text":"<p>Iterate over all aspect-tuples (Cartesian product).</p> <p>Yields:</p> Type Description <code>tuple[str, ...]</code> <p>Layer tuples in configured order.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.iter_vertex_layers","title":"<code>iter_vertex_layers(u)</code>","text":"<p>Iterate layer tuples where <code>(u, aa)</code> is in <code>V_M</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <p>Yields:</p> Type Description <code>tuple[str, ...]</code> <p>Layer tuples for <code>u</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.ensure_vertex_layer_index","title":"<code>ensure_vertex_layer_index(restrict_layers=None)</code>","text":"<p>Build stable mapping between vertex\u2013layer tuples and row indices.</p> <p>Parameters:</p> Name Type Description Default <code>restrict_layers</code> <code>list[tuple[str, ...]] | None</code> <p>If provided, index only these layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of indexed vertex\u2013layer pairs.</p> Notes <p>Ordering is lexicographic by vertex id, then by layer tuple.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.nl_to_row","title":"<code>nl_to_row(u, layer_tuple)</code>","text":"<p>Map <code>(u, aa)</code> to row index.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex\u2013layer pair is not indexed.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.row_to_nl","title":"<code>row_to_nl(row)</code>","text":"<p>Map row index to <code>(u, aa)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>Row index.</p> required <p>Returns:</p> Type Description <code>tuple[str, tuple[str, ...]]</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the row is not indexed.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._validate_layer_tuple","title":"<code>_validate_layer_tuple(aa)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_id_to_tuple","title":"<code>layer_id_to_tuple(layer_id)</code>","text":"<p>Map legacy string layer id to aspect tuple.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier (single-aspect only).</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If not in single-aspect mode.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._layer_id_to_tuple_cached","title":"<code>_layer_id_to_tuple_cached(layer)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_tuple_to_id","title":"<code>layer_tuple_to_id(aa)</code>","text":"<p>Canonical string id for a layer tuple.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Canonical id (single label for 1 aspect, or <code>\"\u00d7\"</code>-joined).</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._elem_layer_id","title":"<code>_elem_layer_id(aspect, label)</code>","text":"<p>Canonical id for an elementary Kivela layer (aspect, label).</p> <p>This is the key used in <code>layer_attributes.layer_id</code>:     layer_id = \"{aspect}_{label}\"</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._upsert_layer_attribute_row","title":"<code>_upsert_layer_attribute_row(layer_id, attrs)</code>","text":"<p>Upsert a row in <code>self.layer_attributes</code> for <code>layer_id</code>.</p> <p>Strategy (simple &amp; robust):   - convert current DF to list[dict]   - find existing row for this layer_id (if any)   - merge attrs into that row (override keys)   - rebuild DataFrame from the updated list of rows</p> <p>This avoids all schema/dtype headaches (Polars infers them).</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_elementary_layer_attrs","title":"<code>set_elementary_layer_attrs(aspect, label, **attrs)</code>","text":"<p>Attach attributes to an elementary Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_elementary_layer_attrs","title":"<code>get_elementary_layer_attrs(aspect, label)</code>","text":"<p>Get attributes for an elementary Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Attributes dict; empty if not set.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_aspect_attrs","title":"<code>set_aspect_attrs(aspect, **attrs)</code>","text":"<p>Attach metadata to a Kivela aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_aspect_attrs","title":"<code>get_aspect_attrs(aspect)</code>","text":"<p>Return a shallow copy of metadata for a Kivela aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_layer_attrs","title":"<code>set_layer_attrs(layer_tuple, **attrs)</code>","text":"<p>Attach metadata to a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_layer_attrs","title":"<code>get_layer_attrs(layer_tuple)</code>","text":"<p>Get metadata dict for a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Shallow copy; empty if not set.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_vertex_layer_attrs","title":"<code>set_vertex_layer_attrs(u, layer_tuple, **attrs)</code>","text":"<p>Attach metadata to a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>(u, layer_tuple)</code> is not present in <code>V_M</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_vertex_layer_attrs","title":"<code>get_vertex_layer_attrs(u, layer_tuple)</code>","text":"<p>Get metadata dict for a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Shallow copy; empty if not set.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._layer_tuple_to_lid","title":"<code>_layer_tuple_to_lid(aa)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_edge_kivela_role","title":"<code>set_edge_kivela_role(eid, role, layers)</code>","text":"<p>Annotate an existing structural edge with Kivela semantics.</p> <p>Parameters:</p> Name Type Description Default <code>eid</code> <code>str</code> <p>Edge identifier.</p> required <code>role</code> <code>str</code> <p>One of <code>\"intra\"</code>, <code>\"inter\"</code>, or <code>\"coupling\"</code>.</p> required <code>layers</code> <code>tuple | list</code> <p><code>aa</code> for <code>\"intra\"</code>; <code>(aa, bb)</code> for <code>\"inter\"</code>/<code>\"coupling\"</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>eid</code> does not exist.</p> <code>ValueError</code> <p>If <code>role</code> is invalid.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_intra_edge","title":"<code>add_intra_edge(u, v, layer, *, weight=1.0, eid=None)</code>","text":"<p>Add an intra-layer edge in legacy single-aspect mode.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Source vertex.</p> required <code>v</code> <code>str</code> <p>Target vertex.</p> required <code>layer</code> <code>str</code> <p>Layer id (single-aspect only).</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_intra_edge_nl","title":"<code>add_intra_edge_nl(u, v, layer_tuple, *, weight=1.0, eid=None)</code>","text":"<p>Add an intra-layer edge for a multi-aspect layer.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Source vertex.</p> required <code>v</code> <code>str</code> <p>Target vertex.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer <code>aa</code>.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required vertex\u2013layer presence is missing.</p> <code>ValueError</code> <p>If <code>layer_tuple</code> is invalid.</p> <p>Examples:</p> <pre><code>G.add_intra_edge_nl(\"u1\", \"u2\", (\"t1\", \"F\"))\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_intra_edges_bulk","title":"<code>add_intra_edges_bulk(edges, layer_tuple, weight=1.0, fast_mode=True)</code>","text":"<p>Bulk add intra-layer edges with direct matrix updates.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable</code> <p><code>[(u, v), ...]</code> or <code>[(u, v, w), ...]</code>.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <code>weight</code> <code>float</code> <p>Default weight when <code>w</code> is not provided.</p> <code>1.0</code> <code>fast_mode</code> <code>bool</code> <p>If True, skip validation/presence checks.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge ids added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_inter_edge_nl","title":"<code>add_inter_edge_nl(u, layer_a, v, layer_b, *, weight=1.0, eid=None)</code>","text":"<p>Add an inter-layer edge between two layer tuples.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex in layer <code>aa</code>.</p> required <code>layer_a</code> <code>tuple[str, ...]</code> <p>Source layer tuple.</p> required <code>v</code> <code>str</code> <p>Vertex in layer <code>bb</code>.</p> required <code>layer_b</code> <code>tuple[str, ...]</code> <p>Target layer tuple.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required vertex\u2013layer presence is missing.</p> <code>ValueError</code> <p>If layer tuples are invalid.</p> <p>Examples:</p> <pre><code>G.add_inter_edge_nl(\"u1\", (\"t1\",), \"u2\", (\"t2\",))\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_coupling_edge_nl","title":"<code>add_coupling_edge_nl(u, layer_a, layer_b, *, weight=1.0, eid=None)</code>","text":"<p>Add a diagonal coupling edge between two layers for the same vertex.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_a</code> <code>tuple[str, ...]</code> <p>Layer tuple A.</p> required <code>layer_b</code> <code>tuple[str, ...]</code> <p>Layer tuple B.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_vertex_set","title":"<code>layer_vertex_set(layer_tuple)</code>","text":"<p>Vertices present in a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>Iterable[str]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_edge_set","title":"<code>layer_edge_set(layer_tuple, *, include_inter=False, include_coupling=False)</code>","text":"<p>Edges associated with a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>Iterable[str]</code> <p>Aspect tuple layer.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_tuple</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_inter_edge","title":"<code>add_inter_edge(u, v, layer_a, layer_b, *, weight=1.0, eid=None)</code>","text":"<p>Add an inter-layer edge in legacy single-aspect mode.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Source vertex.</p> required <code>v</code> <code>str</code> <p>Target vertex.</p> required <code>layer_a</code> <code>str</code> <p>Layer id (single-aspect only).</p> required <code>layer_b</code> <code>str</code> <p>Layer id (single-aspect only).</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_union","title":"<code>layer_union(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Union of several Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_intersection","title":"<code>layer_intersection(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Intersection of several Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_difference","title":"<code>layer_difference(layer_a, layer_b, *, include_inter=False, include_coupling=False)</code>","text":"<p>Set difference: elements in <code>layer_a</code> but not in <code>layer_b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer","title":"<code>create_slice_from_layer(slice_id, layer_tuple, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice induced by a single Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_tuple</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p> <p>Examples:</p> <pre><code>G.create_slice_from_layer(\"t1_F\", (\"t1\", \"F\"))\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer_union","title":"<code>create_slice_from_layer_union(slice_id, layer_tuples, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice as the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer_intersection","title":"<code>create_slice_from_layer_intersection(slice_id, layer_tuples, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice as the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer_difference","title":"<code>create_slice_from_layer_difference(slice_id, layer_a, layer_b, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice as the difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_tuple","title":"<code>subgraph_from_layer_tuple(layer_tuple, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by a single Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_tuple</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_union","title":"<code>subgraph_from_layer_union(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_intersection","title":"<code>subgraph_from_layer_intersection(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_difference","title":"<code>subgraph_from_layer_difference(layer_a, layer_b, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by a set-difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._assert_presence","title":"<code>_assert_presence(u, aa)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_adjacency","title":"<code>supra_adjacency(layers=None)</code>","text":"<p>Build the supra adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers. In single-aspect mode, string ids are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>Supra adjacency over the chosen vertex\u2013layer index.</p> <p>Examples:</p> <pre><code>A = G.supra_adjacency()\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._normalize_layers_arg","title":"<code>_normalize_layers_arg(layers)</code>","text":"<p>Normalize <code>layers</code> argument to aspect tuples or None.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._build_block","title":"<code>_build_block(include_kinds, layers=None)</code>","text":"<p>Internal builder for supra block matrices.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.build_intra_block","title":"<code>build_intra_block(layers=None)</code>","text":"<p>Supra matrix containing only intra-layer edges (diagonal blocks).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.build_inter_block","title":"<code>build_inter_block(layers=None)</code>","text":"<p>Supra matrix containing only inter-layer (non-diagonal) edges.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.build_coupling_block","title":"<code>build_coupling_block(layers=None)</code>","text":"<p>Supra matrix containing only coupling edges.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_degree","title":"<code>supra_degree(layers=None)</code>","text":"<p>Degree vector over the supra-graph.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_laplacian","title":"<code>supra_laplacian(kind='comb', layers=None)</code>","text":"<p>Build supra-Laplacian.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p><code>\"comb\"</code> for combinatorial <code>L = D - A</code> or <code>\"norm\"</code> for normalized <code>L = I - D^{-1/2} A D^{-1/2}</code>.</p> <code>'comb'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._aspect_index","title":"<code>_aspect_index(aspect)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._layer_matches_filter","title":"<code>_layer_matches_filter(aa, layer_filter)</code>","text":"<p>layer_filter: {aspect_name: {elem1, elem2, ...}}; a layer matches if aa[a] \u2208 set for all keys.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_layer_coupling_pairs","title":"<code>add_layer_coupling_pairs(layer_pairs, *, weight=1.0)</code>","text":"<p>Add diagonal couplings for explicit layer pairs.</p> <p>Parameters:</p> Name Type Description Default <code>layer_pairs</code> <code>list[tuple[tuple[str, ...], tuple[str, ...]]]</code> <p>Layer tuple pairs <code>(aa, bb)</code>.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_categorical_coupling","title":"<code>add_categorical_coupling(aspect, groups, *, weight=1.0)</code>","text":"<p>Add categorical couplings along one aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect name to couple over.</p> required <code>groups</code> <code>list[list[str]]</code> <p>Groups of elementary labels to fully connect per vertex.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_diagonal_coupling_filter","title":"<code>add_diagonal_coupling_filter(layer_filter, *, weight=1.0)</code>","text":"<p>Add diagonal couplings within a filtered layer subspace.</p> <p>Parameters:</p> Name Type Description Default <code>layer_filter</code> <code>dict[str, set]</code> <p>Aspect filters (e.g., <code>{\"time\": {\"t1\",\"t2\"}}</code>).</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.tensor_index","title":"<code>tensor_index(layers=None)</code>","text":"<p>Build indices for tensor view.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p><code>(vertices, layers_t, vertex_to_i, layer_to_i)</code>.</p> <p>Examples:</p> <pre><code>vertices, layers_t, v2i, l2i = G.tensor_index()\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.adjacency_tensor_view","title":"<code>adjacency_tensor_view(layers=None)</code>","text":"<p>Sparse 4-index adjacency view.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\",\"layers\",\"vertex_to_i\",\"layer_to_i\",\"ui\",\"ai\",\"vi\",\"bi\",\"w\"}</code>.</p> Notes <p>Symmetric entries are emitted twice: <code>(ui, ai, vi, bi)</code> and <code>(vi, bi, ui, ai)</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.flatten_to_supra","title":"<code>flatten_to_supra(tensor_view)</code>","text":"<p>Flatten a tensor view into a supra adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>tensor_view</code> <code>dict</code> <p>Output of :meth:<code>adjacency_tensor_view</code> or :meth:<code>unflatten_from_supra</code>.</p> required <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.unflatten_from_supra","title":"<code>unflatten_from_supra(A, layers=None)</code>","text":"<p>Unflatten a supra adjacency matrix into a tensor view.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>spmatrix</code> <p>Supra adjacency matrix.</p> required <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Tensor view with the same schema as :meth:<code>adjacency_tensor_view</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_adjacency_scaled","title":"<code>supra_adjacency_scaled(*, coupling_scale=1.0, include_inter=True, layers=None)</code>","text":"<p>Build scaled supra adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>coupling_scale</code> <code>float</code> <p>Scaling factor for coupling edges.</p> <code>1.0</code> <code>include_inter</code> <code>bool</code> <p>Whether to include inter-layer edges.</p> <code>True</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.transition_matrix","title":"<code>transition_matrix(layers=None)</code>","text":"<p>Row-stochastic transition matrix <code>P = D^{-1} A</code>.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.random_walk_step","title":"<code>random_walk_step(p, layers=None)</code>","text":"<p>One random-walk step <code>p' = p P</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array - like</code> <p>Row vector of length <code>|V_M|</code>.</p> required <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.diffusion_step","title":"<code>diffusion_step(x, tau=1.0, kind='comb', layers=None)</code>","text":"<p>One explicit Euler step of diffusion on the supra-graph.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>State vector of length <code>|V_M|</code>.</p> required <code>tau</code> <code>float</code> <p>Time step.</p> <code>1.0</code> <code>kind</code> <code>str</code> <p><code>\"comb\"</code> or <code>\"norm\"</code>.</p> <code>'comb'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.algebraic_connectivity","title":"<code>algebraic_connectivity(layers=None)</code>","text":"<p>Algebraic connectivity of the supra-graph.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[float, ndarray | None]</code> <p><code>(lambda_2, fiedler_vector)</code> or <code>(0.0, None)</code> if too small.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.k_smallest_laplacian_eigs","title":"<code>k_smallest_laplacian_eigs(k=6, kind='comb', layers=None)</code>","text":"<p>Return k smallest eigenvalues/eigenvectors of the supra-Laplacian.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of eigenpairs to compute.</p> <code>6</code> <code>kind</code> <code>str</code> <p><code>\"comb\"</code> or <code>\"norm\"</code>.</p> <code>'comb'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p><code>(eigenvalues, eigenvectors)</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.dominant_rw_eigenpair","title":"<code>dominant_rw_eigenpair(layers=None)</code>","text":"<p>Dominant eigenpair of the random-walk operator.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[float, ndarray | None]</code> <p><code>(lambda_max, v)</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.sweep_coupling_regime","title":"<code>sweep_coupling_regime(scales, metric='algebraic_connectivity', layers=None)</code>","text":"<p>Scan coupling scales and evaluate a metric.</p> <p>Parameters:</p> Name Type Description Default <code>scales</code> <code>Iterable[float]</code> <p>Coupling scales to evaluate.</p> required <code>metric</code> <code>str | callable</code> <p><code>\"algebraic_connectivity\"</code> or a callable <code>metric(A)-&gt;float</code>.</p> <code>'algebraic_connectivity'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Metric values aligned with <code>scales</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._rows_for_layer","title":"<code>_rows_for_layer(L)</code>","text":"<p>Return row indices in the supra index that belong to aspect-tuple layer L.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_degree_vectors","title":"<code>layer_degree_vectors(layers=None)</code>","text":"<p>Per-layer degree vectors (intra-layer only).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{layer_tuple: (rows_idx_list, deg_vector_np)}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.participation_coefficient","title":"<code>participation_coefficient(layers=None)</code>","text":"<p>Participation coefficient per vertex.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, float]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.versatility","title":"<code>versatility(layers=None)</code>","text":"<p>Versatility proxy based on dominant eigenvector of supra adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, float]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.multislice_modularity","title":"<code>multislice_modularity(partition, *, gamma=1.0, omega=1.0, include_inter=False, layers=None)</code>","text":"<p>Mucha et al. multislice modularity (scorer only).</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>array - like</code> <p>Community ids, length <code>|V_M|</code> in the current index.</p> required <code>gamma</code> <code>float</code> <p>Resolution parameter.</p> <code>1.0</code> <code>omega</code> <code>float</code> <p>Coupling strength (binary coupling structure scaled by <code>omega</code>).</p> <code>1.0</code> <code>include_inter</code> <code>bool</code> <p>Whether to include inter-layer (non-diagonal) edges.</p> <code>False</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers to score on.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Modularity score <code>Q</code>.</p> <p>Examples:</p> <pre><code>Q = G.multislice_modularity(partition)\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager-functions","title":"Functions","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.aspects","title":"<code>aspects()</code>","text":"<p>List aspect names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Aspect identifiers in configured order.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.elementary_layers","title":"<code>elementary_layers()</code>","text":"<p>Return elementary layer labels per aspect.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of aspect name to list of elementary labels.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.layer_tuples","title":"<code>layer_tuples()</code>","text":"<p>List all aspect-tuples (Cartesian product).</p> <p>Returns:</p> Type Description <code>list[tuple[str, ...]]</code> <p>All layer tuples in configured order.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.tuple_id","title":"<code>tuple_id(aa)</code>","text":"<p>Canonical string id for a layer tuple.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Aspect-tuple layer (e.g., <code>(\"t1\",\"F\")</code>).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Canonical id (single label for 1 aspect, or <code>\"\u00d7\"</code>-joined).</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.vertex_layers","title":"<code>vertex_layers(u)</code>","text":"<p>List all layer-tuples where vertex <code>u</code> is present.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, ...]]</code> <p>Layer tuples where <code>(u, aa)</code> is in <code>V_M</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.has_presence","title":"<code>has_presence(u, aa)</code>","text":"<p>Check whether <code>(u, aa)</code> is in <code>V_M</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_aspect_attrs","title":"<code>set_aspect_attrs(aspect, **attrs)</code>","text":"<p>Attach metadata to an aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.aspect_attrs","title":"<code>aspect_attrs(aspect)</code>","text":"<p>Get metadata dict for an aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_layer_attrs","title":"<code>set_layer_attrs(aa, **attrs)</code>","text":"<p>Attach metadata to a Kivela layer (aspect tuple).</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.layer_attrs","title":"<code>layer_attrs(aa)</code>","text":"<p>Get metadata dict for a Kivela layer (aspect tuple).</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_vertex_layer_attrs","title":"<code>set_vertex_layer_attrs(u, aa, **attrs)</code>","text":"<p>Attach metadata to a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.vertex_layer_attrs","title":"<code>vertex_layer_attrs(u, aa)</code>","text":"<p>Get metadata dict for a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.elem_layer_id","title":"<code>elem_layer_id(aspect, label)</code>","text":"<p>Canonical <code>\"{aspect}_{label}\"</code> id used in <code>layer_attributes</code>.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <p>Returns:</p> Type Description <code>str</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.set_elem_layer_attrs","title":"<code>set_elem_layer_attrs(aspect, label, **attrs)</code>","text":"<p>Upsert attributes for an elementary layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.elem_layer_attrs","title":"<code>elem_layer_attrs(aspect, label)</code>","text":"<p>Read attributes for an elementary layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.vertex_set","title":"<code>vertex_set(aa)</code>","text":"<p>Vertices present in a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.edge_set","title":"<code>edge_set(aa, include_inter=False, include_coupling=False)</code>","text":"<p>Edges associated with a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>aa</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>aa</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.union","title":"<code>union(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Set-union over Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.intersection","title":"<code>intersection(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Set-intersection over Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.difference","title":"<code>difference(layer_a, layer_b, include_inter=False, include_coupling=False)</code>","text":"<p>Set-difference over two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.to_slice","title":"<code>to_slice(aa, slice_id=None, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from a single Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier. Defaults to the canonical layer id.</p> <code>None</code> <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>aa</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>aa</code>.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p> <p>Examples:</p> <pre><code>G.layers.to_slice((\"t1\", \"F\"), slice_id=\"t1_F\")\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.union_to_slice","title":"<code>union_to_slice(layer_tuples, slice_id, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.intersection_to_slice","title":"<code>intersection_to_slice(layer_tuples, slice_id, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.difference_to_slice","title":"<code>difference_to_slice(layer_a, layer_b, slice_id, include_inter=False, include_coupling=False, **attrs)</code>","text":"<p>Create a slice from a set-difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <code>**attrs</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph","title":"<code>subgraph(aa, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by a single layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>aa</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>aa</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph_union","title":"<code>subgraph_union(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Subgraph induced by the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph_intersection","title":"<code>subgraph_intersection(layer_tuples, include_inter=False, include_coupling=False)</code>","text":"<p>Subgraph induced by the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.subgraph_difference","title":"<code>subgraph_difference(layer_a, layer_b, include_inter=False, include_coupling=False)</code>","text":"<p>Subgraph induced by a set-difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.intra_edges_tuple","title":"<code>intra_edges_tuple(aa)</code>","text":"<p>Edge IDs of intra edges inside a layer.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.inter_edges_between","title":"<code>inter_edges_between(aa, bb)</code>","text":"<p>Edge IDs of inter edges between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple A.</p> required <code>bb</code> <code>Iterable[str]</code> <p>Layer tuple B.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.coupling_edges_between","title":"<code>coupling_edges_between(aa, bb)</code>","text":"<p>Edge IDs of coupling edges between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>Iterable[str]</code> <p>Layer tuple A.</p> required <code>bb</code> <code>Iterable[str]</code> <p>Layer tuple B.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.supra_adjacency","title":"<code>supra_adjacency(layers=None)</code>","text":"<p>Proxy to full supra adjacency over selected layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Layer subset. In single-aspect mode, string IDs are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerManager.blocks","title":"<code>blocks(layers=None)</code>","text":"<p>Return supra block matrices.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Layer subset. In single-aspect mode, string IDs are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"intra\": A_intra, \"inter\": A_inter, \"coupling\": A_coupling}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass-functions","title":"Functions","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_aspects","title":"<code>set_aspects(aspects, elem_layers)</code>","text":"<p>Define multi-aspect structure.</p> <p>Parameters:</p> Name Type Description Default <code>aspects</code> <code>list[str]</code> <p>Aspect identifiers (e.g., <code>[\"time\", \"relation\"]</code>).</p> required <code>elem_layers</code> <code>dict[str, list[str]]</code> <p>Elementary labels per aspect (e.g., <code>{\"time\": [\"t1\",\"t2\"]}</code>).</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>aspects</code> is empty.</p> <p>Examples:</p> <pre><code>G.set_aspects([\"time\", \"relation\"], {\"time\": [\"t1\", \"t2\"], \"relation\": [\"F\", \"A\"]})\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._rebuild_all_layers_cache","title":"<code>_rebuild_all_layers_cache()</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_presence","title":"<code>add_presence(u, layer_tuple)</code>","text":"<p>Declare that a vertex is present in a layer tuple.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>u</code> is not a vertex.</p> <code>ValueError</code> <p>If <code>layer_tuple</code> is invalid for the configured aspects.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.remove_presence","title":"<code>remove_presence(u, layer_tuple)</code>","text":"<p>Remove presence <code>(u, aa)</code> if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>layer_tuple</code> is invalid for the configured aspects.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.has_presence","title":"<code>has_presence(u, layer_tuple)</code>","text":"<p>Check whether <code>(u, aa)</code> is in <code>V_M</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.iter_layers","title":"<code>iter_layers()</code>","text":"<p>Iterate over all aspect-tuples (Cartesian product).</p> <p>Yields:</p> Type Description <code>tuple[str, ...]</code> <p>Layer tuples in configured order.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.iter_vertex_layers","title":"<code>iter_vertex_layers(u)</code>","text":"<p>Iterate layer tuples where <code>(u, aa)</code> is in <code>V_M</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <p>Yields:</p> Type Description <code>tuple[str, ...]</code> <p>Layer tuples for <code>u</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.ensure_vertex_layer_index","title":"<code>ensure_vertex_layer_index(restrict_layers=None)</code>","text":"<p>Build stable mapping between vertex\u2013layer tuples and row indices.</p> <p>Parameters:</p> Name Type Description Default <code>restrict_layers</code> <code>list[tuple[str, ...]] | None</code> <p>If provided, index only these layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of indexed vertex\u2013layer pairs.</p> Notes <p>Ordering is lexicographic by vertex id, then by layer tuple.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.nl_to_row","title":"<code>nl_to_row(u, layer_tuple)</code>","text":"<p>Map <code>(u, aa)</code> to row index.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex\u2013layer pair is not indexed.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.row_to_nl","title":"<code>row_to_nl(row)</code>","text":"<p>Map row index to <code>(u, aa)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>Row index.</p> required <p>Returns:</p> Type Description <code>tuple[str, tuple[str, ...]]</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the row is not indexed.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._validate_layer_tuple","title":"<code>_validate_layer_tuple(aa)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_id_to_tuple","title":"<code>layer_id_to_tuple(layer_id)</code>","text":"<p>Map legacy string layer id to aspect tuple.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier (single-aspect only).</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If not in single-aspect mode.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._layer_id_to_tuple_cached","title":"<code>_layer_id_to_tuple_cached(layer)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_tuple_to_id","title":"<code>layer_tuple_to_id(aa)</code>","text":"<p>Canonical string id for a layer tuple.</p> <p>Parameters:</p> Name Type Description Default <code>aa</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Canonical id (single label for 1 aspect, or <code>\"\u00d7\"</code>-joined).</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._elem_layer_id","title":"<code>_elem_layer_id(aspect, label)</code>","text":"<p>Canonical id for an elementary Kivela layer (aspect, label).</p> <p>This is the key used in <code>layer_attributes.layer_id</code>:     layer_id = \"{aspect}_{label}\"</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._upsert_layer_attribute_row","title":"<code>_upsert_layer_attribute_row(layer_id, attrs)</code>","text":"<p>Upsert a row in <code>self.layer_attributes</code> for <code>layer_id</code>.</p> <p>Strategy (simple &amp; robust):   - convert current DF to list[dict]   - find existing row for this layer_id (if any)   - merge attrs into that row (override keys)   - rebuild DataFrame from the updated list of rows</p> <p>This avoids all schema/dtype headaches (Polars infers them).</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_elementary_layer_attrs","title":"<code>set_elementary_layer_attrs(aspect, label, **attrs)</code>","text":"<p>Attach attributes to an elementary Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_elementary_layer_attrs","title":"<code>get_elementary_layer_attrs(aspect, label)</code>","text":"<p>Get attributes for an elementary Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>label</code> <code>str</code> <p>Elementary layer label.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Attributes dict; empty if not set.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_aspect_attrs","title":"<code>set_aspect_attrs(aspect, **attrs)</code>","text":"<p>Attach metadata to a Kivela aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_aspect_attrs","title":"<code>get_aspect_attrs(aspect)</code>","text":"<p>Return a shallow copy of metadata for a Kivela aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect identifier.</p> required <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_layer_attrs","title":"<code>set_layer_attrs(layer_tuple, **attrs)</code>","text":"<p>Attach metadata to a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_layer_attrs","title":"<code>get_layer_attrs(layer_tuple)</code>","text":"<p>Get metadata dict for a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Shallow copy; empty if not set.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_vertex_layer_attrs","title":"<code>set_vertex_layer_attrs(u, layer_tuple, **attrs)</code>","text":"<p>Attach metadata to a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <code>**attrs</code> <p>Key-value metadata to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>(u, layer_tuple)</code> is not present in <code>V_M</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.get_vertex_layer_attrs","title":"<code>get_vertex_layer_attrs(u, layer_tuple)</code>","text":"<p>Get metadata dict for a vertex\u2013layer pair.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Shallow copy; empty if not set.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._layer_tuple_to_lid","title":"<code>_layer_tuple_to_lid(aa)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.set_edge_kivela_role","title":"<code>set_edge_kivela_role(eid, role, layers)</code>","text":"<p>Annotate an existing structural edge with Kivela semantics.</p> <p>Parameters:</p> Name Type Description Default <code>eid</code> <code>str</code> <p>Edge identifier.</p> required <code>role</code> <code>str</code> <p>One of <code>\"intra\"</code>, <code>\"inter\"</code>, or <code>\"coupling\"</code>.</p> required <code>layers</code> <code>tuple | list</code> <p><code>aa</code> for <code>\"intra\"</code>; <code>(aa, bb)</code> for <code>\"inter\"</code>/<code>\"coupling\"</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>eid</code> does not exist.</p> <code>ValueError</code> <p>If <code>role</code> is invalid.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_intra_edge","title":"<code>add_intra_edge(u, v, layer, *, weight=1.0, eid=None)</code>","text":"<p>Add an intra-layer edge in legacy single-aspect mode.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Source vertex.</p> required <code>v</code> <code>str</code> <p>Target vertex.</p> required <code>layer</code> <code>str</code> <p>Layer id (single-aspect only).</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_intra_edge_nl","title":"<code>add_intra_edge_nl(u, v, layer_tuple, *, weight=1.0, eid=None)</code>","text":"<p>Add an intra-layer edge for a multi-aspect layer.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Source vertex.</p> required <code>v</code> <code>str</code> <p>Target vertex.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer <code>aa</code>.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required vertex\u2013layer presence is missing.</p> <code>ValueError</code> <p>If <code>layer_tuple</code> is invalid.</p> <p>Examples:</p> <pre><code>G.add_intra_edge_nl(\"u1\", \"u2\", (\"t1\", \"F\"))\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_intra_edges_bulk","title":"<code>add_intra_edges_bulk(edges, layer_tuple, weight=1.0, fast_mode=True)</code>","text":"<p>Bulk add intra-layer edges with direct matrix updates.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable</code> <p><code>[(u, v), ...]</code> or <code>[(u, v, w), ...]</code>.</p> required <code>layer_tuple</code> <code>tuple[str, ...]</code> <p>Aspect tuple layer.</p> required <code>weight</code> <code>float</code> <p>Default weight when <code>w</code> is not provided.</p> <code>1.0</code> <code>fast_mode</code> <code>bool</code> <p>If True, skip validation/presence checks.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge ids added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_inter_edge_nl","title":"<code>add_inter_edge_nl(u, layer_a, v, layer_b, *, weight=1.0, eid=None)</code>","text":"<p>Add an inter-layer edge between two layer tuples.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex in layer <code>aa</code>.</p> required <code>layer_a</code> <code>tuple[str, ...]</code> <p>Source layer tuple.</p> required <code>v</code> <code>str</code> <p>Vertex in layer <code>bb</code>.</p> required <code>layer_b</code> <code>tuple[str, ...]</code> <p>Target layer tuple.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required vertex\u2013layer presence is missing.</p> <code>ValueError</code> <p>If layer tuples are invalid.</p> <p>Examples:</p> <pre><code>G.add_inter_edge_nl(\"u1\", (\"t1\",), \"u2\", (\"t2\",))\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_coupling_edge_nl","title":"<code>add_coupling_edge_nl(u, layer_a, layer_b, *, weight=1.0, eid=None)</code>","text":"<p>Add a diagonal coupling edge between two layers for the same vertex.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Vertex identifier.</p> required <code>layer_a</code> <code>tuple[str, ...]</code> <p>Layer tuple A.</p> required <code>layer_b</code> <code>tuple[str, ...]</code> <p>Layer tuple B.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_vertex_set","title":"<code>layer_vertex_set(layer_tuple)</code>","text":"<p>Vertices present in a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>Iterable[str]</code> <p>Aspect tuple layer.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_edge_set","title":"<code>layer_edge_set(layer_tuple, *, include_inter=False, include_coupling=False)</code>","text":"<p>Edges associated with a Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>Iterable[str]</code> <p>Aspect tuple layer.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_tuple</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_inter_edge","title":"<code>add_inter_edge(u, v, layer_a, layer_b, *, weight=1.0, eid=None)</code>","text":"<p>Add an inter-layer edge in legacy single-aspect mode.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Source vertex.</p> required <code>v</code> <code>str</code> <p>Target vertex.</p> required <code>layer_a</code> <code>str</code> <p>Layer id (single-aspect only).</p> required <code>layer_b</code> <code>str</code> <p>Layer id (single-aspect only).</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>eid</code> <code>str | None</code> <p>Edge id override.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Edge id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_union","title":"<code>layer_union(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Union of several Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_intersection","title":"<code>layer_intersection(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Intersection of several Kivela layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_difference","title":"<code>layer_difference(layer_a, layer_b, *, include_inter=False, include_coupling=False)</code>","text":"<p>Set difference: elements in <code>layer_a</code> but not in <code>layer_b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer","title":"<code>create_slice_from_layer(slice_id, layer_tuple, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice induced by a single Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_tuple</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p> <p>Examples:</p> <pre><code>G.create_slice_from_layer(\"t1_F\", (\"t1\", \"F\"))\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer_union","title":"<code>create_slice_from_layer_union(slice_id, layer_tuples, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice as the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer_intersection","title":"<code>create_slice_from_layer_intersection(slice_id, layer_tuples, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice as the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.create_slice_from_layer_difference","title":"<code>create_slice_from_layer_difference(slice_id, layer_a, layer_b, *, include_inter=False, include_coupling=False, **attributes)</code>","text":"<p>Create a slice as the difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice id.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_tuple","title":"<code>subgraph_from_layer_tuple(layer_tuple, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by a single Kivela layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuple</code> <code>Iterable[str]</code> <p>Layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_tuple</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_tuple</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_union","title":"<code>subgraph_from_layer_union(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by the union of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to union.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the union.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the union.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_intersection","title":"<code>subgraph_from_layer_intersection(layer_tuples, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by the intersection of several layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_tuples</code> <code>Iterable[Iterable[str]]</code> <p>Layer tuples to intersect.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching any layer in the intersection.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching any layer in the intersection.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.subgraph_from_layer_difference","title":"<code>subgraph_from_layer_difference(layer_a, layer_b, *, include_inter=False, include_coupling=False)</code>","text":"<p>Concrete subgraph induced by a set-difference of two layers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_a</code> <code>Iterable[str]</code> <p>Minuend layer tuple.</p> required <code>layer_b</code> <code>Iterable[str]</code> <p>Subtrahend layer tuple.</p> required <code>include_inter</code> <code>bool</code> <p>Include inter-layer edges touching <code>layer_a</code>.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>Include coupling edges touching <code>layer_a</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._assert_presence","title":"<code>_assert_presence(u, aa)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_adjacency","title":"<code>supra_adjacency(layers=None)</code>","text":"<p>Build the supra adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers. In single-aspect mode, string ids are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>Supra adjacency over the chosen vertex\u2013layer index.</p> <p>Examples:</p> <pre><code>A = G.supra_adjacency()\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._normalize_layers_arg","title":"<code>_normalize_layers_arg(layers)</code>","text":"<p>Normalize <code>layers</code> argument to aspect tuples or None.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._build_block","title":"<code>_build_block(include_kinds, layers=None)</code>","text":"<p>Internal builder for supra block matrices.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.build_intra_block","title":"<code>build_intra_block(layers=None)</code>","text":"<p>Supra matrix containing only intra-layer edges (diagonal blocks).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.build_inter_block","title":"<code>build_inter_block(layers=None)</code>","text":"<p>Supra matrix containing only inter-layer (non-diagonal) edges.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.build_coupling_block","title":"<code>build_coupling_block(layers=None)</code>","text":"<p>Supra matrix containing only coupling edges.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_degree","title":"<code>supra_degree(layers=None)</code>","text":"<p>Degree vector over the supra-graph.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_laplacian","title":"<code>supra_laplacian(kind='comb', layers=None)</code>","text":"<p>Build supra-Laplacian.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p><code>\"comb\"</code> for combinatorial <code>L = D - A</code> or <code>\"norm\"</code> for normalized <code>L = I - D^{-1/2} A D^{-1/2}</code>.</p> <code>'comb'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._aspect_index","title":"<code>_aspect_index(aspect)</code>","text":""},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._layer_matches_filter","title":"<code>_layer_matches_filter(aa, layer_filter)</code>","text":"<p>layer_filter: {aspect_name: {elem1, elem2, ...}}; a layer matches if aa[a] \u2208 set for all keys.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_layer_coupling_pairs","title":"<code>add_layer_coupling_pairs(layer_pairs, *, weight=1.0)</code>","text":"<p>Add diagonal couplings for explicit layer pairs.</p> <p>Parameters:</p> Name Type Description Default <code>layer_pairs</code> <code>list[tuple[tuple[str, ...], tuple[str, ...]]]</code> <p>Layer tuple pairs <code>(aa, bb)</code>.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_categorical_coupling","title":"<code>add_categorical_coupling(aspect, groups, *, weight=1.0)</code>","text":"<p>Add categorical couplings along one aspect.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>str</code> <p>Aspect name to couple over.</p> required <code>groups</code> <code>list[list[str]]</code> <p>Groups of elementary labels to fully connect per vertex.</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.add_diagonal_coupling_filter","title":"<code>add_diagonal_coupling_filter(layer_filter, *, weight=1.0)</code>","text":"<p>Add diagonal couplings within a filtered layer subspace.</p> <p>Parameters:</p> Name Type Description Default <code>layer_filter</code> <code>dict[str, set]</code> <p>Aspect filters (e.g., <code>{\"time\": {\"t1\",\"t2\"}}</code>).</p> required <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges added.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.tensor_index","title":"<code>tensor_index(layers=None)</code>","text":"<p>Build indices for tensor view.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p><code>(vertices, layers_t, vertex_to_i, layer_to_i)</code>.</p> <p>Examples:</p> <pre><code>vertices, layers_t, v2i, l2i = G.tensor_index()\n</code></pre>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.adjacency_tensor_view","title":"<code>adjacency_tensor_view(layers=None)</code>","text":"<p>Sparse 4-index adjacency view.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\",\"layers\",\"vertex_to_i\",\"layer_to_i\",\"ui\",\"ai\",\"vi\",\"bi\",\"w\"}</code>.</p> Notes <p>Symmetric entries are emitted twice: <code>(ui, ai, vi, bi)</code> and <code>(vi, bi, ui, ai)</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.flatten_to_supra","title":"<code>flatten_to_supra(tensor_view)</code>","text":"<p>Flatten a tensor view into a supra adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>tensor_view</code> <code>dict</code> <p>Output of :meth:<code>adjacency_tensor_view</code> or :meth:<code>unflatten_from_supra</code>.</p> required <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.unflatten_from_supra","title":"<code>unflatten_from_supra(A, layers=None)</code>","text":"<p>Unflatten a supra adjacency matrix into a tensor view.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>spmatrix</code> <p>Supra adjacency matrix.</p> required <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Tensor view with the same schema as :meth:<code>adjacency_tensor_view</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.supra_adjacency_scaled","title":"<code>supra_adjacency_scaled(*, coupling_scale=1.0, include_inter=True, layers=None)</code>","text":"<p>Build scaled supra adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>coupling_scale</code> <code>float</code> <p>Scaling factor for coupling edges.</p> <code>1.0</code> <code>include_inter</code> <code>bool</code> <p>Whether to include inter-layer edges.</p> <code>True</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.transition_matrix","title":"<code>transition_matrix(layers=None)</code>","text":"<p>Row-stochastic transition matrix <code>P = D^{-1} A</code>.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>csr_matrix</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.random_walk_step","title":"<code>random_walk_step(p, layers=None)</code>","text":"<p>One random-walk step <code>p' = p P</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array - like</code> <p>Row vector of length <code>|V_M|</code>.</p> required <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.diffusion_step","title":"<code>diffusion_step(x, tau=1.0, kind='comb', layers=None)</code>","text":"<p>One explicit Euler step of diffusion on the supra-graph.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>State vector of length <code>|V_M|</code>.</p> required <code>tau</code> <code>float</code> <p>Time step.</p> <code>1.0</code> <code>kind</code> <code>str</code> <p><code>\"comb\"</code> or <code>\"norm\"</code>.</p> <code>'comb'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.algebraic_connectivity","title":"<code>algebraic_connectivity(layers=None)</code>","text":"<p>Algebraic connectivity of the supra-graph.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[float, ndarray | None]</code> <p><code>(lambda_2, fiedler_vector)</code> or <code>(0.0, None)</code> if too small.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.k_smallest_laplacian_eigs","title":"<code>k_smallest_laplacian_eigs(k=6, kind='comb', layers=None)</code>","text":"<p>Return k smallest eigenvalues/eigenvectors of the supra-Laplacian.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of eigenpairs to compute.</p> <code>6</code> <code>kind</code> <code>str</code> <p><code>\"comb\"</code> or <code>\"norm\"</code>.</p> <code>'comb'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p><code>(eigenvalues, eigenvectors)</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.dominant_rw_eigenpair","title":"<code>dominant_rw_eigenpair(layers=None)</code>","text":"<p>Dominant eigenpair of the random-walk operator.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[float, ndarray | None]</code> <p><code>(lambda_max, v)</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.sweep_coupling_regime","title":"<code>sweep_coupling_regime(scales, metric='algebraic_connectivity', layers=None)</code>","text":"<p>Scan coupling scales and evaluate a metric.</p> <p>Parameters:</p> Name Type Description Default <code>scales</code> <code>Iterable[float]</code> <p>Coupling scales to evaluate.</p> required <code>metric</code> <code>str | callable</code> <p><code>\"algebraic_connectivity\"</code> or a callable <code>metric(A)-&gt;float</code>.</p> <code>'algebraic_connectivity'</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Metric values aligned with <code>scales</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass._rows_for_layer","title":"<code>_rows_for_layer(L)</code>","text":"<p>Return row indices in the supra index that belong to aspect-tuple layer L.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.layer_degree_vectors","title":"<code>layer_degree_vectors(layers=None)</code>","text":"<p>Per-layer degree vectors (intra-layer only).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{layer_tuple: (rows_idx_list, deg_vector_np)}</code>.</p>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.participation_coefficient","title":"<code>participation_coefficient(layers=None)</code>","text":"<p>Participation coefficient per vertex.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, float]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.versatility","title":"<code>versatility(layers=None)</code>","text":"<p>Versatility proxy based on dominant eigenvector of supra adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, float]</code>"},{"location":"reference/annnet_layers/#annnet.core._Layers.LayerClass.multislice_modularity","title":"<code>multislice_modularity(partition, *, gamma=1.0, omega=1.0, include_inter=False, layers=None)</code>","text":"<p>Mucha et al. multislice modularity (scorer only).</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>array - like</code> <p>Community ids, length <code>|V_M|</code> in the current index.</p> required <code>gamma</code> <code>float</code> <p>Resolution parameter.</p> <code>1.0</code> <code>omega</code> <code>float</code> <p>Coupling strength (binary coupling structure scaled by <code>omega</code>).</p> <code>1.0</code> <code>include_inter</code> <code>bool</code> <p>Whether to include inter-layer (non-diagonal) edges.</p> <code>False</code> <code>layers</code> <code>list[str] | list[tuple[str, ...]] | None</code> <p>Optional subset of layers to score on.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Modularity score <code>Q</code>.</p> <p>Examples:</p> <pre><code>Q = G.multislice_modularity(partition)\n</code></pre>"},{"location":"reference/annnet_slices/","title":"Slices","text":"<p>Slices represent subgraphs with their own membership and attributes. This page covers both the manager API and the mixin used by <code>AnnNet</code>.</p>"},{"location":"reference/annnet_slices/#slice-manager","title":"Slice Manager","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager","title":"<code>annnet.core._Slices.SliceManager</code>","text":"<p>Manager for graph slice operations.</p> <p>Provides organized namespace for slice operations by delegating to AnnNet methods. All heavy lifting is done by the AnnNet class; this is just a clean API surface.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.active","title":"<code>active</code>  <code>property</code> <code>writable</code>","text":"<p>Get active slice ID.</p> <p>Returns:</p> Type Description <code>str</code> Notes <p>Delegates to <code>AnnNet.get_active_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager-functions","title":"Functions","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.add","title":"<code>add(slice_id, **attributes)</code>","text":"<p>Create new slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Delegates to <code>AnnNet.add_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.remove","title":"<code>remove(slice_id)</code>","text":"<p>Remove slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required Notes <p>Delegates to <code>AnnNet.remove_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.list","title":"<code>list(include_default=False)</code>","text":"<p>List slice IDs.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal default slice if True.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> Notes <p>Delegates to <code>AnnNet.list_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.exists","title":"<code>exists(slice_id)</code>","text":"<p>Check if slice exists.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> Notes <p>Delegates to <code>AnnNet.has_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.info","title":"<code>info(slice_id)</code>","text":"<p>Get slice metadata.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>dict</code> Notes <p>Delegates to <code>AnnNet.get_slice_info()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.count","title":"<code>count()</code>","text":"<p>Get number of slices.</p> <p>Returns:</p> Type Description <code>int</code> Notes <p>Delegates to <code>AnnNet.slice_count()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.vertices","title":"<code>vertices(slice_id)</code>","text":"<p>Get vertices in slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> Notes <p>Delegates to <code>AnnNet.get_slice_vertices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.edges","title":"<code>edges(slice_id)</code>","text":"<p>Get edges in slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> Notes <p>Delegates to <code>AnnNet.get_slice_edges()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.union","title":"<code>union(slice_ids)</code>","text":"<p>Compute union of slices (returns dict, doesn't create slice).</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to union.</p> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p> Notes <p>Delegates to <code>AnnNet.slice_union()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.intersect","title":"<code>intersect(slice_ids)</code>","text":"<p>Compute intersection of slices (returns dict, doesn't create slice).</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to intersect.</p> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p> Notes <p>Delegates to <code>AnnNet.slice_intersection()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.difference","title":"<code>difference(slice_a, slice_b)</code>","text":"<p>Compute set difference (returns dict, doesn't create slice).</p> <p>Parameters:</p> Name Type Description Default <code>slice_a</code> <code>str</code> <p>First slice.</p> required <code>slice_b</code> <code>str</code> <p>Second slice.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Elements in <code>slice_a</code> but not in <code>slice_b</code>.</p> Notes <p>Delegates to <code>AnnNet.slice_difference()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.union_create","title":"<code>union_create(slice_ids, name, **attributes)</code>","text":"<p>Create new slice as union of existing slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to union.</p> required <code>name</code> <code>str</code> <p>New slice name.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Combines <code>AnnNet.slice_union()</code> with <code>AnnNet.create_slice_from_operation()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.intersect_create","title":"<code>intersect_create(slice_ids, name, **attributes)</code>","text":"<p>Create new slice as intersection of existing slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to intersect.</p> required <code>name</code> <code>str</code> <p>New slice name.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Combines <code>AnnNet.slice_intersection()</code> with <code>AnnNet.create_slice_from_operation()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.difference_create","title":"<code>difference_create(slice_a, slice_b, name, **attributes)</code>","text":"<p>Create new slice as difference of two slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_a</code> <code>str</code> <p>First slice.</p> required <code>slice_b</code> <code>str</code> <p>Second slice.</p> required <code>name</code> <code>str</code> <p>New slice name.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Combines <code>AnnNet.slice_difference()</code> with <code>AnnNet.create_slice_from_operation()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.aggregate","title":"<code>aggregate(source_slice_ids, target_slice_id, method='union', weight_func=None, **attributes)</code>","text":"<p>Create aggregated slice from multiple sources.</p> <p>Parameters:</p> Name Type Description Default <code>source_slice_ids</code> <code>list[str]</code> <p>Source slices.</p> required <code>target_slice_id</code> <code>str</code> <p>Target slice name.</p> required <code>method</code> <code>(union, intersection)</code> <p>Aggregation method.</p> <code>'union'</code> <code>weight_func</code> <code>callable</code> <p>Weight merging function (reserved).</p> <code>None</code> <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Delegates to <code>AnnNet.create_aggregated_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.stats","title":"<code>stats(include_default=False)</code>","text":"<p>Get statistics for all slices.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of slice ID to stats.</p> Notes <p>Delegates to <code>AnnNet.slice_statistics()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.vertex_presence","title":"<code>vertex_presence(vertex_id, include_default=False)</code>","text":"<p>Find slices containing a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex to search for.</p> required <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> Notes <p>Delegates to <code>AnnNet.vertex_presence_across_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.edge_presence","title":"<code>edge_presence(edge_id=None, source=None, target=None, include_default=False, undirected_match=None)</code>","text":"<p>Find slices containing an edge.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge ID to search for.</p> <code>None</code> <code>source</code> <code>str</code> <p>Source vertex (with target).</p> <code>None</code> <code>target</code> <code>str</code> <p>Target vertex (with source).</p> <code>None</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <code>undirected_match</code> <code>bool</code> <p>Allow symmetric matches.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str] | dict[str, list[str]]</code> <p>If <code>edge_id</code>: list of slice IDs. If <code>source</code>/<code>target</code>: mapping of slice IDs to matching edge IDs.</p> Notes <p>Delegates to <code>AnnNet.edge_presence_across_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.hyperedge_presence","title":"<code>hyperedge_presence(members=None, head=None, tail=None, include_default=False)</code>","text":"<p>Find slices containing a hyperedge.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected hyperedge members.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed hyperedge head.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed hyperedge tail.</p> <code>None</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of slice ID to edge IDs.</p> Notes <p>Delegates to <code>AnnNet.hyperedge_presence_across_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.conserved_edges","title":"<code>conserved_edges(min_slices=2, include_default=False)</code>","text":"<p>Find edges present in multiple slices.</p> <p>Parameters:</p> Name Type Description Default <code>min_slices</code> <code>int</code> <p>Minimum number of slices.</p> <code>2</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Mapping of edge ID to slice count.</p> Notes <p>Delegates to <code>AnnNet.conserved_edges()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.specific_edges","title":"<code>specific_edges(slice_id)</code>","text":"<p>Find edges unique to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Edge IDs unique to this slice.</p> Notes <p>Delegates to <code>AnnNet.slice_specific_edges()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.temporal_dynamics","title":"<code>temporal_dynamics(ordered_slices, metric='edge_change')</code>","text":"<p>Analyze temporal changes across slices.</p> <p>Parameters:</p> Name Type Description Default <code>ordered_slices</code> <code>list[str]</code> <p>Slice IDs in chronological order.</p> required <code>metric</code> <code>(edge_change, vertex_change)</code> <p>What to track.</p> <code>'edge_change'</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Per-step changes with keys <code>added</code>, <code>removed</code>, <code>net_change</code>.</p> Notes <p>Delegates to <code>AnnNet.temporal_dynamics()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.summary","title":"<code>summary()</code>","text":"<p>Get human-readable summary of all slices.</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted summary.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.__repr__","title":"<code>__repr__()</code>","text":""},{"location":"reference/annnet_slices/#slice-mixin","title":"Slice Mixin","text":"Internal helpers <p>Manager for graph slice operations.</p> <p>Provides organized namespace for slice operations by delegating to AnnNet methods. All heavy lifting is done by the AnnNet class; this is just a clean API surface.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass","title":"<code>annnet.core._Slices.SliceClass</code>","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass-functions","title":"Functions","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.add_slice","title":"<code>add_slice(slice_id, **attributes)</code>","text":"<p>Create a new empty slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>New slice identifier.</p> required <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the slice already exists.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.set_active_slice","title":"<code>set_active_slice(slice_id)</code>","text":"<p>Set the active slice for subsequent operations.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Existing slice ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_active_slice","title":"<code>get_active_slice()</code>","text":"<p>Get the currently active slice ID.</p> <p>Returns:</p> Type Description <code>str</code> <p>Active slice ID.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slices_dict","title":"<code>get_slices_dict(include_default=False)</code>","text":"<p>Get a mapping of slice IDs to their metadata.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal <code>default</code> slice if True.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of slice IDs to metadata dicts.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.list_slices","title":"<code>list_slices(include_default=False)</code>","text":"<p>List slice IDs.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal <code>default</code> slice if True.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Slice IDs.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.has_slice","title":"<code>has_slice(slice_id)</code>","text":"<p>Check whether a slice exists.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_count","title":"<code>slice_count()</code>","text":"<p>Get the number of slices (including the internal default).</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slice_info","title":"<code>get_slice_info(slice_id)</code>","text":"<p>Get a slice's metadata snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Copy of <code>{\"vertices\": set, \"edges\": set, \"attributes\": dict}</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slice_vertices","title":"<code>get_slice_vertices(slice_id)</code>","text":"<p>Vertices in a slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slice_edges","title":"<code>get_slice_edges(slice_id)</code>","text":"<p>Edges in a slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_union","title":"<code>slice_union(slice_ids)</code>","text":"<p>Union of multiple slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>Iterable[str]</code> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_intersection","title":"<code>slice_intersection(slice_ids)</code>","text":"<p>Intersection of multiple slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>Iterable[str]</code> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_difference","title":"<code>slice_difference(slice1_id, slice2_id)</code>","text":"<p>Set difference: elements in <code>slice1_id</code> not in <code>slice2_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>slice1_id</code> <code>str</code> required <code>slice2_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either slice is missing.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.create_slice_from_operation","title":"<code>create_slice_from_operation(result_slice_id, operation_result, **attributes)</code>","text":"<p>Create a new slice from the result of a set operation.</p> <p>Parameters:</p> Name Type Description Default <code>result_slice_id</code> <code>str</code> <p>New slice identifier.</p> required <code>operation_result</code> <code>dict</code> <p>Output of <code>slice_union</code>/<code>slice_intersection</code>/<code>slice_difference</code>.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the target slice already exists.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.add_vertex_to_slice","title":"<code>add_vertex_to_slice(lid, vid)</code>","text":"<p>Attach an existing vertex to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice identifier.</p> required <code>vid</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.edge_presence_across_slices","title":"<code>edge_presence_across_slices(edge_id=None, source=None, target=None, *, include_default=False, undirected_match=None)</code>","text":"<p>Locate where an edge exists across slices.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>If provided, match by ID (any kind: binary/vertex-edge/hyper).</p> <code>None</code> <code>source</code> <code>str</code> <p>When used with <code>target</code>, match binary/vertex-edge edges by endpoints.</p> <code>None</code> <code>target</code> <code>str</code> <code>None</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice in the search.</p> <code>False</code> <code>undirected_match</code> <code>bool</code> <p>When endpoint matching, allow undirected symmetric matches.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str] | dict[str, list[str]]</code> <p>If <code>edge_id</code> is given: list of slice IDs. Otherwise mapping of slice IDs to matching edge IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both modes (ID and endpoints) are provided or neither is valid.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.hyperedge_presence_across_slices","title":"<code>hyperedge_presence_across_slices(*, members=None, head=None, tail=None, include_default=False)</code>","text":"<p>Locate slices containing a hyperedge with exactly these sets.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected member set (exact match).</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (exact match).</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (exact match).</p> <code>None</code> <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of slice IDs to matching edge IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>For invalid combinations or empty sets.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.vertex_presence_across_slices","title":"<code>vertex_presence_across_slices(vertex_id, include_default=False)</code>","text":"<p>List slices containing a specific vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.conserved_edges","title":"<code>conserved_edges(min_slices=2, include_default=False)</code>","text":"<p>Edges present in at least <code>min_slices</code> slices.</p> <p>Parameters:</p> Name Type Description Default <code>min_slices</code> <code>int</code> <code>2</code> <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Mapping of edge ID to slice count.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_specific_edges","title":"<code>slice_specific_edges(slice_id)</code>","text":"<p>Edges that appear only in the specified slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.temporal_dynamics","title":"<code>temporal_dynamics(ordered_slices, metric='edge_change')</code>","text":"<p>Compute changes between consecutive slices in a temporal sequence.</p> <p>Parameters:</p> Name Type Description Default <code>ordered_slices</code> <code>list[str]</code> <p>Slice IDs in chronological order.</p> required <code>metric</code> <code>(edge_change, vertex_change)</code> <code>'edge_change'</code> <p>Returns:</p> Type Description <code>list[dict[str, int]]</code> <p>Per-step dictionaries with keys <code>added</code>, <code>removed</code>, <code>net_change</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two slices are provided.</p> <code>KeyError</code> <p>If a referenced slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.create_aggregated_slice","title":"<code>create_aggregated_slice(source_slice_ids, target_slice_id, method='union', weight_func=None, **attributes)</code>","text":"<p>Create a new slice by aggregating multiple source slices.</p> <p>Parameters:</p> Name Type Description Default <code>source_slice_ids</code> <code>list[str]</code> required <code>target_slice_id</code> <code>str</code> required <code>method</code> <code>(union, intersection)</code> <code>'union'</code> <code>weight_func</code> <code>callable</code> <p>Reserved for future weight merging logic (currently unused).</p> <code>None</code> <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>For unknown methods or missing source slices, or if target exists.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_statistics","title":"<code>slice_statistics(include_default=False)</code>","text":"<p>Basic per-slice statistics.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of slice ID to stats.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager-attributes","title":"Attributes","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager._G","title":"<code>_G = graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.active","title":"<code>active</code>  <code>property</code> <code>writable</code>","text":"<p>Get active slice ID.</p> <p>Returns:</p> Type Description <code>str</code> Notes <p>Delegates to <code>AnnNet.get_active_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager-functions","title":"Functions","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.add","title":"<code>add(slice_id, **attributes)</code>","text":"<p>Create new slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Delegates to <code>AnnNet.add_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.remove","title":"<code>remove(slice_id)</code>","text":"<p>Remove slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required Notes <p>Delegates to <code>AnnNet.remove_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.list","title":"<code>list(include_default=False)</code>","text":"<p>List slice IDs.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal default slice if True.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> Notes <p>Delegates to <code>AnnNet.list_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.exists","title":"<code>exists(slice_id)</code>","text":"<p>Check if slice exists.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> Notes <p>Delegates to <code>AnnNet.has_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.info","title":"<code>info(slice_id)</code>","text":"<p>Get slice metadata.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>dict</code> Notes <p>Delegates to <code>AnnNet.get_slice_info()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.count","title":"<code>count()</code>","text":"<p>Get number of slices.</p> <p>Returns:</p> Type Description <code>int</code> Notes <p>Delegates to <code>AnnNet.slice_count()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.vertices","title":"<code>vertices(slice_id)</code>","text":"<p>Get vertices in slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> Notes <p>Delegates to <code>AnnNet.get_slice_vertices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.edges","title":"<code>edges(slice_id)</code>","text":"<p>Get edges in slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> Notes <p>Delegates to <code>AnnNet.get_slice_edges()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.union","title":"<code>union(slice_ids)</code>","text":"<p>Compute union of slices (returns dict, doesn't create slice).</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to union.</p> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p> Notes <p>Delegates to <code>AnnNet.slice_union()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.intersect","title":"<code>intersect(slice_ids)</code>","text":"<p>Compute intersection of slices (returns dict, doesn't create slice).</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to intersect.</p> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p> Notes <p>Delegates to <code>AnnNet.slice_intersection()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.difference","title":"<code>difference(slice_a, slice_b)</code>","text":"<p>Compute set difference (returns dict, doesn't create slice).</p> <p>Parameters:</p> Name Type Description Default <code>slice_a</code> <code>str</code> <p>First slice.</p> required <code>slice_b</code> <code>str</code> <p>Second slice.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Elements in <code>slice_a</code> but not in <code>slice_b</code>.</p> Notes <p>Delegates to <code>AnnNet.slice_difference()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.union_create","title":"<code>union_create(slice_ids, name, **attributes)</code>","text":"<p>Create new slice as union of existing slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to union.</p> required <code>name</code> <code>str</code> <p>New slice name.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Combines <code>AnnNet.slice_union()</code> with <code>AnnNet.create_slice_from_operation()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.intersect_create","title":"<code>intersect_create(slice_ids, name, **attributes)</code>","text":"<p>Create new slice as intersection of existing slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>list[str]</code> <p>Slices to intersect.</p> required <code>name</code> <code>str</code> <p>New slice name.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Combines <code>AnnNet.slice_intersection()</code> with <code>AnnNet.create_slice_from_operation()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.difference_create","title":"<code>difference_create(slice_a, slice_b, name, **attributes)</code>","text":"<p>Create new slice as difference of two slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_a</code> <code>str</code> <p>First slice.</p> required <code>slice_b</code> <code>str</code> <p>Second slice.</p> required <code>name</code> <code>str</code> <p>New slice name.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Combines <code>AnnNet.slice_difference()</code> with <code>AnnNet.create_slice_from_operation()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.aggregate","title":"<code>aggregate(source_slice_ids, target_slice_id, method='union', weight_func=None, **attributes)</code>","text":"<p>Create aggregated slice from multiple sources.</p> <p>Parameters:</p> Name Type Description Default <code>source_slice_ids</code> <code>list[str]</code> <p>Source slices.</p> required <code>target_slice_id</code> <code>str</code> <p>Target slice name.</p> required <code>method</code> <code>(union, intersection)</code> <p>Aggregation method.</p> <code>'union'</code> <code>weight_func</code> <code>callable</code> <p>Weight merging function (reserved).</p> <code>None</code> <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Created slice ID.</p> Notes <p>Delegates to <code>AnnNet.create_aggregated_slice()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.stats","title":"<code>stats(include_default=False)</code>","text":"<p>Get statistics for all slices.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of slice ID to stats.</p> Notes <p>Delegates to <code>AnnNet.slice_statistics()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.vertex_presence","title":"<code>vertex_presence(vertex_id, include_default=False)</code>","text":"<p>Find slices containing a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex to search for.</p> required <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> Notes <p>Delegates to <code>AnnNet.vertex_presence_across_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.edge_presence","title":"<code>edge_presence(edge_id=None, source=None, target=None, include_default=False, undirected_match=None)</code>","text":"<p>Find slices containing an edge.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge ID to search for.</p> <code>None</code> <code>source</code> <code>str</code> <p>Source vertex (with target).</p> <code>None</code> <code>target</code> <code>str</code> <p>Target vertex (with source).</p> <code>None</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <code>undirected_match</code> <code>bool</code> <p>Allow symmetric matches.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str] | dict[str, list[str]]</code> <p>If <code>edge_id</code>: list of slice IDs. If <code>source</code>/<code>target</code>: mapping of slice IDs to matching edge IDs.</p> Notes <p>Delegates to <code>AnnNet.edge_presence_across_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.hyperedge_presence","title":"<code>hyperedge_presence(members=None, head=None, tail=None, include_default=False)</code>","text":"<p>Find slices containing a hyperedge.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected hyperedge members.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed hyperedge head.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed hyperedge tail.</p> <code>None</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of slice ID to edge IDs.</p> Notes <p>Delegates to <code>AnnNet.hyperedge_presence_across_slices()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.conserved_edges","title":"<code>conserved_edges(min_slices=2, include_default=False)</code>","text":"<p>Find edges present in multiple slices.</p> <p>Parameters:</p> Name Type Description Default <code>min_slices</code> <code>int</code> <p>Minimum number of slices.</p> <code>2</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Mapping of edge ID to slice count.</p> Notes <p>Delegates to <code>AnnNet.conserved_edges()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.specific_edges","title":"<code>specific_edges(slice_id)</code>","text":"<p>Find edges unique to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Edge IDs unique to this slice.</p> Notes <p>Delegates to <code>AnnNet.slice_specific_edges()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.temporal_dynamics","title":"<code>temporal_dynamics(ordered_slices, metric='edge_change')</code>","text":"<p>Analyze temporal changes across slices.</p> <p>Parameters:</p> Name Type Description Default <code>ordered_slices</code> <code>list[str]</code> <p>Slice IDs in chronological order.</p> required <code>metric</code> <code>(edge_change, vertex_change)</code> <p>What to track.</p> <code>'edge_change'</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Per-step changes with keys <code>added</code>, <code>removed</code>, <code>net_change</code>.</p> Notes <p>Delegates to <code>AnnNet.temporal_dynamics()</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.summary","title":"<code>summary()</code>","text":"<p>Get human-readable summary of all slices.</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted summary.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceManager.__repr__","title":"<code>__repr__()</code>","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass-functions","title":"Functions","text":""},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.add_slice","title":"<code>add_slice(slice_id, **attributes)</code>","text":"<p>Create a new empty slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>New slice identifier.</p> required <code>**attributes</code> <p>Slice attributes to store.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the slice already exists.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.set_active_slice","title":"<code>set_active_slice(slice_id)</code>","text":"<p>Set the active slice for subsequent operations.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Existing slice ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_active_slice","title":"<code>get_active_slice()</code>","text":"<p>Get the currently active slice ID.</p> <p>Returns:</p> Type Description <code>str</code> <p>Active slice ID.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slices_dict","title":"<code>get_slices_dict(include_default=False)</code>","text":"<p>Get a mapping of slice IDs to their metadata.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal <code>default</code> slice if True.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of slice IDs to metadata dicts.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.list_slices","title":"<code>list_slices(include_default=False)</code>","text":"<p>List slice IDs.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <p>Include the internal <code>default</code> slice if True.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Slice IDs.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.has_slice","title":"<code>has_slice(slice_id)</code>","text":"<p>Check whether a slice exists.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_count","title":"<code>slice_count()</code>","text":"<p>Get the number of slices (including the internal default).</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slice_info","title":"<code>get_slice_info(slice_id)</code>","text":"<p>Get a slice's metadata snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Copy of <code>{\"vertices\": set, \"edges\": set, \"attributes\": dict}</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slice_vertices","title":"<code>get_slice_vertices(slice_id)</code>","text":"<p>Vertices in a slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.get_slice_edges","title":"<code>get_slice_edges(slice_id)</code>","text":"<p>Edges in a slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_union","title":"<code>slice_union(slice_ids)</code>","text":"<p>Union of multiple slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>Iterable[str]</code> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_intersection","title":"<code>slice_intersection(slice_ids)</code>","text":"<p>Intersection of multiple slices.</p> <p>Parameters:</p> Name Type Description Default <code>slice_ids</code> <code>Iterable[str]</code> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_difference","title":"<code>slice_difference(slice1_id, slice2_id)</code>","text":"<p>Set difference: elements in <code>slice1_id</code> not in <code>slice2_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>slice1_id</code> <code>str</code> required <code>slice2_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"vertices\": set[str], \"edges\": set[str]}</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either slice is missing.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.create_slice_from_operation","title":"<code>create_slice_from_operation(result_slice_id, operation_result, **attributes)</code>","text":"<p>Create a new slice from the result of a set operation.</p> <p>Parameters:</p> Name Type Description Default <code>result_slice_id</code> <code>str</code> <p>New slice identifier.</p> required <code>operation_result</code> <code>dict</code> <p>Output of <code>slice_union</code>/<code>slice_intersection</code>/<code>slice_difference</code>.</p> required <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the target slice already exists.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.add_vertex_to_slice","title":"<code>add_vertex_to_slice(lid, vid)</code>","text":"<p>Attach an existing vertex to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice identifier.</p> required <code>vid</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.edge_presence_across_slices","title":"<code>edge_presence_across_slices(edge_id=None, source=None, target=None, *, include_default=False, undirected_match=None)</code>","text":"<p>Locate where an edge exists across slices.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>If provided, match by ID (any kind: binary/vertex-edge/hyper).</p> <code>None</code> <code>source</code> <code>str</code> <p>When used with <code>target</code>, match binary/vertex-edge edges by endpoints.</p> <code>None</code> <code>target</code> <code>str</code> <code>None</code> <code>include_default</code> <code>bool</code> <p>Include the internal default slice in the search.</p> <code>False</code> <code>undirected_match</code> <code>bool</code> <p>When endpoint matching, allow undirected symmetric matches.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str] | dict[str, list[str]]</code> <p>If <code>edge_id</code> is given: list of slice IDs. Otherwise mapping of slice IDs to matching edge IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both modes (ID and endpoints) are provided or neither is valid.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.hyperedge_presence_across_slices","title":"<code>hyperedge_presence_across_slices(*, members=None, head=None, tail=None, include_default=False)</code>","text":"<p>Locate slices containing a hyperedge with exactly these sets.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected member set (exact match).</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (exact match).</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (exact match).</p> <code>None</code> <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of slice IDs to matching edge IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>For invalid combinations or empty sets.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.vertex_presence_across_slices","title":"<code>vertex_presence_across_slices(vertex_id, include_default=False)</code>","text":"<p>List slices containing a specific vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> required <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.conserved_edges","title":"<code>conserved_edges(min_slices=2, include_default=False)</code>","text":"<p>Edges present in at least <code>min_slices</code> slices.</p> <p>Parameters:</p> Name Type Description Default <code>min_slices</code> <code>int</code> <code>2</code> <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Mapping of edge ID to slice count.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_specific_edges","title":"<code>slice_specific_edges(slice_id)</code>","text":"<p>Edges that appear only in the specified slice.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.temporal_dynamics","title":"<code>temporal_dynamics(ordered_slices, metric='edge_change')</code>","text":"<p>Compute changes between consecutive slices in a temporal sequence.</p> <p>Parameters:</p> Name Type Description Default <code>ordered_slices</code> <code>list[str]</code> <p>Slice IDs in chronological order.</p> required <code>metric</code> <code>(edge_change, vertex_change)</code> <code>'edge_change'</code> <p>Returns:</p> Type Description <code>list[dict[str, int]]</code> <p>Per-step dictionaries with keys <code>added</code>, <code>removed</code>, <code>net_change</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two slices are provided.</p> <code>KeyError</code> <p>If a referenced slice does not exist.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.create_aggregated_slice","title":"<code>create_aggregated_slice(source_slice_ids, target_slice_id, method='union', weight_func=None, **attributes)</code>","text":"<p>Create a new slice by aggregating multiple source slices.</p> <p>Parameters:</p> Name Type Description Default <code>source_slice_ids</code> <code>list[str]</code> required <code>target_slice_id</code> <code>str</code> required <code>method</code> <code>(union, intersection)</code> <code>'union'</code> <code>weight_func</code> <code>callable</code> <p>Reserved for future weight merging logic (currently unused).</p> <code>None</code> <code>**attributes</code> <p>Slice attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The created slice ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>For unknown methods or missing source slices, or if target exists.</p>"},{"location":"reference/annnet_slices/#annnet.core._Slices.SliceClass.slice_statistics","title":"<code>slice_statistics(include_default=False)</code>","text":"<p>Basic per-slice statistics.</p> <p>Parameters:</p> Name Type Description Default <code>include_default</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of slice ID to stats.</p>"},{"location":"reference/api/","title":"API Reference (Moved)","text":"<p>This page has been replaced by the curated API Reference.</p> <ul> <li>Start here: API Overview</li> </ul>"},{"location":"reference/api_core/","title":"Core Graph (Moved)","text":"<p>This page has been replaced by the curated API Reference.</p> <ul> <li>AnnNet core: Core + Attributes</li> <li>API overview: API Overview</li> </ul>"},{"location":"reference/api_managers/","title":"Managers (Moved)","text":"<p>This page has been replaced by the curated API Reference.</p> <ul> <li>Slices: Slices</li> <li>Layers: Layers</li> <li>API overview: API Overview</li> </ul>"},{"location":"reference/api_mixins/","title":"Mixins (Moved)","text":"<p>This page has been replaced by the curated API Reference.</p> <ul> <li>Core + Attributes: Core + Attributes</li> <li>Slices: Slices</li> <li>Layers: Layers</li> <li>API overview: API Overview</li> </ul>"},{"location":"reference/interoperability/","title":"Interoperability","text":"<p>This section covers in-memory adapters and file-format IO used to exchange AnnNet graphs with external tools and formats.</p>"},{"location":"reference/interoperability/#in-memory-backends","title":"In-Memory Backends","text":""},{"location":"reference/interoperability/#networkx-optional","title":"NetworkX (optional)","text":"<p>The NetworkX adapter requires the <code>networkx</code> extra. Public entry points:</p> <ul> <li><code>to_nx(graph, ...)</code></li> <li><code>from_nx(G, ...)</code></li> <li><code>from_nx_only(G, ...)</code></li> <li><code>to_backend(graph, ...)</code></li> <li><code>save_manifest(manifest, path)</code></li> <li><code>load_manifest(path)</code></li> </ul> <p>See <code>annnet.adapters.networkx_adapter</code> in source for full details.</p>"},{"location":"reference/interoperability/#igraph-optional","title":"igraph (optional)","text":"Internal helpers"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter","title":"<code>annnet.adapters.igraph_adapter</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.IGraphAdapter","title":"<code>IGraphAdapter</code>","text":"<p>Legacy adapter class for backward compatibility.</p> <p>Methods:</p> Name Description <code>export</code> <p>Export AnnNet to igraph.AnnNet without manifest (lossy).</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.IGraphAdapter-functions","title":"Functions","text":"<code>export(graph, **kwargs)</code> <p>Export AnnNet to igraph.AnnNet without manifest.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>AnnNet</code> required <code>**kwargs</code> <p>See to_backend() for supported parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._endpoint_coeff_map","title":"<code>_endpoint_coeff_map(edge_attrs, private_key, endpoint_set)</code>","text":"<p>Return {vertex: float_coeff} for the given endpoint_set. Reads from edge_attrs[private_key], which may be serialized in multiple shapes. Missing endpoints default to 1.0.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._is_directed_eid","title":"<code>_is_directed_eid(graph, eid)</code>","text":"<p>Best-effort directedness probe; default True.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._collect_slices_and_weights","title":"<code>_collect_slices_and_weights(graph)</code>","text":"<p>Returns:   slices_section: {slice_id: [edge_id, ...]}   slice_weights:  {slice_id: {edge_id: weight}} Backends supported: Polars-like, .to_dicts()-like, dict.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_value","title":"<code>_serialize_value(v)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._attrs_to_dict","title":"<code>_attrs_to_dict(attrs_dict)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._rows","title":"<code>_rows(t)</code>","text":"<p>Backend-agnostic: convert a table-ish object to list[dict].</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._safe_df_to_rows","title":"<code>_safe_df_to_rows(df)</code>","text":"<p>Never crash if df is None or backend is missing.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._export_legacy","title":"<code>_export_legacy(graph, *, directed=True, skip_hyperedges=True, public_only=False)</code>","text":"<p>Export AnnNet to igraph.AnnNet without manifest.</p> <p>igraph requires integer vertex indices; external vertex IDs are preserved in vertex attribute 'name'. Edge IDs stored in edge attribute 'eid'.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>AnnNet</code> <p>Source graph instance.</p> required <code>directed</code> <code>bool</code> <p>If True, export as directed igraph.AnnNet; else undirected. Undirected edges in directed export are emitted bidirectionally.</p> <code>True</code> <code>skip_hyperedges</code> <code>bool</code> <p>If True, drop hyperedges. If False:   - directed hyperedges expand head\u00d7tail (cartesian product)   - undirected hyperedges expand to clique</p> <code>True</code> <code>public_only</code> <code>bool</code> <p>If True, strip private attrs starting with \"__\".</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._coeff_from_obj","title":"<code>_coeff_from_obj(obj)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.to_igraph","title":"<code>to_igraph(graph, directed=True, hyperedge_mode='skip', slice=None, slices=None, public_only=False, reify_prefix='he::')</code>","text":"<p>Export AnnNet \u2192 (igraph.AnnNet, manifest).</p> <p>hyperedge_mode: {\"skip\",\"expand\",\"reify\"}   - \"skip\": drop HE edges from igG (manifest keeps them)   - \"expand\": cartesian product (directed) / clique (undirected)   - \"reify\": add a node per HE and membership edges V\u2194HE carrying roles/coeffs</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.save_manifest","title":"<code>save_manifest(manifest, path)</code>","text":"<p>Write manifest to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>dict</code> <p>Manifest dictionary from to_igraph().</p> required <code>path</code> <code>str</code> <p>Output file path (typically .json extension).</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If file cannot be written.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.load_manifest","title":"<code>load_manifest(path)</code>","text":"<p>Load manifest from JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to manifest JSON file created by save_manifest().</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Manifest dictionary suitable for from_igraph().</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If file cannot be read.</p> <code>JSONDecodeError</code> <p>If file contains invalid JSON.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._ig_collect_reified","title":"<code>_ig_collect_reified(igG, he_node_flag='is_hyperedge', he_id_attr='eid', role_attr='role', coeff_attr='coeff', membership_attr='membership_of')</code>","text":"<p>Scan igG for reified hyperedges.</p> <p>Returns:   - hyperdefs: list of (eid, directed:bool, head_map:dict, tail_map:dict, he_node_attrs:dict, he_vertex_index)   - membership_edge_idx: set of edge indices that are membership edges (to skip for binary import)</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.from_igraph","title":"<code>from_igraph(igG, manifest, *, hyperedge='none', he_node_flag='is_hyperedge', he_id_attr='eid', reify_prefix='he::')</code>","text":"<p>Reconstruct a AnnNet from igraph.AnnNet + manifest.</p> <p>hyperedge: \"none\" (default) | \"reified\"   When \"reified\", also detect hyperedge nodes in igG and rebuild true hyperedges   that are NOT present in the manifest.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.to_backend","title":"<code>to_backend(graph, **kwargs)</code>","text":"<p>Export AnnNet to igraph without manifest (legacy compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>AnnNet</code> <p>Source AnnNet instance to export.</p> required <code>**kwargs</code> <p>Forwarded to _export_legacy(). Supported: - directed : bool, default True     Export as directed igraph.AnnNet (True) or undirected (False). - skip_hyperedges : bool, default True     If True, drop hyperedges. If False, expand them     (cartesian product for directed, clique for undirected). - public_only : bool, default False     Strip attributes starting with \"__\" if True.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>igraph.AnnNet with integer vertex indices. External vertex IDs are stored in vertex attribute 'name'. Edge IDs stored in edge attribute 'eid'. Hyperedges are either dropped or expanded into multiple binary edges. No manifest is returned, so round-tripping will lose hyperedge structure, slices, and precise edge IDs.</p> Notes <p>This is a lossy export. Use to_igraph() with manifest for full fidelity. igraph requires integer vertex indices internally; the 'name' attribute preserves your original string IDs.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.from_ig_only","title":"<code>from_ig_only(igG, *, hyperedge='none', he_node_flag='is_hyperedge', he_id_attr='eid', role_attr='role', coeff_attr='coeff', membership_attr='membership_of')</code>","text":"<p>Best-effort import from a plain igraph.AnnNet (no manifest). Preserves all vertex/edge attributes. hyperedge: \"none\" | \"reified\"   When \"reified\", rebuild true hyperedges and skip membership edges from binary import.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.IGraphAdapter","title":"<code>IGraphAdapter</code>","text":"<p>Legacy adapter class for backward compatibility.</p> <p>Methods:</p> Name Description <code>export</code> <p>Export AnnNet to igraph.AnnNet without manifest (lossy).</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._endpoint_coeff_map","title":"<code>_endpoint_coeff_map(edge_attrs, private_key, endpoint_set)</code>","text":"<p>Return {vertex: float_coeff} for the given endpoint_set. Reads from edge_attrs[private_key], which may be serialized in multiple shapes. Missing endpoints default to 1.0.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._is_directed_eid","title":"<code>_is_directed_eid(graph, eid)</code>","text":"<p>Best-effort directedness probe; default True.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._collect_slices_and_weights","title":"<code>_collect_slices_and_weights(graph)</code>","text":"<p>Returns:   slices_section: {slice_id: [edge_id, ...]}   slice_weights:  {slice_id: {edge_id: weight}} Backends supported: Polars-like, .to_dicts()-like, dict.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._serialize_value","title":"<code>_serialize_value(v)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._attrs_to_dict","title":"<code>_attrs_to_dict(attrs_dict)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._rows","title":"<code>_rows(t)</code>","text":"<p>Backend-agnostic: convert a table-ish object to list[dict].</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._safe_df_to_rows","title":"<code>_safe_df_to_rows(df)</code>","text":"<p>Never crash if df is None or backend is missing.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._export_legacy","title":"<code>_export_legacy(graph, *, directed=True, skip_hyperedges=True, public_only=False)</code>","text":"<p>Export AnnNet to igraph.AnnNet without manifest.</p> <p>igraph requires integer vertex indices; external vertex IDs are preserved in vertex attribute 'name'. Edge IDs stored in edge attribute 'eid'.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>AnnNet</code> <p>Source graph instance.</p> required <code>directed</code> <code>bool</code> <p>If True, export as directed igraph.AnnNet; else undirected. Undirected edges in directed export are emitted bidirectionally.</p> <code>True</code> <code>skip_hyperedges</code> <code>bool</code> <p>If True, drop hyperedges. If False:   - directed hyperedges expand head\u00d7tail (cartesian product)   - undirected hyperedges expand to clique</p> <code>True</code> <code>public_only</code> <code>bool</code> <p>If True, strip private attrs starting with \"__\".</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._coeff_from_obj","title":"<code>_coeff_from_obj(obj)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.to_igraph","title":"<code>to_igraph(graph, directed=True, hyperedge_mode='skip', slice=None, slices=None, public_only=False, reify_prefix='he::')</code>","text":"<p>Export AnnNet \u2192 (igraph.AnnNet, manifest).</p> <p>hyperedge_mode: {\"skip\",\"expand\",\"reify\"}   - \"skip\": drop HE edges from igG (manifest keeps them)   - \"expand\": cartesian product (directed) / clique (undirected)   - \"reify\": add a node per HE and membership edges V\u2194HE carrying roles/coeffs</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.save_manifest","title":"<code>save_manifest(manifest, path)</code>","text":"<p>Write manifest to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>dict</code> <p>Manifest dictionary from to_igraph().</p> required <code>path</code> <code>str</code> <p>Output file path (typically .json extension).</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If file cannot be written.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.load_manifest","title":"<code>load_manifest(path)</code>","text":"<p>Load manifest from JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to manifest JSON file created by save_manifest().</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Manifest dictionary suitable for from_igraph().</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If file cannot be read.</p> <code>JSONDecodeError</code> <p>If file contains invalid JSON.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter._ig_collect_reified","title":"<code>_ig_collect_reified(igG, he_node_flag='is_hyperedge', he_id_attr='eid', role_attr='role', coeff_attr='coeff', membership_attr='membership_of')</code>","text":"<p>Scan igG for reified hyperedges.</p> <p>Returns:   - hyperdefs: list of (eid, directed:bool, head_map:dict, tail_map:dict, he_node_attrs:dict, he_vertex_index)   - membership_edge_idx: set of edge indices that are membership edges (to skip for binary import)</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.from_igraph","title":"<code>from_igraph(igG, manifest, *, hyperedge='none', he_node_flag='is_hyperedge', he_id_attr='eid', reify_prefix='he::')</code>","text":"<p>Reconstruct a AnnNet from igraph.AnnNet + manifest.</p> <p>hyperedge: \"none\" (default) | \"reified\"   When \"reified\", also detect hyperedge nodes in igG and rebuild true hyperedges   that are NOT present in the manifest.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.to_backend","title":"<code>to_backend(graph, **kwargs)</code>","text":"<p>Export AnnNet to igraph without manifest (legacy compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>AnnNet</code> <p>Source AnnNet instance to export.</p> required <code>**kwargs</code> <p>Forwarded to _export_legacy(). Supported: - directed : bool, default True     Export as directed igraph.AnnNet (True) or undirected (False). - skip_hyperedges : bool, default True     If True, drop hyperedges. If False, expand them     (cartesian product for directed, clique for undirected). - public_only : bool, default False     Strip attributes starting with \"__\" if True.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>igraph.AnnNet with integer vertex indices. External vertex IDs are stored in vertex attribute 'name'. Edge IDs stored in edge attribute 'eid'. Hyperedges are either dropped or expanded into multiple binary edges. No manifest is returned, so round-tripping will lose hyperedge structure, slices, and precise edge IDs.</p> Notes <p>This is a lossy export. Use to_igraph() with manifest for full fidelity. igraph requires integer vertex indices internally; the 'name' attribute preserves your original string IDs.</p>"},{"location":"reference/interoperability/#annnet.adapters.igraph_adapter.from_ig_only","title":"<code>from_ig_only(igG, *, hyperedge='none', he_node_flag='is_hyperedge', he_id_attr='eid', role_attr='role', coeff_attr='coeff', membership_attr='membership_of')</code>","text":"<p>Best-effort import from a plain igraph.AnnNet (no manifest). Preserves all vertex/edge attributes. hyperedge: \"none\" | \"reified\"   When \"reified\", rebuild true hyperedges and skip membership edges from binary import.</p>"},{"location":"reference/interoperability/#graph-tool-optional","title":"graph-tool (optional)","text":"Internal helpers <p>AnnNet-tool adapter for AnnNet AnnNet.</p> <p>Provides:     to_graphtool(G)      -&gt; (gt.Graph, manifest_dict)     from_graphtool(gtG, manifest=None) -&gt; AnnNet</p> <p>graph-tool only gets what it can natively represent:     - vertices (type 'vertex')     - simple binary edges with a global directedness + a 'weight' edge property Everything else (hyperedges, per-edge directedness, multilayer, slices, all attribute tables, etc.) is preserved in <code>manifest</code>.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter","title":"<code>annnet.adapters.graphtool_adapter</code>","text":"<p>AnnNet-tool adapter for AnnNet AnnNet.</p> <p>Provides:     to_graphtool(G)      -&gt; (gt.Graph, manifest_dict)     from_graphtool(gtG, manifest=None) -&gt; AnnNet</p> <p>graph-tool only gets what it can natively represent:     - vertices (type 'vertex')     - simple binary edges with a global directedness + a 'weight' edge property Everything else (hyperedges, per-edge directedness, multilayer, slices, all attribute tables, etc.) is preserved in <code>manifest</code>.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_slices","title":"<code>_deserialize_slices(data)</code>","text":"<p>Inverse of _serialize_slices.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_slices","title":"<code>_serialize_slices(slices)</code>","text":"<p>_slices is {slice_id: {\"vertices\": set, \"edges\": set, \"attributes\": dict}} Convert sets to lists for JSON.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.to_graphtool","title":"<code>to_graphtool(G, *, vertex_id_property='id', edge_id_property='id', weight_property='weight')</code>","text":"<p>Convert an AnnNet AnnNet -&gt; (graph_tool.AnnNet, manifest).</p> <p>graph-tool graph:   - vertices: only entities with entity_types[u] == \"vertex\"   - edges: only binary edges whose endpoints are such vertices   - vertex property vp[vertex_id_property] = AnnNet vertex id   - edge property   ep[edge_id_property]   = AnnNet edge id   - edge property   ep[weight_property]    = edge weight (float)</p> <p>manifest:   - preserves everything graph-tool cannot: hyperedges, slices,     multilayer, and ALL attribute tables.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.from_graphtool","title":"<code>from_graphtool(gtG, manifest=None, *, vertex_id_property='id', edge_id_property='id', weight_property='weight')</code>","text":"<p>Convert graph_tool.AnnNet (+ optional manifest) back into AnnNet AnnNet.</p> <ul> <li>Vertices: from vertex property <code>vertex_id_property</code> if present, else numeric index.</li> <li>Edges:    from edges in gtG; edge_id from edge property <code>edge_id_property</code> if present,             else auto; weight from edge property <code>weight_property</code> if present, else 1.0.</li> </ul> <p>If <code>manifest</code> is provided, rehydrates:   - all attribute tables (vertex/edge/slice/edge_slice/layer),   - _slices internal structure,   - hyperedges,   - edge_directed and edge_direction_policy,   - multilayer (aspects, elem_layers, VM, aspect attrs, layer-tuple attrs,     edge_kind, edge_layers, node-layer attrs),   - graph_attributes.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_slices","title":"<code>_deserialize_slices(data)</code>","text":"<p>Inverse of _serialize_slices.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_slices","title":"<code>_serialize_slices(slices)</code>","text":"<p>_slices is {slice_id: {\"vertices\": set, \"edges\": set, \"attributes\": dict}} Convert sets to lists for JSON.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.to_graphtool","title":"<code>to_graphtool(G, *, vertex_id_property='id', edge_id_property='id', weight_property='weight')</code>","text":"<p>Convert an AnnNet AnnNet -&gt; (graph_tool.AnnNet, manifest).</p> <p>graph-tool graph:   - vertices: only entities with entity_types[u] == \"vertex\"   - edges: only binary edges whose endpoints are such vertices   - vertex property vp[vertex_id_property] = AnnNet vertex id   - edge property   ep[edge_id_property]   = AnnNet edge id   - edge property   ep[weight_property]    = edge weight (float)</p> <p>manifest:   - preserves everything graph-tool cannot: hyperedges, slices,     multilayer, and ALL attribute tables.</p>"},{"location":"reference/interoperability/#annnet.adapters.graphtool_adapter.from_graphtool","title":"<code>from_graphtool(gtG, manifest=None, *, vertex_id_property='id', edge_id_property='id', weight_property='weight')</code>","text":"<p>Convert graph_tool.AnnNet (+ optional manifest) back into AnnNet AnnNet.</p> <ul> <li>Vertices: from vertex property <code>vertex_id_property</code> if present, else numeric index.</li> <li>Edges:    from edges in gtG; edge_id from edge property <code>edge_id_property</code> if present,             else auto; weight from edge property <code>weight_property</code> if present, else 1.0.</li> </ul> <p>If <code>manifest</code> is provided, rehydrates:   - all attribute tables (vertex/edge/slice/edge_slice/layer),   - _slices internal structure,   - hyperedges,   - edge_directed and edge_direction_policy,   - multilayer (aspects, elem_layers, VM, aspect attrs, layer-tuple attrs,     edge_kind, edge_layers, node-layer attrs),   - graph_attributes.</p>"},{"location":"reference/interoperability/#pytorch-geometric-optional","title":"PyTorch Geometric (optional)","text":"<p>The PyG adapter requires <code>torch</code> + <code>torch_geometric</code>. Public entry point:</p> <ul> <li><code>to_pyg(graph, ...)</code></li> </ul> <p>See <code>annnet.adapters.pyg_adapter</code> in source for full details.</p>"},{"location":"reference/interoperability/#adapter-manager","title":"Adapter Manager","text":"Internal helpers"},{"location":"reference/interoperability/#annnet.adapters.manager","title":"<code>annnet.adapters.manager</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.manager-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.BackendProxy","title":"<code>BackendProxy</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.adapters.manager-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.load_adapter","title":"<code>load_adapter(name, *args, **kwargs)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.get_adapter","title":"<code>get_adapter(name)</code>","text":"<p>Return a new adapter instance for the optional backend.</p>"},{"location":"reference/interoperability/#annnet.adapters.manager.get_proxy","title":"<code>get_proxy(backend_name, graph)</code>","text":"<p>Return a lazy proxy so users can write <code>G.nx.&lt;algo&gt;()</code> etc.</p>"},{"location":"reference/interoperability/#annnet.adapters.manager._backend_import_name","title":"<code>_backend_import_name(name)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.ensure_materialized","title":"<code>ensure_materialized(backend_name, graph)</code>","text":"<p>Convert (or re-convert) graph into the requested backend object and cache the result on the graph\u2019s private state object. Returns:</p>"},{"location":"reference/interoperability/#annnet.adapters.manager-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.BackendProxy","title":"<code>BackendProxy</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.adapters.manager.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.adapters.manager-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.load_adapter","title":"<code>load_adapter(name, *args, **kwargs)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.get_adapter","title":"<code>get_adapter(name)</code>","text":"<p>Return a new adapter instance for the optional backend.</p>"},{"location":"reference/interoperability/#annnet.adapters.manager.get_proxy","title":"<code>get_proxy(backend_name, graph)</code>","text":"<p>Return a lazy proxy so users can write <code>G.nx.&lt;algo&gt;()</code> etc.</p>"},{"location":"reference/interoperability/#annnet.adapters.manager._backend_import_name","title":"<code>_backend_import_name(name)</code>","text":""},{"location":"reference/interoperability/#annnet.adapters.manager.ensure_materialized","title":"<code>ensure_materialized(backend_name, graph)</code>","text":"<p>Convert (or re-convert) graph into the requested backend object and cache the result on the graph\u2019s private state object. Returns:</p>"},{"location":"reference/interoperability/#file-formats","title":"File Formats","text":""},{"location":"reference/interoperability/#graphml-gexf-via-networkx-optional","title":"GraphML / GEXF (via NetworkX, optional)","text":"<p>The GraphML/GEXF helpers require NetworkX. Public entry points:</p> <ul> <li><code>to_graphml(graph, path, ...)</code></li> <li><code>from_graphml(path, ...)</code></li> <li><code>to_gexf(graph, path, ...)</code></li> <li><code>from_gexf(path, ...)</code></li> </ul> <p>See <code>annnet.io.GraphML_io</code> in source for full details.</p>"},{"location":"reference/interoperability/#sif","title":"SIF","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io","title":"<code>annnet.io.SIF_io</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._split_sif_line","title":"<code>_split_sif_line(line, delimiter)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._safe_vertex_attr_table","title":"<code>_safe_vertex_attr_table(graph)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._get_all_edge_attrs","title":"<code>_get_all_edge_attrs(graph, edge_id)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._get_edge_weight","title":"<code>_get_edge_weight(graph, edge_id, default=1.0)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._build_edge_attr_map","title":"<code>_build_edge_attr_map(graph)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io.to_sif","title":"<code>to_sif(graph, path=None, *, relation_attr='relation', default_relation='interacts_with', write_nodes=True, nodes_path=None, lossless=False, manifest_path=None)</code>","text":"<p>Export graph to SIF format.</p> <p>Standard mode (lossless=False):     - Writes only binary edges to SIF file     - Hyperedges, weights, attrs, IDs are lost     - Returns None</p> <p>Lossless mode (lossless=True):     - Writes binary edges to SIF file     - Returns (None, manifest) where manifest contains all lost info     - Manifest can be saved separately and used with from_sif()</p> <p>Args:     path: Output SIF file path (if None, only manifest is returned in lossless mode)     relation_attr: Edge attribute key for relation type     default_relation: Default relation if attr missing     write_nodes: Whether to write .nodes sidecar with vertex attrs     nodes_path: Custom path for nodes sidecar (default: path + \".nodes\")     lossless: If True, return manifest with all non-SIF data     manifest_path: If provided, write manifest to this path (only when lossless=True)</p> <p>Returns:     None (standard mode) or (None, manifest_dict) (lossless mode)</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io.from_sif","title":"<code>from_sif(path, *, manifest=None, directed=True, relation_attr='relation', default_relation='interacts_with', read_nodes_sidecar=True, nodes_path=None, encoding='utf-8', delimiter=None, comment_prefixes=('#', '!'))</code>","text":"<p>Import graph from SIF (Simple Interaction Format).</p> <p>Standard mode (manifest=None):     - Reads binary edges from SIF file (source, relation, target)     - Auto-generates edge IDs (edge_0, edge_1, ...)     - All edges inherit the <code>directed</code> parameter     - Vertex attributes loaded from optional .nodes sidecar     - Hyperedges, per-edge directedness, and complex metadata are lost</p> <p>Lossless mode (manifest provided):     - Reads binary edges from SIF file     - Restores original edge IDs, weights, and attributes from manifest     - Reconstructs hyperedges from manifest     - Restores per-edge directedness from manifest     - Restores slice memberships and slice-specific weights from manifest     - Full round-trip fidelity when paired with to_sif(lossless=True)</p> <p>SIF Format:     - Three columns: sourcerelationtarget     - Lines starting with comment_prefixes are ignored     - Vertices referenced in edges are created automatically <p>Sidecar .nodes file format (optional):     - One vertex per line: vertex_idkey=valuekey=value...     - Boolean values: true/false (case-insensitive)     - Numeric values: auto-detected floats     - String values: everything else <p>Args:     path: Input SIF file path     manifest: Manifest dict or path to manifest JSON (for lossless reconstruction)     directed: Default directedness for edges (overridden by manifest if provided)     relation_attr: Edge attribute key for storing relation type     default_relation: Default relation if not specified in file     read_nodes_sidecar: Whether to read .nodes sidecar file with vertex attributes     nodes_path: Custom path for nodes sidecar (default: path + \".nodes\")     encoding: File encoding (default: utf-8)     delimiter: Custom delimiter (default: auto-detect TAB or whitespace)     comment_prefixes: Line prefixes to skip (default: # and !)</p> <p>Returns:     AnnNet: Reconstructed graph object</p> <p>Notes:     - SIF format only supports binary edges natively     - For full graph reconstruction (hyperedges, slices, metadata), use manifest     - Manifest files are created by to_sif(lossless=True)     - Edge IDs are auto-generated in standard mode, preserved in lossless mode     - Vertex attributes require .nodes sidecar file or manifest</p> Internal helpers"},{"location":"reference/interoperability/#annnet.io.SIF_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io._split_sif_line","title":"<code>_split_sif_line(line, delimiter)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._safe_vertex_attr_table","title":"<code>_safe_vertex_attr_table(graph)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._get_all_edge_attrs","title":"<code>_get_all_edge_attrs(graph, edge_id)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._get_edge_weight","title":"<code>_get_edge_weight(graph, edge_id, default=1.0)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io._build_edge_attr_map","title":"<code>_build_edge_attr_map(graph)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SIF_io.to_sif","title":"<code>to_sif(graph, path=None, *, relation_attr='relation', default_relation='interacts_with', write_nodes=True, nodes_path=None, lossless=False, manifest_path=None)</code>","text":"<p>Export graph to SIF format.</p> <p>Standard mode (lossless=False):     - Writes only binary edges to SIF file     - Hyperedges, weights, attrs, IDs are lost     - Returns None</p> <p>Lossless mode (lossless=True):     - Writes binary edges to SIF file     - Returns (None, manifest) where manifest contains all lost info     - Manifest can be saved separately and used with from_sif()</p> <p>Args:     path: Output SIF file path (if None, only manifest is returned in lossless mode)     relation_attr: Edge attribute key for relation type     default_relation: Default relation if attr missing     write_nodes: Whether to write .nodes sidecar with vertex attrs     nodes_path: Custom path for nodes sidecar (default: path + \".nodes\")     lossless: If True, return manifest with all non-SIF data     manifest_path: If provided, write manifest to this path (only when lossless=True)</p> <p>Returns:     None (standard mode) or (None, manifest_dict) (lossless mode)</p>"},{"location":"reference/interoperability/#annnet.io.SIF_io.from_sif","title":"<code>from_sif(path, *, manifest=None, directed=True, relation_attr='relation', default_relation='interacts_with', read_nodes_sidecar=True, nodes_path=None, encoding='utf-8', delimiter=None, comment_prefixes=('#', '!'))</code>","text":"<p>Import graph from SIF (Simple Interaction Format).</p> <p>Standard mode (manifest=None):     - Reads binary edges from SIF file (source, relation, target)     - Auto-generates edge IDs (edge_0, edge_1, ...)     - All edges inherit the <code>directed</code> parameter     - Vertex attributes loaded from optional .nodes sidecar     - Hyperedges, per-edge directedness, and complex metadata are lost</p> <p>Lossless mode (manifest provided):     - Reads binary edges from SIF file     - Restores original edge IDs, weights, and attributes from manifest     - Reconstructs hyperedges from manifest     - Restores per-edge directedness from manifest     - Restores slice memberships and slice-specific weights from manifest     - Full round-trip fidelity when paired with to_sif(lossless=True)</p> <p>SIF Format:     - Three columns: sourcerelationtarget     - Lines starting with comment_prefixes are ignored     - Vertices referenced in edges are created automatically <p>Sidecar .nodes file format (optional):     - One vertex per line: vertex_idkey=valuekey=value...     - Boolean values: true/false (case-insensitive)     - Numeric values: auto-detected floats     - String values: everything else <p>Args:     path: Input SIF file path     manifest: Manifest dict or path to manifest JSON (for lossless reconstruction)     directed: Default directedness for edges (overridden by manifest if provided)     relation_attr: Edge attribute key for storing relation type     default_relation: Default relation if not specified in file     read_nodes_sidecar: Whether to read .nodes sidecar file with vertex attributes     nodes_path: Custom path for nodes sidecar (default: path + \".nodes\")     encoding: File encoding (default: utf-8)     delimiter: Custom delimiter (default: auto-detect TAB or whitespace)     comment_prefixes: Line prefixes to skip (default: # and !)</p> <p>Returns:     AnnNet: Reconstructed graph object</p> <p>Notes:     - SIF format only supports binary edges natively     - For full graph reconstruction (hyperedges, slices, metadata), use manifest     - Manifest files are created by to_sif(lossless=True)     - Edge IDs are auto-generated in standard mode, preserved in lossless mode     - Vertex attributes require .nodes sidecar file or manifest</p>"},{"location":"reference/interoperability/#sbml","title":"SBML","text":"Internal helpers"},{"location":"reference/interoperability/#annnet.io.SBML_io","title":"<code>annnet.io.SBML_io</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io.BOUNDARY_SOURCE","title":"<code>BOUNDARY_SOURCE = '__BOUNDARY_SOURCE__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io.BOUNDARY_SINK","title":"<code>BOUNDARY_SINK = '__BOUNDARY_SINK__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io._monkeypatch_set_hyperedge_coeffs","title":"<code>_monkeypatch_set_hyperedge_coeffs(G)</code>","text":"<p>Add set_hyperedge_coeffs(edge_id, coeffs) to AnnNet instance if missing. Writes per-vertex coefficients into the incidence column. Returns True if patch was applied, False if already available.</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io._ensure_vertices","title":"<code>_ensure_vertices(G, vertices, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io._ensure_boundary_vertices","title":"<code>_ensure_boundary_vertices(G, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io._read_sbml_model","title":"<code>_read_sbml_model(path)</code>","text":"<p>Read SBML with libSBML and return the Model object.</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io._graph_from_sbml_model","title":"<code>_graph_from_sbml_model(model, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":"<p>Build a AnnNet from an SBML model using only libSBML.</p> <ul> <li>Vertices: SBML species ids (plus global boundary source/sink nodes).</li> <li>Hyperedges: reactions, tail = reactants, head = products.</li> <li>Stoichiometry: signed coefficients (reactants negative, products positive).</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SBML_io.from_sbml","title":"<code>from_sbml(path, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":"<p>Read SBML using python-libsbml.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the SBML file.</p> required <code>graph</code> <code>AnnNet | None</code> <p>Optional existing AnnNet to add entities/edges to.</p> <code>None</code> <code>slice</code> <code>str</code> <p>AnnNet slice name.</p> <code>'default'</code> <code>preserve_stoichiometry</code> <code>bool</code> <p>If True, store per-vertex stoichiometric coefficients (either via <code>set_hyperedge_coeffs</code> if available, or as an edge attribute <code>stoich</code>).</p> <code>True</code>"},{"location":"reference/interoperability/#annnet.io.SBML_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io.BOUNDARY_SOURCE","title":"<code>BOUNDARY_SOURCE = '__BOUNDARY_SOURCE__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io.BOUNDARY_SINK","title":"<code>BOUNDARY_SINK = '__BOUNDARY_SINK__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io._monkeypatch_set_hyperedge_coeffs","title":"<code>_monkeypatch_set_hyperedge_coeffs(G)</code>","text":"<p>Add set_hyperedge_coeffs(edge_id, coeffs) to AnnNet instance if missing. Writes per-vertex coefficients into the incidence column. Returns True if patch was applied, False if already available.</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io._ensure_vertices","title":"<code>_ensure_vertices(G, vertices, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io._ensure_boundary_vertices","title":"<code>_ensure_boundary_vertices(G, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.SBML_io._read_sbml_model","title":"<code>_read_sbml_model(path)</code>","text":"<p>Read SBML with libSBML and return the Model object.</p>"},{"location":"reference/interoperability/#annnet.io.SBML_io._graph_from_sbml_model","title":"<code>_graph_from_sbml_model(model, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":"<p>Build a AnnNet from an SBML model using only libSBML.</p> <ul> <li>Vertices: SBML species ids (plus global boundary source/sink nodes).</li> <li>Hyperedges: reactions, tail = reactants, head = products.</li> <li>Stoichiometry: signed coefficients (reactants negative, products positive).</li> </ul>"},{"location":"reference/interoperability/#annnet.io.SBML_io.from_sbml","title":"<code>from_sbml(path, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":"<p>Read SBML using python-libsbml.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the SBML file.</p> required <code>graph</code> <code>AnnNet | None</code> <p>Optional existing AnnNet to add entities/edges to.</p> <code>None</code> <code>slice</code> <code>str</code> <p>AnnNet slice name.</p> <code>'default'</code> <code>preserve_stoichiometry</code> <code>bool</code> <p>If True, store per-vertex stoichiometric coefficients (either via <code>set_hyperedge_coeffs</code> if available, or as an edge attribute <code>stoich</code>).</p> <code>True</code>"},{"location":"reference/interoperability/#sbml-cobra","title":"SBML (COBRA)","text":"Internal helpers SBML (Systems Biology Markup Language) \u2192 AnnNet adapter <p>Targets the provided <code>AnnNet</code> API.</p> <p>Two entry points:   - from_sbml(path, graph=None, slice=\"default\", preserve_stoichiometry=True)   - from_cobra_model(model, graph=None, slice=\"default\", preserve_stoichiometry=True)</p> <p>If <code>AnnNet.set_hyperedge_coeffs(edge_id, coeffs: dict[str, float])</code> is not available, stoichiometric coefficients are stored under an edge attribute <code>stoich</code> (lossy but usable).</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io","title":"<code>annnet.io.sbml_cobra_io</code>","text":"SBML (Systems Biology Markup Language) \u2192 AnnNet adapter <p>Targets the provided <code>AnnNet</code> API.</p> <p>Two entry points:   - from_sbml(path, graph=None, slice=\"default\", preserve_stoichiometry=True)   - from_cobra_model(model, graph=None, slice=\"default\", preserve_stoichiometry=True)</p> <p>If <code>AnnNet.set_hyperedge_coeffs(edge_id, coeffs: dict[str, float])</code> is not available, stoichiometric coefficients are stored under an edge attribute <code>stoich</code> (lossy but usable).</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.BOUNDARY_SOURCE","title":"<code>BOUNDARY_SOURCE = '__BOUNDARY_SOURCE__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.BOUNDARY_SINK","title":"<code>BOUNDARY_SINK = '__BOUNDARY_SINK__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._monkeypatch_set_hyperedge_coeffs","title":"<code>_monkeypatch_set_hyperedge_coeffs(G)</code>","text":"<p>Add <code>set_hyperedge_coeffs(edge_id, coeffs)</code> to AnnNet instance if missing. Writes per-vertex coefficients into the incidence column (DOK [Dictionary Of Keys]). Returns True if patch was applied, False if already available.</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._ensure_vertices","title":"<code>_ensure_vertices(G, vertices, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._ensure_boundary_vertices","title":"<code>_ensure_boundary_vertices(G, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._graph_from_stoich","title":"<code>_graph_from_stoich(S, metabolite_ids, reaction_ids, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.from_cobra_model","title":"<code>from_cobra_model(model, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":"<p>Convert a COBRApy model to AnnNet. Requires cobra.util.array.create_stoichiometric_matrix. Edge attributes added: name, default_lb, default_ub, gpr (Gene-Protein-Reaction rule [GPR]).</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.from_sbml","title":"<code>from_sbml(path, graph=None, *, slice='default', preserve_stoichiometry=True, quiet=True)</code>","text":"<p>Read SBML using COBRApy if available; falls back to python-libsbml (if you extend this file).</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.BOUNDARY_SOURCE","title":"<code>BOUNDARY_SOURCE = '__BOUNDARY_SOURCE__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.BOUNDARY_SINK","title":"<code>BOUNDARY_SINK = '__BOUNDARY_SINK__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._monkeypatch_set_hyperedge_coeffs","title":"<code>_monkeypatch_set_hyperedge_coeffs(G)</code>","text":"<p>Add <code>set_hyperedge_coeffs(edge_id, coeffs)</code> to AnnNet instance if missing. Writes per-vertex coefficients into the incidence column (DOK [Dictionary Of Keys]). Returns True if patch was applied, False if already available.</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._ensure_vertices","title":"<code>_ensure_vertices(G, vertices, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._ensure_boundary_vertices","title":"<code>_ensure_boundary_vertices(G, slice)</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io._graph_from_stoich","title":"<code>_graph_from_stoich(S, metabolite_ids, reaction_ids, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":""},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.from_cobra_model","title":"<code>from_cobra_model(model, graph=None, *, slice='default', preserve_stoichiometry=True)</code>","text":"<p>Convert a COBRApy model to AnnNet. Requires cobra.util.array.create_stoichiometric_matrix. Edge attributes added: name, default_lb, default_ub, gpr (Gene-Protein-Reaction rule [GPR]).</p>"},{"location":"reference/interoperability/#annnet.io.sbml_cobra_io.from_sbml","title":"<code>from_sbml(path, graph=None, *, slice='default', preserve_stoichiometry=True, quiet=True)</code>","text":"<p>Read SBML using COBRApy if available; falls back to python-libsbml (if you extend this file).</p>"},{"location":"reference/interoperability/#cx2","title":"CX2","text":"Internal helpers <p>CX2 Adapter for AnnNet AnnNet.</p> <p>Provides:     to_cx2(G)        -&gt; List[Dict[str, Any]] (CX2 JSON object)     from_cx2(cx2_data) -&gt; AnnNet</p> <p>This adapter maps AnnNet Graphs to the Cytoscape Exchange (CX2) format. It creates a lossless representation by serializing complex features (hyperedges, slices, multilayer) into a 'manifest' stored within the CX2 'networkAttributes'.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io","title":"<code>annnet.io.cx2_io</code>","text":"<p>CX2 Adapter for AnnNet AnnNet.</p> <p>Provides:     to_cx2(G)        -&gt; List[Dict[str, Any]] (CX2 JSON object)     from_cx2(cx2_data) -&gt; AnnNet</p> <p>This adapter maps AnnNet Graphs to the Cytoscape Exchange (CX2) format. It creates a lossless representation by serializing complex features (hyperedges, slices, multilayer) into a 'manifest' stored within the CX2 'networkAttributes'.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io.CX_STYLE_KEY","title":"<code>CX_STYLE_KEY = '__cx_style__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_slices","title":"<code>_deserialize_slices(data)</code>","text":"<p>Inverse of _serialize_slices.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._safe_df_to_rows","title":"<code>_safe_df_to_rows(df)</code>","text":"<p>Return list[dict] rows from polars/pandas/narwhals; return [] on None/empty/unknown.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_slices","title":"<code>_serialize_slices(slices)</code>","text":"<p>_slices is {slice_id: {\"vertices\": set, \"edges\": set, \"attributes\": dict}} Convert sets to lists for JSON.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._cx2_collect_reified","title":"<code>_cx2_collect_reified(aspects)</code>","text":"<p>Detect reified hyperedges from CX2 nodes + edges.</p> <p>Returns:   hyperdefs: list of (eid, directed, head_map, tail_map, attrs, he_node_id)   membership_edges: set of edge-ids in CX2 that belong to hyperedge membership structure.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io._map_pl_to_cx2_type","title":"<code>_map_pl_to_cx2_type(dtype)</code>","text":"<p>Map Polars DataType to CX2 attribute data type string.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._jsonify","title":"<code>_jsonify(obj)</code>","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io.to_cx2","title":"<code>to_cx2(G, *, export_name='annnet export', layer=None, include_inter=False, include_coupling=False, hyperedges='skip')</code>","text":"<p>Convert an AnnNet graph to CX2 compliant JSON format.</p> <p>The output is a list of aspect dictionaries (CX2 format). Complex AnnNet features (hyperedges, slices, multilayer structure) are serialized into a JSON string stored in networkAttributes under 'AnnNet_Manifest'.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>The graph to export.</p> required <code>export_name</code> <code>str</code> <p>Name of the exported network (stored in networkAttributes).</p> <code>\"annnet export\"</code> <code>layer</code> <code>tuple of str</code> <p>Elementary layer tuple specifying which layer to export. If provided, only the subgraph for that layer is exported. Useful for multilayer graphs where flattening creates unreadable visualizations in Cytoscape (e.g., coupling edges become self-loops). If None, exports the entire graph. Example: layer=(\"social\", \"2020\") for a 2-aspect multilayer network.</p> <code>None</code> <code>hyperedges</code> <code>('skip', 'expand', 'reify')</code> <p>How to handle hyperedges in the export: - \"skip\": Omit hyperedges entirely - \"expand\": Convert to cartesian product of pairwise edges - \"reify\": Create explicit hyperedge nodes with membership edges</p> <code>\"skip\"</code> <p>Returns:</p> Type Description <code>list of dict</code> <p>CX2-compliant JSON structure (list of aspect dictionaries).</p> Notes <ul> <li>Cytoscape does not natively support multilayer networks. When exporting   multilayer graphs without specifying a layer, coupling edges may appear   as self-loops and the visualization becomes cluttered.</li> <li>Use the <code>layer</code> parameter to export individual elementary layers for   clean, interpretable Cytoscape visualizations.</li> <li>The full multilayer structure is preserved in the manifest regardless   of the <code>layer</code> parameter, enabling lossless round-trip via from_cx2().</li> </ul>"},{"location":"reference/interoperability/#annnet.io.cx2_io.from_cx2","title":"<code>from_cx2(cx2_data, *, hyperedges='manifest')</code>","text":"<p>Fully robust CX2 - AnnNet importer. Supports:   - manifest reconstruction (full fidelity)   - reified hyperedges   - expanded hyperedges   - Cytoscape-edited files   - sparse attribute tables   - arbitrary attribute modifications</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io.show","title":"<code>show(G, *, export_name='annnet export', layer=None, include_inter=False, include_coupling=False, hyperedges='skip', port=None, auto_open=True)</code>","text":"<p>Visualize graph in web browser using Cytoscape.js.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>The graph to visualize.</p> required <code>export_name</code> <code>str</code> <p>Name of the network display.</p> <code>\"annnet export\"</code> <code>layer</code> <code>tuple of str</code> <p>Elementary layer tuple specifying which layer to visualize. If None, shows the entire graph (may include coupling edges as self-loops). Example: layer=(\"social\", \"2020\") for a 2-aspect multilayer network.</p> <code>None</code> <code>include_inter</code> <code>bool</code> <p>When layer is specified, whether to include interlayer edges (edges between nodes in different layers but same aspect). Only relevant if layer is not None.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>When layer is specified, whether to include coupling edges (edges connecting the same node across layers). Only relevant if layer is not None. Warning: Including coupling creates self-loops in the visualization.</p> <code>False</code> <code>hyperedges</code> <code>('skip', 'expand', 'reify')</code> <p>How to handle hyperedges: - \"skip\": Omit hyperedges entirely - \"expand\": Convert to cartesian product of pairwise edges - \"reify\": Create explicit hyperedge nodes with membership edges</p> <code>\"skip\"</code> <code>port</code> <code>int</code> <p>Port for local web server. If None, finds available port automatically.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>If True, automatically open browser.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Local URL to the visualization.</p> Notes <p>For multilayer graphs: - Without layer parameter: shows entire flattened graph with coupling edges   appearing as self-loops (messy but shows full structure) - With layer parameter: shows clean single-layer view without coupling edges   (recommended for visualization)</p> <p>Press Ctrl+C in terminal to stop the web server.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G.show()  # Show entire graph (all layers flattened)\n&gt;&gt;&gt; G.show(layer=(\"social\", \"2020\"))  # Clean single layer view\n&gt;&gt;&gt; G.show(layer=(\"social\", \"2020\"), include_coupling=True)  # With self-loops\n</code></pre>"},{"location":"reference/interoperability/#annnet.io.cx2_io._cx2_to_cytoscapejs","title":"<code>_cx2_to_cytoscapejs(cx2_data)</code>","text":"<p>Convert CX2 format to Cytoscape.js format.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io.CX_STYLE_KEY","title":"<code>CX_STYLE_KEY = '__cx_style__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_slices","title":"<code>_deserialize_slices(data)</code>","text":"<p>Inverse of _serialize_slices.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._safe_df_to_rows","title":"<code>_safe_df_to_rows(df)</code>","text":"<p>Return list[dict] rows from polars/pandas/narwhals; return [] on None/empty/unknown.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_slices","title":"<code>_serialize_slices(slices)</code>","text":"<p>_slices is {slice_id: {\"vertices\": set, \"edges\": set, \"attributes\": dict}} Convert sets to lists for JSON.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._cx2_collect_reified","title":"<code>_cx2_collect_reified(aspects)</code>","text":"<p>Detect reified hyperedges from CX2 nodes + edges.</p> <p>Returns:   hyperdefs: list of (eid, directed, head_map, tail_map, attrs, he_node_id)   membership_edges: set of edge-ids in CX2 that belong to hyperedge membership structure.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io._map_pl_to_cx2_type","title":"<code>_map_pl_to_cx2_type(dtype)</code>","text":"<p>Map Polars DataType to CX2 attribute data type string.</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io._jsonify","title":"<code>_jsonify(obj)</code>","text":""},{"location":"reference/interoperability/#annnet.io.cx2_io.to_cx2","title":"<code>to_cx2(G, *, export_name='annnet export', layer=None, include_inter=False, include_coupling=False, hyperedges='skip')</code>","text":"<p>Convert an AnnNet graph to CX2 compliant JSON format.</p> <p>The output is a list of aspect dictionaries (CX2 format). Complex AnnNet features (hyperedges, slices, multilayer structure) are serialized into a JSON string stored in networkAttributes under 'AnnNet_Manifest'.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>The graph to export.</p> required <code>export_name</code> <code>str</code> <p>Name of the exported network (stored in networkAttributes).</p> <code>\"annnet export\"</code> <code>layer</code> <code>tuple of str</code> <p>Elementary layer tuple specifying which layer to export. If provided, only the subgraph for that layer is exported. Useful for multilayer graphs where flattening creates unreadable visualizations in Cytoscape (e.g., coupling edges become self-loops). If None, exports the entire graph. Example: layer=(\"social\", \"2020\") for a 2-aspect multilayer network.</p> <code>None</code> <code>hyperedges</code> <code>('skip', 'expand', 'reify')</code> <p>How to handle hyperedges in the export: - \"skip\": Omit hyperedges entirely - \"expand\": Convert to cartesian product of pairwise edges - \"reify\": Create explicit hyperedge nodes with membership edges</p> <code>\"skip\"</code> <p>Returns:</p> Type Description <code>list of dict</code> <p>CX2-compliant JSON structure (list of aspect dictionaries).</p> Notes <ul> <li>Cytoscape does not natively support multilayer networks. When exporting   multilayer graphs without specifying a layer, coupling edges may appear   as self-loops and the visualization becomes cluttered.</li> <li>Use the <code>layer</code> parameter to export individual elementary layers for   clean, interpretable Cytoscape visualizations.</li> <li>The full multilayer structure is preserved in the manifest regardless   of the <code>layer</code> parameter, enabling lossless round-trip via from_cx2().</li> </ul>"},{"location":"reference/interoperability/#annnet.io.cx2_io.from_cx2","title":"<code>from_cx2(cx2_data, *, hyperedges='manifest')</code>","text":"<p>Fully robust CX2 - AnnNet importer. Supports:   - manifest reconstruction (full fidelity)   - reified hyperedges   - expanded hyperedges   - Cytoscape-edited files   - sparse attribute tables   - arbitrary attribute modifications</p>"},{"location":"reference/interoperability/#annnet.io.cx2_io.show","title":"<code>show(G, *, export_name='annnet export', layer=None, include_inter=False, include_coupling=False, hyperedges='skip', port=None, auto_open=True)</code>","text":"<p>Visualize graph in web browser using Cytoscape.js.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>The graph to visualize.</p> required <code>export_name</code> <code>str</code> <p>Name of the network display.</p> <code>\"annnet export\"</code> <code>layer</code> <code>tuple of str</code> <p>Elementary layer tuple specifying which layer to visualize. If None, shows the entire graph (may include coupling edges as self-loops). Example: layer=(\"social\", \"2020\") for a 2-aspect multilayer network.</p> <code>None</code> <code>include_inter</code> <code>bool</code> <p>When layer is specified, whether to include interlayer edges (edges between nodes in different layers but same aspect). Only relevant if layer is not None.</p> <code>False</code> <code>include_coupling</code> <code>bool</code> <p>When layer is specified, whether to include coupling edges (edges connecting the same node across layers). Only relevant if layer is not None. Warning: Including coupling creates self-loops in the visualization.</p> <code>False</code> <code>hyperedges</code> <code>('skip', 'expand', 'reify')</code> <p>How to handle hyperedges: - \"skip\": Omit hyperedges entirely - \"expand\": Convert to cartesian product of pairwise edges - \"reify\": Create explicit hyperedge nodes with membership edges</p> <code>\"skip\"</code> <code>port</code> <code>int</code> <p>Port for local web server. If None, finds available port automatically.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>If True, automatically open browser.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Local URL to the visualization.</p> Notes <p>For multilayer graphs: - Without layer parameter: shows entire flattened graph with coupling edges   appearing as self-loops (messy but shows full structure) - With layer parameter: shows clean single-layer view without coupling edges   (recommended for visualization)</p> <p>Press Ctrl+C in terminal to stop the web server.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G.show()  # Show entire graph (all layers flattened)\n&gt;&gt;&gt; G.show(layer=(\"social\", \"2020\"))  # Clean single layer view\n&gt;&gt;&gt; G.show(layer=(\"social\", \"2020\"), include_coupling=True)  # With self-loops\n</code></pre>"},{"location":"reference/interoperability/#annnet.io.cx2_io._cx2_to_cytoscapejs","title":"<code>_cx2_to_cytoscapejs(cx2_data)</code>","text":"<p>Convert CX2 format to Cytoscape.js format.</p>"},{"location":"reference/interoperability/#json-ndjson","title":"JSON / NDJSON","text":"Internal helpers"},{"location":"reference/interoperability/#annnet.io.json_io","title":"<code>annnet.io.json_io</code>","text":""},{"location":"reference/interoperability/#annnet.io.json_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.io.json_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._is_directed_eid","title":"<code>_is_directed_eid(graph, eid)</code>","text":""},{"location":"reference/interoperability/#annnet.io.json_io._coerce_coeff_mapping","title":"<code>_coerce_coeff_mapping(val)</code>","text":"<p>Normalize various serialized forms into {vertex: {__value: float}|float} Accepts:   - dict({v: x} or {v: {\"__value\": x}})   - list of pairs [(v,x), ...]   - list of dicts [{\"vertex\": v, \"__value\": x} | {v: x}, ...]   - JSON string of any of the above</p>"},{"location":"reference/interoperability/#annnet.io.json_io._endpoint_coeff_map","title":"<code>_endpoint_coeff_map(edge_attrs, private_key, endpoint_set)</code>","text":"<p>Return {vertex: float_coeff} for the given endpoint_set. Reads from edge_attrs[private_key] which may be serialized in multiple shapes. Missing endpoints default to 1.0.</p>"},{"location":"reference/interoperability/#annnet.io.json_io.to_json","title":"<code>to_json(graph, path, *, public_only=False, indent=0)</code>","text":"<p>Node-link JSON with x-extensions (slices, edge_slices, hyperedges). Lossless vs your core (IDs, attrs, parallel, hyperedges, slices).</p>"},{"location":"reference/interoperability/#annnet.io.json_io.from_json","title":"<code>from_json(path)</code>","text":"<p>Load AnnNet from node-link JSON + x-extensions (lossless wrt schema above).</p>"},{"location":"reference/interoperability/#annnet.io.json_io.write_ndjson","title":"<code>write_ndjson(graph, dir_path)</code>","text":"<p>Write nodes.ndjson, edges.ndjson, hyperedges.ndjson, slices.ndjson, edge_slices.ndjson. Each line is one JSON object. Lossless wrt to_json schema.</p>"},{"location":"reference/interoperability/#annnet.io.json_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.io.json_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.io.json_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._df_to_rows","title":"<code>_df_to_rows(df)</code>","text":"<p>Convert a Polars DataFrame to list-of-dicts in a stable way.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._rows_to_df","title":"<code>_rows_to_df(rows)</code>","text":"<p>Build a Polars DataFrame from list-of-dicts. Empty -&gt; empty DF.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/interoperability/#annnet.io.json_io._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.json_io._is_directed_eid","title":"<code>_is_directed_eid(graph, eid)</code>","text":""},{"location":"reference/interoperability/#annnet.io.json_io._coerce_coeff_mapping","title":"<code>_coerce_coeff_mapping(val)</code>","text":"<p>Normalize various serialized forms into {vertex: {__value: float}|float} Accepts:   - dict({v: x} or {v: {\"__value\": x}})   - list of pairs [(v,x), ...]   - list of dicts [{\"vertex\": v, \"__value\": x} | {v: x}, ...]   - JSON string of any of the above</p>"},{"location":"reference/interoperability/#annnet.io.json_io._endpoint_coeff_map","title":"<code>_endpoint_coeff_map(edge_attrs, private_key, endpoint_set)</code>","text":"<p>Return {vertex: float_coeff} for the given endpoint_set. Reads from edge_attrs[private_key] which may be serialized in multiple shapes. Missing endpoints default to 1.0.</p>"},{"location":"reference/interoperability/#annnet.io.json_io.to_json","title":"<code>to_json(graph, path, *, public_only=False, indent=0)</code>","text":"<p>Node-link JSON with x-extensions (slices, edge_slices, hyperedges). Lossless vs your core (IDs, attrs, parallel, hyperedges, slices).</p>"},{"location":"reference/interoperability/#annnet.io.json_io.from_json","title":"<code>from_json(path)</code>","text":"<p>Load AnnNet from node-link JSON + x-extensions (lossless wrt schema above).</p>"},{"location":"reference/interoperability/#annnet.io.json_io.write_ndjson","title":"<code>write_ndjson(graph, dir_path)</code>","text":"<p>Write nodes.ndjson, edges.ndjson, hyperedges.ndjson, slices.ndjson, edge_slices.ndjson. Each line is one JSON object. Lossless wrt to_json schema.</p>"},{"location":"reference/interoperability/#csv","title":"CSV","text":"Internal helpers <p>This module purposefully avoids importing stdlib <code>csv</code> and uses Polars for IO.</p> <p>It ingests a CSV into AnnNet by auto-detecting common schemas: - Edge list (including DOK/COO triples and variations) - Hyperedge table (members column or head/tail sets) - Incidence matrix (rows=entities, cols=edges, \u00b1w orientation) - Adjacency matrix (square matrix, weighted/unweighted) - LIL-style neighbor lists (single column of neighbors)</p> <p>If auto-detection fails or you want control, pass schema=... explicitly.</p> <p>Dependencies: polars, numpy, scipy (only if you use sparse helpers), AnnNet</p> <p>Design notes: - We treat unknown columns as attributes (\"pure\" non-structural) and write them via   the corresponding set_*_attrs APIs when applicable. - slices: if a <code>slice</code> column exists it can contain a single slice or multiple   (separated by <code>|</code>, <code>;</code>, or <code>,</code>). Per-slice weight overrides support columns of the   form <code>weight:&lt;slice_name&gt;</code>. - Directedness: we honor an explicit <code>directed</code> column when present (truthy), else   infer for incidence (presence of negative values) and adjacency (symmetry check). - We try not to guess too hard. If the heuristics get it wrong, supply   schema=\"edge_list\" / \"hyperedge\" / \"incidence\" / \"adjacency\" / \"lil\".</p> <p>Public entry points: - load_csv_to_graph(path, graph=None, schema=\"auto\", options) -&gt; AnnNet - from_dataframe(df, graph=None, schema=\"auto\", options) -&gt; AnnNet</p> <p>Both will create and return an AnnNet (or mutate the provided one).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io","title":"<code>annnet.io.csv_io</code>","text":"<p>This module purposefully avoids importing stdlib <code>csv</code> and uses Polars for IO.</p> <p>It ingests a CSV into AnnNet by auto-detecting common schemas: - Edge list (including DOK/COO triples and variations) - Hyperedge table (members column or head/tail sets) - Incidence matrix (rows=entities, cols=edges, \u00b1w orientation) - Adjacency matrix (square matrix, weighted/unweighted) - LIL-style neighbor lists (single column of neighbors)</p> <p>If auto-detection fails or you want control, pass schema=... explicitly.</p> <p>Dependencies: polars, numpy, scipy (only if you use sparse helpers), AnnNet</p> <p>Design notes: - We treat unknown columns as attributes (\"pure\" non-structural) and write them via   the corresponding set_*_attrs APIs when applicable. - slices: if a <code>slice</code> column exists it can contain a single slice or multiple   (separated by <code>|</code>, <code>;</code>, or <code>,</code>). Per-slice weight overrides support columns of the   form <code>weight:&lt;slice_name&gt;</code>. - Directedness: we honor an explicit <code>directed</code> column when present (truthy), else   infer for incidence (presence of negative values) and adjacency (symmetry check). - We try not to guess too hard. If the heuristics get it wrong, supply   schema=\"edge_list\" / \"hyperedge\" / \"incidence\" / \"adjacency\" / \"lil\".</p> <p>Public entry points: - load_csv_to_graph(path, graph=None, schema=\"auto\", options) -&gt; AnnNet - from_dataframe(df, graph=None, schema=\"auto\", options) -&gt; AnnNet</p> <p>Both will create and return an AnnNet (or mutate the provided one).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._STR_TRUE","title":"<code>_STR_TRUE = {'1', 'true', 't', 'yes', 'y', 'on'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._STR_FALSE","title":"<code>_STR_FALSE = {'0', 'false', 'f', 'no', 'n', 'off'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._slice_SEP","title":"<code>_slice_SEP = re.compile('[|;,]')</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._SET_SEP","title":"<code>_SET_SEP = re.compile('[|;,]\\\\s*')</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.SRC_COLS","title":"<code>SRC_COLS = ['source', 'src', 'from', 'u']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.DST_COLS","title":"<code>DST_COLS = ['target', 'dst', 'to', 'v']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.WGT_COLS","title":"<code>WGT_COLS = ['weight', 'w']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.DIR_COLS","title":"<code>DIR_COLS = ['directed', 'is_directed', 'dir', 'orientation']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.slice_COLS","title":"<code>slice_COLS = ['slice', 'slices']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.EDGE_ID_COLS","title":"<code>EDGE_ID_COLS = ['edge', 'edge_id', 'id']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.vertex_ID_COLS","title":"<code>vertex_ID_COLS = ['vertex', 'vertex_id', 'id', 'name', 'label']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.NEIGH_COLS","title":"<code>NEIGH_COLS = ['neighbors', 'nbrs', 'adj', 'adjacency', 'neighbors_out', 'neighbors_in']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.MEMBERS_COLS","title":"<code>MEMBERS_COLS = ['members', 'verts', 'participants']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.HEAD_COLS","title":"<code>HEAD_COLS = ['head', 'heads']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.TAIL_COLS","title":"<code>TAIL_COLS = ['tail', 'tails']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.ROW_COLS","title":"<code>ROW_COLS = ['row', 'i', 'r']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.COL_COLS","title":"<code>COL_COLS = ['col', 'column', 'j', 'c']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.VAL_COLS","title":"<code>VAL_COLS = ['val', 'value', 'w', 'weight']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.RESERVED","title":"<code>RESERVED = set(SRC_COLS + DST_COLS + WGT_COLS + DIR_COLS + slice_COLS + EDGE_ID_COLS + vertex_ID_COLS + NEIGH_COLS + MEMBERS_COLS + HEAD_COLS + TAIL_COLS + ROW_COLS + COL_COLS + VAL_COLS)</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._norm","title":"<code>_norm(s)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._truthy","title":"<code>_truthy(x)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._split_slices","title":"<code>_split_slices(cell)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._split_set","title":"<code>_split_set(cell)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._pick_first","title":"<code>_pick_first(df, candidates)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._is_numeric_series","title":"<code>_is_numeric_series(s)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._attr_columns","title":"<code>_attr_columns(df, exclude)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._detect_schema","title":"<code>_detect_schema(df)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.load_csv_to_graph","title":"<code>load_csv_to_graph(path, *, graph=None, schema='auto', default_slice=None, default_directed=None, default_weight=1.0, infer_schema_length=10000, encoding=None, null_values=None, low_memory=True, **kwargs)</code>","text":"<p>Load a CSV and construct/augment an AnnNet.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the CSV file.</p> required <code>graph</code> <code>AnnNet or None</code> <p>If provided, mutate this graph; otherwise create a new AnnNet using <code>AnnNet(**kwargs)</code>.</p> <code>None</code> <code>schema</code> <code>('auto', 'edge_list', 'hyperedge', 'incidence', 'adjacency', 'lil')</code> <p>Parsing mode. 'auto' tries to infer the schema from columns and types.</p> <code>'auto','edge_list','hyperedge','incidence','adjacency','lil'</code> <code>default_slice</code> <code>str or None</code> <p>slice to register vertices/edges when none is specified in the data.</p> <code>None</code> <code>default_directed</code> <code>bool or None</code> <p>Default directedness for binary edges when not implied by data.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight when not specified.</p> <code>1.0</code> <code>infer_schema_length</code> <code>int</code> <p>Row count Polars uses to infer column types.</p> <code>10000</code> <code>encoding</code> <code>str or None</code> <p>File encoding override.</p> <code>None</code> <code>null_values</code> <code>list[str] or None</code> <p>Additional strings to interpret as nulls.</p> <code>None</code> <code>low_memory</code> <code>bool</code> <p>Pass to Polars read_csv for balanced memory usage.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Passed to AnnNet constructor if <code>graph</code> is None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>The populated graph instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no AnnNet can be constructed or imported.</p> <code>ValueError</code> <p>If schema is unknown or parsing fails.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.from_dataframe","title":"<code>from_dataframe(df, *, graph=None, schema='auto', default_slice=None, default_directed=None, default_weight=1.0, **kwargs)</code>","text":"<p>Build/augment an AnnNet from a Polars DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input table parsed from CSV.</p> required <code>graph</code> <code>AnnNet or None</code> <p>If provided, mutate this graph; otherwise create a new AnnNet using <code>AnnNet(**kwargs)</code>.</p> <code>None</code> <code>schema</code> <code>('auto', 'edge_list', 'hyperedge', 'incidence', 'adjacency', 'lil')</code> <p>Parsing mode. 'auto' tries to infer the schema.</p> <code>'auto','edge_list','hyperedge','incidence','adjacency','lil'</code> <code>default_slice</code> <code>str or None</code> <p>Fallback slice if no slice is specified in the data.</p> <code>None</code> <code>default_directed</code> <code>bool or None</code> <p>Default directedness for binary edges when not implied by data.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Weight to use when no explicit weight is present.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>The populated graph instance.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.export_edge_list_csv","title":"<code>export_edge_list_csv(G, path, slice=None)</code>","text":"<p>Export the binary edge subgraph to a CSV [Comma-Separated Values] file.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>AnnNet instance to export. Must support <code>edges_view</code> with columns compatible with binary endpoints (e.g., 'source', 'target').</p> required <code>path</code> <code>str or Path</code> <p>Output path for the CSV file.</p> required <code>slice</code> <code>str</code> <p>Restrict the export to a specific slice. If None, all slices are exported.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>Only binary edges are exported. Hyperedges (edges connecting more than two   entities) are ignored.</li> <li>Output columns include: 'source', 'target', 'weight', 'directed', and 'slice'.</li> <li>If a weight column does not exist, a default weight of 1.0 is written.</li> <li>If a directedness column is absent, it will be written as <code>None</code>.</li> <li>This format is compatible with <code>load_csv_to_graph(schema=\"edge_list\")</code>.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.csv_io.export_hyperedge_csv","title":"<code>export_hyperedge_csv(G, path, slice=None, directed=None)</code>","text":"<p>Export hyperedges from the graph to a CSV [Comma-Separated Values] file.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>AnnNet instance to export. Must support <code>edges_view</code> exposing either 'members' (for undirected hyperedges) or 'head'/'tail' (for directed hyperedges).</p> required <code>path</code> <code>str or Path</code> <p>Output path for the CSV file.</p> required <code>slice</code> <code>str</code> <p>Restrict the export to a specific slice. If None, all slices are exported.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Force treatment of hyperedges as directed or undirected. If None, the function attempts to infer directedness from the graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>If the graph exposes a 'members' column, the output will contain one row per   undirected hyperedge.</li> <li>If 'head' and 'tail' columns are present, the output will contain one row per   directed hyperedge. If <code>directed=False</code> is passed, 'head' and 'tail' are merged   into a 'members' column.</li> <li>A 'weight' column is included if available; otherwise, all weights default to 1.0.</li> <li>A 'slice' column is included if present or if <code>slice</code> is specified.</li> <li>This format is compatible with <code>load_csv_to_graph(schema=\"hyperedge\")</code>.</li> <li>If the graph does not expose hyperedge columns, a <code>ValueError</code> is raised.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_edge_list","title":"<code>_ingest_edge_list(df, G, default_slice, default_directed, default_weight)</code>","text":"<p>Parse edge-list-like tables (incl. COO/DOK).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_hyperedge","title":"<code>_ingest_hyperedge(df, G, default_slice, default_weight)</code>","text":"<p>Parse hyperedge tables (members OR head/tail).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_incidence","title":"<code>_ingest_incidence(df, G, default_slice, default_weight)</code>","text":"<p>Parse incidence matrices (first col = entity id, remaining numeric edge columns).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_adjacency","title":"<code>_ingest_adjacency(df, G, default_slice, default_directed, default_weight)</code>","text":"<p>Parse adjacency matrices (square). If first column is non-numeric, treat as row labels.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_lil","title":"<code>_ingest_lil(df, G, default_slice, default_directed, default_weight)</code>","text":"<p>Parse LIL-style neighbor tables: one row per vertex with a neighbors column.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io-attributes","title":"Attributes","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._STR_TRUE","title":"<code>_STR_TRUE = {'1', 'true', 't', 'yes', 'y', 'on'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._STR_FALSE","title":"<code>_STR_FALSE = {'0', 'false', 'f', 'no', 'n', 'off'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._slice_SEP","title":"<code>_slice_SEP = re.compile('[|;,]')</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._SET_SEP","title":"<code>_SET_SEP = re.compile('[|;,]\\\\s*')</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.SRC_COLS","title":"<code>SRC_COLS = ['source', 'src', 'from', 'u']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.DST_COLS","title":"<code>DST_COLS = ['target', 'dst', 'to', 'v']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.WGT_COLS","title":"<code>WGT_COLS = ['weight', 'w']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.DIR_COLS","title":"<code>DIR_COLS = ['directed', 'is_directed', 'dir', 'orientation']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.slice_COLS","title":"<code>slice_COLS = ['slice', 'slices']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.EDGE_ID_COLS","title":"<code>EDGE_ID_COLS = ['edge', 'edge_id', 'id']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.vertex_ID_COLS","title":"<code>vertex_ID_COLS = ['vertex', 'vertex_id', 'id', 'name', 'label']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.NEIGH_COLS","title":"<code>NEIGH_COLS = ['neighbors', 'nbrs', 'adj', 'adjacency', 'neighbors_out', 'neighbors_in']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.MEMBERS_COLS","title":"<code>MEMBERS_COLS = ['members', 'verts', 'participants']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.HEAD_COLS","title":"<code>HEAD_COLS = ['head', 'heads']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.TAIL_COLS","title":"<code>TAIL_COLS = ['tail', 'tails']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.ROW_COLS","title":"<code>ROW_COLS = ['row', 'i', 'r']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.COL_COLS","title":"<code>COL_COLS = ['col', 'column', 'j', 'c']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.VAL_COLS","title":"<code>VAL_COLS = ['val', 'value', 'w', 'weight']</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.RESERVED","title":"<code>RESERVED = set(SRC_COLS + DST_COLS + WGT_COLS + DIR_COLS + slice_COLS + EDGE_ID_COLS + vertex_ID_COLS + NEIGH_COLS + MEMBERS_COLS + HEAD_COLS + TAIL_COLS + ROW_COLS + COL_COLS + VAL_COLS)</code>  <code>module-attribute</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._norm","title":"<code>_norm(s)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._truthy","title":"<code>_truthy(x)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._split_slices","title":"<code>_split_slices(cell)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._split_set","title":"<code>_split_set(cell)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._pick_first","title":"<code>_pick_first(df, candidates)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._is_numeric_series","title":"<code>_is_numeric_series(s)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._attr_columns","title":"<code>_attr_columns(df, exclude)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io._detect_schema","title":"<code>_detect_schema(df)</code>","text":""},{"location":"reference/interoperability/#annnet.io.csv_io.load_csv_to_graph","title":"<code>load_csv_to_graph(path, *, graph=None, schema='auto', default_slice=None, default_directed=None, default_weight=1.0, infer_schema_length=10000, encoding=None, null_values=None, low_memory=True, **kwargs)</code>","text":"<p>Load a CSV and construct/augment an AnnNet.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the CSV file.</p> required <code>graph</code> <code>AnnNet or None</code> <p>If provided, mutate this graph; otherwise create a new AnnNet using <code>AnnNet(**kwargs)</code>.</p> <code>None</code> <code>schema</code> <code>('auto', 'edge_list', 'hyperedge', 'incidence', 'adjacency', 'lil')</code> <p>Parsing mode. 'auto' tries to infer the schema from columns and types.</p> <code>'auto','edge_list','hyperedge','incidence','adjacency','lil'</code> <code>default_slice</code> <code>str or None</code> <p>slice to register vertices/edges when none is specified in the data.</p> <code>None</code> <code>default_directed</code> <code>bool or None</code> <p>Default directedness for binary edges when not implied by data.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight when not specified.</p> <code>1.0</code> <code>infer_schema_length</code> <code>int</code> <p>Row count Polars uses to infer column types.</p> <code>10000</code> <code>encoding</code> <code>str or None</code> <p>File encoding override.</p> <code>None</code> <code>null_values</code> <code>list[str] or None</code> <p>Additional strings to interpret as nulls.</p> <code>None</code> <code>low_memory</code> <code>bool</code> <p>Pass to Polars read_csv for balanced memory usage.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Passed to AnnNet constructor if <code>graph</code> is None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>The populated graph instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no AnnNet can be constructed or imported.</p> <code>ValueError</code> <p>If schema is unknown or parsing fails.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.from_dataframe","title":"<code>from_dataframe(df, *, graph=None, schema='auto', default_slice=None, default_directed=None, default_weight=1.0, **kwargs)</code>","text":"<p>Build/augment an AnnNet from a Polars DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input table parsed from CSV.</p> required <code>graph</code> <code>AnnNet or None</code> <p>If provided, mutate this graph; otherwise create a new AnnNet using <code>AnnNet(**kwargs)</code>.</p> <code>None</code> <code>schema</code> <code>('auto', 'edge_list', 'hyperedge', 'incidence', 'adjacency', 'lil')</code> <p>Parsing mode. 'auto' tries to infer the schema.</p> <code>'auto','edge_list','hyperedge','incidence','adjacency','lil'</code> <code>default_slice</code> <code>str or None</code> <p>Fallback slice if no slice is specified in the data.</p> <code>None</code> <code>default_directed</code> <code>bool or None</code> <p>Default directedness for binary edges when not implied by data.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Weight to use when no explicit weight is present.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>The populated graph instance.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io.export_edge_list_csv","title":"<code>export_edge_list_csv(G, path, slice=None)</code>","text":"<p>Export the binary edge subgraph to a CSV [Comma-Separated Values] file.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>AnnNet instance to export. Must support <code>edges_view</code> with columns compatible with binary endpoints (e.g., 'source', 'target').</p> required <code>path</code> <code>str or Path</code> <p>Output path for the CSV file.</p> required <code>slice</code> <code>str</code> <p>Restrict the export to a specific slice. If None, all slices are exported.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>Only binary edges are exported. Hyperedges (edges connecting more than two   entities) are ignored.</li> <li>Output columns include: 'source', 'target', 'weight', 'directed', and 'slice'.</li> <li>If a weight column does not exist, a default weight of 1.0 is written.</li> <li>If a directedness column is absent, it will be written as <code>None</code>.</li> <li>This format is compatible with <code>load_csv_to_graph(schema=\"edge_list\")</code>.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.csv_io.export_hyperedge_csv","title":"<code>export_hyperedge_csv(G, path, slice=None, directed=None)</code>","text":"<p>Export hyperedges from the graph to a CSV [Comma-Separated Values] file.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>AnnNet</code> <p>AnnNet instance to export. Must support <code>edges_view</code> exposing either 'members' (for undirected hyperedges) or 'head'/'tail' (for directed hyperedges).</p> required <code>path</code> <code>str or Path</code> <p>Output path for the CSV file.</p> required <code>slice</code> <code>str</code> <p>Restrict the export to a specific slice. If None, all slices are exported.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Force treatment of hyperedges as directed or undirected. If None, the function attempts to infer directedness from the graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>If the graph exposes a 'members' column, the output will contain one row per   undirected hyperedge.</li> <li>If 'head' and 'tail' columns are present, the output will contain one row per   directed hyperedge. If <code>directed=False</code> is passed, 'head' and 'tail' are merged   into a 'members' column.</li> <li>A 'weight' column is included if available; otherwise, all weights default to 1.0.</li> <li>A 'slice' column is included if present or if <code>slice</code> is specified.</li> <li>This format is compatible with <code>load_csv_to_graph(schema=\"hyperedge\")</code>.</li> <li>If the graph does not expose hyperedge columns, a <code>ValueError</code> is raised.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_edge_list","title":"<code>_ingest_edge_list(df, G, default_slice, default_directed, default_weight)</code>","text":"<p>Parse edge-list-like tables (incl. COO/DOK).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_hyperedge","title":"<code>_ingest_hyperedge(df, G, default_slice, default_weight)</code>","text":"<p>Parse hyperedge tables (members OR head/tail).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_incidence","title":"<code>_ingest_incidence(df, G, default_slice, default_weight)</code>","text":"<p>Parse incidence matrices (first col = entity id, remaining numeric edge columns).</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_adjacency","title":"<code>_ingest_adjacency(df, G, default_slice, default_directed, default_weight)</code>","text":"<p>Parse adjacency matrices (square). If first column is non-numeric, treat as row labels.</p>"},{"location":"reference/interoperability/#annnet.io.csv_io._ingest_lil","title":"<code>_ingest_lil(df, G, default_slice, default_directed, default_weight)</code>","text":"<p>Parse LIL-style neighbor tables: one row per vertex with a neighbors column.</p>"},{"location":"reference/interoperability/#excel","title":"Excel","text":"Internal helpers"},{"location":"reference/interoperability/#annnet.io.excel","title":"<code>annnet.io.excel</code>","text":""},{"location":"reference/interoperability/#annnet.io.excel-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.excel.load_excel_to_graph","title":"<code>load_excel_to_graph(path, graph=None, schema='auto', sheet=None, default_slice=None, default_directed=None, default_weight=1.0, **kwargs)</code>","text":"<p>Load an Excel (.xlsx/.xls) file by converting it internally to CSV, then building a graph.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the Excel file.</p> required <code>graph</code> <code>AnnNet</code> <p>Existing graph instance. If None, a new one is created.</p> <code>None</code> <code>schema</code> <code>('auto', 'edge_list', 'hyperedge', 'incidence', 'adjacency', 'lil')</code> <p>AnnNet schema to assume or infer.</p> <code>'auto'</code> <code>sheet</code> <code>str</code> <p>Sheet name to load. Defaults to the first sheet.</p> <code>None</code> <code>default_slice</code> <code>str</code> <p>Default slice name if not present.</p> <code>None</code> <code>default_directed</code> <code>bool</code> <p>Default directedness if not present or inferrable.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight if no weight column exists.</p> <code>1.0</code> <code>**kwargs</code> <p>Extra keyword arguments passed to the graph constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>The created or augmented graph.</p> Notes <ul> <li>This function does not require <code>fastexcel</code> or <code>openpyxl</code>.</li> <li>The Excel is read once into memory and written to a temporary CSV, then processed with the CSV loader.</li> <li>Supported formats and schemas are identical to <code>load_csv_to_graph</code>.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.excel-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.excel.load_excel_to_graph","title":"<code>load_excel_to_graph(path, graph=None, schema='auto', sheet=None, default_slice=None, default_directed=None, default_weight=1.0, **kwargs)</code>","text":"<p>Load an Excel (.xlsx/.xls) file by converting it internally to CSV, then building a graph.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the Excel file.</p> required <code>graph</code> <code>AnnNet</code> <p>Existing graph instance. If None, a new one is created.</p> <code>None</code> <code>schema</code> <code>('auto', 'edge_list', 'hyperedge', 'incidence', 'adjacency', 'lil')</code> <p>AnnNet schema to assume or infer.</p> <code>'auto'</code> <code>sheet</code> <code>str</code> <p>Sheet name to load. Defaults to the first sheet.</p> <code>None</code> <code>default_slice</code> <code>str</code> <p>Default slice name if not present.</p> <code>None</code> <code>default_directed</code> <code>bool</code> <p>Default directedness if not present or inferrable.</p> <code>None</code> <code>default_weight</code> <code>float</code> <p>Default weight if no weight column exists.</p> <code>1.0</code> <code>**kwargs</code> <p>Extra keyword arguments passed to the graph constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>The created or augmented graph.</p> Notes <ul> <li>This function does not require <code>fastexcel</code> or <code>openpyxl</code>.</li> <li>The Excel is read once into memory and written to a temporary CSV, then processed with the CSV loader.</li> <li>Supported formats and schemas are identical to <code>load_csv_to_graph</code>.</li> </ul>"},{"location":"reference/interoperability/#dataframes-polarspandasnarwhals","title":"DataFrames (Polars/Pandas/Narwhals)","text":"Internal helpers"},{"location":"reference/interoperability/#annnet.io.dataframe_io","title":"<code>annnet.io.dataframe_io</code>","text":""},{"location":"reference/interoperability/#annnet.io.dataframe_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet-attributes","title":"Attributes","text":"<code>V</code> <code>property</code> <p>All vertices as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Vertex IDs.</p> <code>E</code> <code>property</code> <p>All edges as a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>Edge identifiers.</p> <code>num_vertices</code> <code>property</code> <p>Total number of vertices in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>num_edges</code> <code>property</code> <p>Total number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <code>nv</code> <code>property</code> <p>Shorthand for <code>num_vertices</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>ne</code> <code>property</code> <p>Shorthand for <code>num_edges</code>.</p> <p>Returns:</p> Type Description <code>int</code> <code>shape</code> <code>property</code> <p>AnnNet shape as a tuple: (num_vertices, num_edges).</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <code>nx</code> <code>property</code> <p>Lazy NetworkX proxy.</p> <p>Returns:</p> Type Description <code>_LazyNXProxy</code> <p>Proxy exposing NetworkX algorithms.</p> <code>ig</code> <code>property</code> <p>Lazy igraph proxy.</p> <p>Returns:</p> Type Description <code>_LazyIGProxy</code> <p>Proxy exposing igraph algorithms.</p> <code>gt</code> <code>property</code> <p>Lazy graph-tool proxy.</p> <p>Returns:</p> Type Description <code>_LazyGTProxy</code> <p>Proxy exposing graph-tool algorithms.</p> <code>obs</code> <code>property</code> <p>Vertex attribute table (observations).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>var</code> <code>property</code> <p>Edge attribute table (variables).</p> <p>Returns:</p> Type Description <code>DataFrame - like</code> <code>uns</code> <code>property</code> <p>Unstructured metadata.</p> <p>Returns:</p> Type Description <code>dict</code> <code>slices</code> <code>property</code> <p>Slice operations manager.</p> <p>Returns:</p> Type Description <code>SliceManager</code> <code>layers</code> <code>property</code> <p>Layer operations manager.</p> <p>Returns:</p> Type Description <code>LayerManager</code> <code>idx</code> <code>property</code> <p>Index lookups (entity_id&lt;-&gt;row, edge_id&lt;-&gt;col).</p> <p>Returns:</p> Type Description <code>IndexManager</code> <code>cache</code> <code>property</code> <p>Cache management (CSR/CSC materialization).</p> <p>Returns:</p> Type Description <code>CacheManager</code>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet-functions","title":"Functions","text":"<code>add_vertex(vertex_id, slice=None, layer=None, **attributes)</code> <p>Add (or upsert) a vertex and optionally attach it to a slice.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier (unique across entities).</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>layer</code> <code>str</code> <p>Layer label (used only in single-aspect mode).</p> <code>None</code> <code>**attributes</code> <p>Vertex attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID (echoed).</p> Notes <p>Ensures a row exists in the vertex attribute table and resizes the incidence matrix if needed.</p> <code>add_vertices(vertices, slice=None, **attributes)</code> <p>Add multiple vertices in a single call.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str] | Iterable[tuple[str, dict]] | Iterable[dict]</code> <p>Vertices to add. Each item can be: - <code>vertex_id</code> (str) - <code>(vertex_id, attrs)</code> tuple - dict containing <code>vertex_id</code> plus attributes</p> required <code>slice</code> <code>str</code> <p>Target slice. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Attributes applied to all vertices (merged with per-vertex attrs).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The vertex IDs added (in input order).</p> <code>add_edge_entity(edge_entity_id, slice=None, **attributes)</code> <p>Register a connectable edge-entity.</p> <p>Parameters:</p> Name Type Description Default <code>edge_entity_id</code> <code>str</code> <p>Identifier for the edge-entity.</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge-entity into. Defaults to the active slice.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge-entity ID.</p> Notes <p>Deprecated: prefer <code>add_edge(..., as_entity=True)</code>.</p> <code>add_edge(source, target, slice=None, weight=1.0, edge_id=None, as_entity=False, propagate='none', slice_weight=None, directed=None, edge_directed=None, **attributes)</code> <p>Add or update a binary edge between two entities.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID (vertex or edge entity).</p> required <code>target</code> <code>str</code> <p>Target entity ID (vertex or edge entity).</p> required <code>slice</code> <code>str</code> <p>Slice to place the edge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Global edge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>as_entity</code> <code>bool</code> <p>If True, this edge can be an endpoint of other edges.</p> <code>False</code> <code>propagate</code> <code>(none, shared, all)</code> <p>Slice propagation mode.</p> <code>'none'</code> <code>slice_weight</code> <code>float</code> <p>Per-slice weight override for this edge.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Global directedness override (legacy).</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Per-edge directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The edge ID (new or updated).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>propagate</code> is invalid.</p> <code>TypeError</code> <p>If <code>weight</code> is not numeric.</p> Notes <p>Directed edges write <code>+weight</code> at source and <code>-weight</code> at target. Undirected edges write <code>+weight</code> at both endpoints.</p> <code>add_parallel_edge(source, target, weight=1.0, **attributes)</code> <p>Add a parallel edge (same endpoints, different ID).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <code>weight</code> <code>float</code> <p>Edge weight stored in the incidence column.</p> <code>1.0</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The new edge ID.</p> <code>add_hyperedge(*, members=None, head=None, tail=None, slice=None, weight=1.0, edge_id=None, edge_directed=None, **attributes)</code> <p>Create a k-ary hyperedge as a single incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[str]</code> <p>Undirected members (&gt;= 2). Each member gets <code>+weight</code>.</p> <code>None</code> <code>head</code> <code>Iterable[str]</code> <p>Directed head set (sources). Each head gets <code>+weight</code>.</p> <code>None</code> <code>tail</code> <code>Iterable[str]</code> <p>Directed tail set (targets). Each tail gets <code>-weight</code>.</p> <code>None</code> <code>slice</code> <code>str</code> <p>Slice to place the hyperedge into. Defaults to the active slice.</p> <code>None</code> <code>weight</code> <code>float</code> <p>Hyperedge weight stored in the incidence column.</p> <code>1.0</code> <code>edge_id</code> <code>str</code> <p>Explicit edge ID. If omitted, a fresh ID is generated.</p> <code>None</code> <code>edge_directed</code> <code>bool</code> <p>Explicit directedness override.</p> <code>None</code> <code>**attributes</code> <p>Edge attributes to upsert.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The hyperedge ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If members/head/tail are inconsistent or invalid.</p> <code>set_hyperedge_coeffs(edge_id, coeffs)</code> <p>Write per-vertex coefficients into the incidence column.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Hyperedge ID to update.</p> required <code>coeffs</code> <code>dict[str, float]</code> <p>Mapping of vertex ID to coefficient value.</p> required <code>add_edge_to_slice(lid, eid)</code> <p>Attach an existing edge to a slice (no weight changes).</p> <p>Parameters:</p> Name Type Description Default <code>lid</code> <code>str</code> <p>Slice ID.</p> required <code>eid</code> <code>str</code> <p>Edge ID.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the slice does not exist.</p> <code>make_undirected(*, drop_flexible=True, update_default=True)</code> <p>Force the whole graph to be undirected in-place.</p> <p>Parameters:</p> Name Type Description Default <code>drop_flexible</code> <code>bool</code> <p>If True, clear flexible-direction policies.</p> <code>True</code> <code>update_default</code> <code>bool</code> <p>If True, set the graph default to undirected for future edges.</p> <code>True</code> Notes <p>Binary edges are rewritten to <code>(+w, +w)</code> at <code>(source, target)</code>. Hyperedges are rewritten to <code>+w</code> on all members.</p> <code>remove_edge(edge_id)</code> <p>Remove an edge (binary or hyperedge) from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge is not found.</p> Notes <p>Physically removes the incidence column (no CSR round-trip) and cleans edge attributes and slice memberships.</p> <code>remove_vertex(vertex_id)</code> <p>Remove a vertex and all incident edges (binary + hyperedges).</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the vertex is not found.</p> Notes <p>Rebuilds entity indexing and shrinks the incidence matrix accordingly.</p> <code>remove_slice(slice_id)</code> <p>Remove a non-default slice and its per-slice attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_id</code> <code>str</code> <p>Slice identifier.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove the internal default slice.</p> <code>KeyError</code> <p>If the slice does not exist.</p> Notes <p>Does not delete vertices or edges globally; only membership and metadata.</p> <code>get_vertex(index)</code> <p>Return the vertex ID corresponding to a given internal index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Internal vertex index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The vertex ID.</p> <code>get_edge(index)</code> <p>Return edge endpoints in a canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | str</code> <p>Internal edge index or edge ID.</p> required <p>Returns:</p> Type Description <code>tuple[frozenset, frozenset]</code> <p><code>(S, T)</code> where <code>S</code> and <code>T</code> are frozensets of vertex IDs.</p> <code>incident_edges(vertex_id)</code> <p>Return all edge indices incident to a given vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Edge indices incident to the vertex.</p> <code>has_edge(source=None, target=None, edge_id=None)</code> <p>Check edge existence using one of three modes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target entity ID.</p> <code>None</code> <code>edge_id</code> <code>str</code> <p>Edge identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | tuple[bool, list[str]]</code> <p>One of: - bool, if only <code>edge_id</code> is provided. - (bool, [edge_ids...]) if <code>source</code> and <code>target</code> are provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument combination is invalid.</p> <code>has_vertex(vertex_id)</code> <p>Test for the existence of a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex exists.</p> <code>get_edge_ids(source, target)</code> <p>List all edge IDs between two endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source entity ID.</p> required <code>target</code> <code>str</code> <p>Target entity ID.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs (may be empty).</p> <code>degree(entity_id)</code> <p>Degree of a vertex or edge-entity (number of incident non-zero entries).</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Degree of the entity.</p> <code>vertices()</code> <p>Get all vertex IDs (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Vertex IDs.</p> <code>edges()</code> <p>Get all edge IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Edge IDs.</p> <code>edge_list()</code> <p>Materialize (source, target, edge_id, weight) for binary/vertex-edge edges.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str, str, float]]</code> <p>Tuples of <code>(source, target, edge_id, weight)</code>.</p> <code>get_directed_edges()</code> <p>List IDs of directed edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Directed edge IDs.</p> <code>get_undirected_edges()</code> <p>List IDs of undirected edges.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Undirected edge IDs.</p> <code>number_of_vertices()</code> <p>Count vertices (excluding edge-entities).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of vertices.</p> <code>number_of_edges()</code> <p>Count edges (columns in the incidence matrix).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges.</p> <code>global_entity_count()</code> <p>Count unique entities present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of entities across slices.</p> <code>global_edge_count()</code> <p>Count unique edges present across all slices (union of memberships).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of edges across slices.</p> <code>in_edges(vertices)</code> <p>Iterate over all edges that are incoming to one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose target set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>in_edges()</code> and <code>out_edges()</code>.</p> <code>out_edges(vertices)</code> <p>Iterate over all edges that are outgoing from one or more vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str]</code> <p>Vertex ID or iterable of vertex IDs. All edges whose source set intersects with this set will be yielded.</p> required <p>Yields:</p> Type Description <code>tuple[int, tuple[frozenset, frozenset]]</code> <p><code>(edge_index, (S, T))</code> where <code>S</code> is sources/heads and <code>T</code> is targets/tails.</p> Notes <p>Works with binary and hyperedges. Undirected edges appear in both <code>out_edges()</code> and <code>in_edges()</code>.</p> <code>get_or_create_vertex_by_attrs(slice=None, **attrs)</code> <p>Return vertex ID for the given composite-key attributes.</p> <p>Parameters:</p> Name Type Description Default <code>slice</code> <code>str</code> <p>Slice to place a newly created vertex into.</p> <code>None</code> <code>**attrs</code> <p>Attributes used to build the composite key.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Vertex ID matching the composite key.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no composite key fields are configured.</p> <code>ValueError</code> <p>If required key fields are missing.</p> Notes <p>Requires <code>set_vertex_key(...)</code> to have been called.</p> <code>vertex_key_tuple(vertex_id)</code> <p>Return the composite-key tuple for a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_id</code> <code>str</code> <p>Vertex identifier.</p> required <p>Returns:</p> Type Description <code>tuple | None</code> <p>Composite key tuple, or None if incomplete or not configured.</p> <code>X()</code> <p>Sparse incidence matrix.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <code>write(path, **kwargs)</code> <p>Save to .annnet format (zero loss).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.write</code>.</p> <code>{}</code> <code>read(path, **kwargs)</code> <code>classmethod</code> <p>Load from .annnet format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Input file path.</p> required <code>**kwargs</code> <p>Passed to <code>annnet.io.io_annnet.read</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnnNet</code> <code>view(vertices=None, edges=None, slices=None, predicate=None)</code> <p>Create a lazy view/subgraph.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Iterable[str]</code> <p>Vertex IDs to include.</p> <code>None</code> <code>edges</code> <code>Iterable[str]</code> <p>Edge IDs to include.</p> <code>None</code> <code>slices</code> <code>Iterable[str]</code> <p>Slice IDs to include.</p> <code>None</code> <code>predicate</code> <code>callable</code> <p>Predicate applied to vertices/edges for filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphView</code> <code>snapshot(label=None)</code> <p>Create a named snapshot of current graph state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Human-readable label for the snapshot. Auto-generated if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Snapshot metadata.</p> <code>diff(a, b=None)</code> <p>Compare two snapshots or compare snapshot with current state.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str | dict | AnnNet</code> <p>First snapshot (label, snapshot dict, or AnnNet instance).</p> required <code>b</code> <code>str | dict | AnnNet | None</code> <p>Second snapshot. If None, compare with current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>GraphDiff</code> <p>Difference object with added/removed entities.</p> <code>list_snapshots()</code> <p>List all snapshots.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Snapshot metadata.</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.dataframe_io.to_dataframes","title":"<code>to_dataframes(graph, *, include_slices=True, include_hyperedges=True, explode_hyperedges=False, public_only=True)</code>","text":"<p>Export graph to Polars DataFrames.</p> <p>Returns a dictionary of DataFrames representing different aspects of the graph: - 'nodes': Vertex IDs and attributes - 'edges': Binary edges with source, target, weight, directed, attributes - 'hyperedges': Hyperedges with head/tail sets (if include_hyperedges=True) - 'slices': slice membership (if include_slices=True) - 'slice_weights': Per-slice edge weights (if include_slices=True)</p> <p>Note: Output is always Polars because hyperedges use List types which aren't universally supported across dataframe libraries.</p> <p>Args:     graph: AnnNet instance to export     include_slices: Include slice membership tables     include_hyperedges: Include hyperedge table     explode_hyperedges: If True, explode hyperedges to one row per endpoint     public_only: If True, filter out attributes starting with '__'</p> <p>Returns:     Dictionary mapping table names to Polars DataFrames</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io._to_dicts","title":"<code>_to_dicts(df)</code>","text":"<p>Convert narwhals DataFrame to list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io._get_height","title":"<code>_get_height(df)</code>","text":"<p>Get row count from narwhals DataFrame.</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.from_dataframes","title":"<code>from_dataframes(nodes=None, edges=None, hyperedges=None, slices=None, slice_weights=None, *, directed=None, exploded_hyperedges=False)</code>","text":"<p>Import graph from any DataFrame (Pandas, Polars, PyArrow, etc.).</p> <p>Accepts DataFrames in the format produced by to_dataframes():</p> <p>Nodes DataFrame (optional):     - Required: vertex_id     - Optional: any attribute columns</p> <p>Edges DataFrame (optional):     - Required: source, target     - Optional: edge_id, weight, directed, edge_type, attribute columns</p> <p>Hyperedges DataFrame (optional):     - Compact format: edge_id, directed, weight, head (list), tail (list), members (list)     - Exploded format: edge_id, vertex_id, role, weight, directed</p> <p>slices DataFrame (optional):     - Required: slice_id, edge_id</p> <p>slice_weights DataFrame (optional):     - Required: slice_id, edge_id, weight</p> <p>Args:     nodes: DataFrame with vertex_id and attributes (Pandas/Polars/PyArrow/etc.)     edges: DataFrame with binary edges     hyperedges: DataFrame with hyperedges     slices: DataFrame with slice membership     slice_weights: DataFrame with per-slice edge weights     directed: Default directedness (None = mixed graph)     exploded_hyperedges: If True, hyperedges DataFrame is in exploded format</p> <p>Returns:     AnnNet instance</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io-classes","title":"Classes","text":""},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io-functions","title":"Functions","text":""},{"location":"reference/interoperability/#annnet.io.dataframe_io.to_dataframes","title":"<code>to_dataframes(graph, *, include_slices=True, include_hyperedges=True, explode_hyperedges=False, public_only=True)</code>","text":"<p>Export graph to Polars DataFrames.</p> <p>Returns a dictionary of DataFrames representing different aspects of the graph: - 'nodes': Vertex IDs and attributes - 'edges': Binary edges with source, target, weight, directed, attributes - 'hyperedges': Hyperedges with head/tail sets (if include_hyperedges=True) - 'slices': slice membership (if include_slices=True) - 'slice_weights': Per-slice edge weights (if include_slices=True)</p> <p>Note: Output is always Polars because hyperedges use List types which aren't universally supported across dataframe libraries.</p> <p>Args:     graph: AnnNet instance to export     include_slices: Include slice membership tables     include_hyperedges: Include hyperedge table     explode_hyperedges: If True, explode hyperedges to one row per endpoint     public_only: If True, filter out attributes starting with '__'</p> <p>Returns:     Dictionary mapping table names to Polars DataFrames</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io._to_dicts","title":"<code>_to_dicts(df)</code>","text":"<p>Convert narwhals DataFrame to list of dicts.</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io._get_height","title":"<code>_get_height(df)</code>","text":"<p>Get row count from narwhals DataFrame.</p>"},{"location":"reference/interoperability/#annnet.io.dataframe_io.from_dataframes","title":"<code>from_dataframes(nodes=None, edges=None, hyperedges=None, slices=None, slice_weights=None, *, directed=None, exploded_hyperedges=False)</code>","text":"<p>Import graph from any DataFrame (Pandas, Polars, PyArrow, etc.).</p> <p>Accepts DataFrames in the format produced by to_dataframes():</p> <p>Nodes DataFrame (optional):     - Required: vertex_id     - Optional: any attribute columns</p> <p>Edges DataFrame (optional):     - Required: source, target     - Optional: edge_id, weight, directed, edge_type, attribute columns</p> <p>Hyperedges DataFrame (optional):     - Compact format: edge_id, directed, weight, head (list), tail (list), members (list)     - Exploded format: edge_id, vertex_id, role, weight, directed</p> <p>slices DataFrame (optional):     - Required: slice_id, edge_id</p> <p>slice_weights DataFrame (optional):     - Required: slice_id, edge_id, weight</p> <p>Args:     nodes: DataFrame with vertex_id and attributes (Pandas/Polars/PyArrow/etc.)     edges: DataFrame with binary edges     hyperedges: DataFrame with hyperedges     slices: DataFrame with slice membership     slice_weights: DataFrame with per-slice edge weights     directed: Default directedness (None = mixed graph)     exploded_hyperedges: If True, hyperedges DataFrame is in exploded format</p> <p>Returns:     AnnNet instance</p>"},{"location":"reference/storage/","title":"Disk Storage (.annnet)","text":"<p>The <code>.annnet</code> format is a lossless on-disk representation built on Zarr + Parquet + JSON. This page documents the primary read/write API.</p>"},{"location":"reference/storage/#annnet-format","title":"AnnNet Format","text":"Internal helpers"},{"location":"reference/storage/#annnet.io.io_annnet.write","title":"<code>annnet.io.io_annnet.write(graph, path, *, compression='zstd', overwrite=False)</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet.read","title":"<code>annnet.io.io_annnet.read(path, *, lazy=False)</code>","text":"<p>Load graph from disk with zero loss.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to .annnet directory</p> required <code>lazy</code> <code>bool</code> <p>If True, delay loading large arrays until accessed</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Reconstructed graph with all topology and metadata</p>"},{"location":"reference/storage/#annnet.io.io_annnet-attributes","title":"Attributes","text":""},{"location":"reference/storage/#annnet.io.io_annnet.ANNNET_EXT","title":"<code>ANNNET_EXT = 'graph.annnet'</code>  <code>module-attribute</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet-classes","title":"Classes","text":""},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet-functions","title":"Functions","text":""},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/storage/#annnet.io.io_annnet.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/storage/#annnet.io.io_annnet-functions","title":"Functions","text":""},{"location":"reference/storage/#annnet.io.io_annnet._read_archive","title":"<code>_read_archive(infile, tmpdir)</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet._write_archive","title":"<code>_write_archive(src_dir, outfile)</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet._write_cache","title":"<code>_write_cache(*args, **kwargs)</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet._have_polars","title":"<code>_have_polars()</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet._df_from_dict","title":"<code>_df_from_dict(data)</code>","text":"<p>Create a DataFrame from dict-of-columns using: - polars if available - else pandas</p>"},{"location":"reference/storage/#annnet.io.io_annnet._write_parquet_df","title":"<code>_write_parquet_df(df, path, *, compression='zstd')</code>","text":"<p>Write a dataframe-like object to parquet: - polars DataFrame: df.write_parquet - pandas DataFrame: df.to_parquet(engine=\"pyarrow\") - anything else: try narwhals -&gt; pandas</p>"},{"location":"reference/storage/#annnet.io.io_annnet._read_parquet","title":"<code>_read_parquet(path)</code>","text":"<p>Read parquet into: - polars DataFrame if available - else pandas DataFrame</p>"},{"location":"reference/storage/#annnet.io.io_annnet._iter_rows","title":"<code>_iter_rows(df)</code>","text":"<p>Return rows as list[dict] for both:   - polars DataFrame: .to_dicts()   - pandas DataFrame: .to_dict(orient=\"records\")</p>"},{"location":"reference/storage/#annnet.io.io_annnet._write_dir","title":"<code>_write_dir(graph, path, *, compression='zstd', overwrite=False)</code>","text":"<p>Write graph to disk with zero topology loss.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Target directory (e.g., \"my_graph.annnet\")</p> required <code>compression</code> <code>str</code> <p>Compression codec for Zarr/Parquet</p> <code>\"zstd\"</code> <code>overwrite</code> <code>bool</code> <p>Allow overwriting existing directory</p> <code>False</code> Notes <p>Creates a self-contained directory with: - Zarr arrays for sparse matrices - Parquet tables for attributes/metadata - JSON for unstructured data</p>"},{"location":"reference/storage/#annnet.io.io_annnet.write","title":"<code>write(graph, path, *, compression='zstd', overwrite=False)</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet._write_structure","title":"<code>_write_structure(graph, path, compression)</code>","text":"<p>Write sparse incidence matrix + all index mappings.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._write_tables","title":"<code>_write_tables(graph, path, compression)</code>","text":""},{"location":"reference/storage/#annnet.io.io_annnet._write_multilayers","title":"<code>_write_multilayers(graph, path, compression)</code>","text":"<p>Write Kivela multilayer structures to disk.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._write_slices","title":"<code>_write_slices(graph, path, compression)</code>","text":"<p>Write slice registry and memberships.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._write_audit","title":"<code>_write_audit(graph, path, compression)</code>","text":"<p>Write history, snapshots, provenance.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._write_uns","title":"<code>_write_uns(graph, path)</code>","text":"<p>Write unstructured metadata and results.</p>"},{"location":"reference/storage/#annnet.io.io_annnet.read","title":"<code>read(path, *, lazy=False)</code>","text":"<p>Load graph from disk with zero loss.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to .annnet directory</p> required <code>lazy</code> <code>bool</code> <p>If True, delay loading large arrays until accessed</p> <code>False</code> <p>Returns:</p> Type Description <code>AnnNet</code> <p>Reconstructed graph with all topology and metadata</p>"},{"location":"reference/storage/#annnet.io.io_annnet._load_structure","title":"<code>_load_structure(graph, path, lazy)</code>","text":"<p>Load sparse matrix and index mappings.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._load_tables","title":"<code>_load_tables(graph, path)</code>","text":"<p>Load Polars DataFrames.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._load_multilayers","title":"<code>_load_multilayers(graph, path)</code>","text":"<p>Load Kivela multilayer structures.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._load_slices","title":"<code>_load_slices(graph, path)</code>","text":"<p>Reconstruct slice registry and memberships.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._load_audit","title":"<code>_load_audit(graph, path)</code>","text":"<p>Load history and provenance.</p>"},{"location":"reference/storage/#annnet.io.io_annnet._load_uns","title":"<code>_load_uns(graph, path)</code>","text":"<p>Load unstructured metadata.</p>"},{"location":"reference/storage/#parquet-graphdir-lossless","title":"Parquet GraphDir (Lossless)","text":"Internal helpers"},{"location":"reference/storage/#annnet.io.Parquet_io.to_parquet","title":"<code>annnet.io.Parquet_io.to_parquet(graph, path)</code>","text":"<p>Write lossless GraphDir:   vertices.parquet, edges.parquet, slices.parquet, edge_slices.parquet, manifest.json Wide tables (attrs as columns). Hyperedges stored with 'kind' and head/tail/members lists.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io.from_parquet","title":"<code>annnet.io.Parquet_io.from_parquet(path)</code>","text":"<p>Read GraphDir (lossless) using bulk ops for speed.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io-classes","title":"Classes","text":""},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet","title":"<code>AnnNet</code>","text":"<p>Sparse incidence-matrix graph with slices, attributes, parallel edges, and hyperedges.</p> <p>The graph is backed by a DOK (Dictionary Of Keys) sparse matrix and exposes sliceed views and attribute tables stored as Polars DF (DataFrame). Supports: vertices, binary edges (directed/undirected), edge-entities (vertex-edge hybrids), k-ary hyperedges (directed/undirected), per-slice membership and weights, and Polars-backed attribute upserts.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Whether edges are directed by default. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Incidence columns encode orientation: +w on source/head, \u2212w on target/tail for   directed edges; +w on all members for undirected edges/hyperedges.</li> <li>Attributes are pure: structural keys are filtered out so attribute tables   contain only user data.</li> </ul> <p>See Also</p> <p>add_vertex, add_edge, add_hyperedge, edges_view, vertices_view, slices_view</p>"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet-functions","title":"Functions","text":""},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet.__init__","title":"<code>__init__(directed=None, n=0, e=0, annotations=None, annotations_backend='polars', **kwargs)</code>","text":"<p>Initialize an empty incidence-matrix graph.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <code>bool</code> <p>Global default for edge directionality. Individual edges can override this.</p> <code>None</code> Notes <ul> <li>Stores entities (vertices and edge-entities), edges (including parallels), and an incidence matrix in DOK (Dictionary Of Keys) sparse format.</li> <li>Attribute tables are Polars DF (DataFrame) with canonical key columns: <code>vertex_attributes(vertex_id)</code>, <code>edge_attributes(edge_id)</code>, <code>slice_attributes(slice_id)</code>, and <code>edge_slice_attributes(slice_id, edge_id, weight)</code>.</li> <li>A <code>'default'</code> slice is created and set active.</li> </ul>"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet._register_edge_as_entity","title":"<code>_register_edge_as_entity(edge_id)</code>","text":"<p>Make an existing edge connectable as an endpoint.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet._propagate_to_shared_slices","title":"<code>_propagate_to_shared_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to all slices that already contain both endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet._propagate_to_all_slices","title":"<code>_propagate_to_all_slices(edge_id, source, target)</code>","text":"<p>INTERNAL: Add an edge to any slice containing either endpoint and insert the missing endpoint into that slice.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <code>source</code> <code>str</code> required <code>target</code> <code>str</code> required"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet._normalize_vertices_arg","title":"<code>_normalize_vertices_arg(vertices)</code>","text":"<p>Normalize a single vertex or an iterable of vertices into a set.</p> <p>This internal utility function standardizes input for methods like <code>in_edges()</code> and <code>out_edges()</code> by converting the argument into a set of vertex identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>str | Iterable[str] | None</code> <ul> <li>A single vertex ID (string).</li> <li>An iterable of vertex IDs (e.g., list, tuple, set).</li> <li><code>None</code> is allowed and will return an empty set.</li> </ul> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of vertex identifiers. If <code>vertices</code> is <code>None</code>, returns an empty set. If a single vertex is provided, returns a one-element set.</p> Notes <ul> <li>Strings are treated as single vertex IDs, not iterables.</li> <li>If the argument is neither iterable nor a string, it is wrapped in a set.</li> <li>Used internally by API methods that accept flexible vertex arguments.</li> </ul>"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet._is_directed_edge","title":"<code>_is_directed_edge(edge_id)</code>","text":"<p>Check if an edge is directed (per-edge flag overrides graph default).</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet._resolve_snapshot","title":"<code>_resolve_snapshot(ref)</code>","text":"<p>Resolve snapshot reference (label, dict, or AnnNet).</p>"},{"location":"reference/storage/#annnet.io.Parquet_io.AnnNet._current_snapshot","title":"<code>_current_snapshot()</code>","text":"<p>Create snapshot of current state (uses AnnNet attributes).</p>"},{"location":"reference/storage/#annnet.io.Parquet_io-functions","title":"Functions","text":""},{"location":"reference/storage/#annnet.io.Parquet_io._deserialize_edge_layers","title":"<code>_deserialize_edge_layers(data)</code>","text":"<p>Inverse of _serialize_edge_layers.</p> <p>Returns eid -&gt; aa or (aa, bb) (tuples).</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._deserialize_layer_tuple_attrs","title":"<code>_deserialize_layer_tuple_attrs(data)</code>","text":"<p>Inverse of _serialize_layer_tuple_attrs.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._deserialize_node_layer_attrs","title":"<code>_deserialize_node_layer_attrs(data)</code>","text":"<p>Inverse of _serialize_node_layer_attrs.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._deserialize_VM","title":"<code>_deserialize_VM(data)</code>","text":"<p>Inverse of _serialize_VM.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._safe_df_to_rows","title":"<code>_safe_df_to_rows(df)</code>","text":"<p>Return list[dict] rows from polars/pandas/narwhals; return [] on None/empty/unknown.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._serialize_edge_layers","title":"<code>_serialize_edge_layers(edge_layers)</code>","text":"<p>Convert edge_layers[eid] (aa or (aa, bb)) into JSON-safe form.</p> <ul> <li>intra:  aa -&gt; {\"kind\": \"single\", \"layers\": [list(aa)]}</li> <li>inter/coupling: (aa, bb) -&gt; {\"kind\": \"pair\", \"layers\": [list(aa), list(bb)]}</li> </ul>"},{"location":"reference/storage/#annnet.io.Parquet_io._serialize_layer_tuple_attrs","title":"<code>_serialize_layer_tuple_attrs(layer_attrs)</code>","text":"<p>_layer_attrs: {aa_tuple -&gt; {attr_name: value}} -&gt; JSON-safe: [{\"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._serialize_node_layer_attrs","title":"<code>_serialize_node_layer_attrs(nl_attrs)</code>","text":"<p>(u, aa) -&gt; {attrs}  -&gt;  [{\"node\": u, \"layer\": list(aa), \"attrs\": {...}}, ...]</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._serialize_VM","title":"<code>_serialize_VM(VM)</code>","text":"<p>Serialize V_M = {(u, aa)} to JSON-safe list of dicts.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._iter_rows","title":"<code>_iter_rows(df)</code>","text":"<p>Return rows as list[dict] for both:   - polars DataFrame: .to_dicts()   - pandas DataFrame: .to_dict(orient=\"records\")</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._read_parquet","title":"<code>_read_parquet(path)</code>","text":"<p>Read parquet into: - polars DataFrame if available - else pandas DataFrame</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._write_parquet_df","title":"<code>_write_parquet_df(df, path, *, compression='zstd')</code>","text":"<p>Write a dataframe-like object to parquet: - polars DataFrame: df.write_parquet - pandas DataFrame: df.to_parquet(engine=\"pyarrow\") - anything else: try narwhals -&gt; pandas</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._build_dataframe_from_rows","title":"<code>_build_dataframe_from_rows(rows)</code>","text":"<p>Build a DataFrame from a list of row records using available backends.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io.pd_build_dataframe_from_rows","title":"<code>pd_build_dataframe_from_rows(rows)</code>","text":"<p>Build a DataFrame from a list of row records using available backends.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._strip_nulls","title":"<code>_strip_nulls(d)</code>","text":""},{"location":"reference/storage/#annnet.io.Parquet_io._is_directed_eid","title":"<code>_is_directed_eid(graph, eid)</code>","text":"<p>Get edge directedness. Default False for hyperedges, True for binary.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._coerce_coeff_mapping","title":"<code>_coerce_coeff_mapping(val)</code>","text":"<p>Normalize various serialized forms into {vertex: {__value: float}|float}. Accepts dict | list | list-of-dicts | list-of-pairs | JSON string.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._is_nullish","title":"<code>_is_nullish(val)</code>","text":""},{"location":"reference/storage/#annnet.io.Parquet_io._as_list_or_empty","title":"<code>_as_list_or_empty(val)</code>","text":""},{"location":"reference/storage/#annnet.io.Parquet_io._endpoint_coeff_map","title":"<code>_endpoint_coeff_map(edge_attrs, private_key, endpoint_set)</code>","text":"<p>Return {vertex: float_coeff} for the given endpoint_set. Reads from edge_attrs[private_key] which may be serialized in multiple shapes. Missing endpoints default to 1.0.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io._build_attr_map","title":"<code>_build_attr_map(df, key_col)</code>","text":"<p>Build {key: attrs} mapping from a dataframe-like table.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io.to_parquet","title":"<code>to_parquet(graph, path)</code>","text":"<p>Write lossless GraphDir:   vertices.parquet, edges.parquet, slices.parquet, edge_slices.parquet, manifest.json Wide tables (attrs as columns). Hyperedges stored with 'kind' and head/tail/members lists.</p>"},{"location":"reference/storage/#annnet.io.Parquet_io.from_parquet","title":"<code>from_parquet(path)</code>","text":"<p>Read GraphDir (lossless) using bulk ops for speed.</p>"},{"location":"reference/source/annnet/_metadata-docs/","title":"metadata docs","text":""},{"location":"reference/source/annnet/_metadata-docs/#description","title":"Description","text":"<p>The <code>_metadata.py</code> file defines the structures and logic for handling metadata associated with cached items in the <code>annnet</code> package. It provides classes and helper functions to manage, store, and retrieve metadata fields, ensuring that each cache entry can be enriched with flexible, structured, and queryable information. This enables advanced search, filtering, and organization of cached data based on user-defined or system-generated metadata.</p>"},{"location":"reference/source/annnet/_metadata-docs/#main-components","title":"Main Components","text":"<ul> <li>Metadata Function:   Encapsulates the metadata for a cache item, providing methods to set, get, update, and validate metadata fields.</li> </ul> <p>Package metadata (version, authors, etc).</p>"},{"location":"reference/source/annnet/_metadata-docs/#annnet._metadata-functions","title":"Functions","text":""},{"location":"reference/source/annnet/_metadata-docs/#annnet._metadata.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Basic package metadata.</p> <p>Retrieves package metadata from the current project directory or from the installed package.</p>"}]}