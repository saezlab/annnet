import inspect

import graph_tool as gt
import graph_tool.centrality
import graph_tool.clustering
import graph_tool.flow
import graph_tool.generation
import graph_tool.inference
import graph_tool.search
import graph_tool.topology
import graph_tool.util

OUTPUT_FILE = "gt_proxy_autogen.py"

NAMESPACES = {
    "topology": graph_tool.topology,
    "centrality": graph_tool.centrality,
    "clustering": graph_tool.clustering,
    "flow": graph_tool.flow,
    "inference": graph_tool.inference,
    "generation": graph_tool.generation,
    "search": graph_tool.search,
    "util": graph_tool.util,
}


def build_method(func_name):
    """
    Creates an autogen wrapper:

        def shortest_distance(self, *args, **kwargs):
            return self.__getattr__("shortest_distance")(*args, **kwargs)
    """

    return f"""    def {func_name}(self, *args, **kwargs):
        return self.__getattr__("{func_name}")(*args, **kwargs)
"""


def generate_namespace_class(name, module):
    """
    Generates:

        class _GTNamespaceAutogen_topology:
            def shortest_distance(...):
            ...
    """

    methods = []

    for attr in dir(module):
        if attr.startswith("_"):
            continue  # skip private
        obj = getattr(module, attr)
        if callable(obj):
            methods.append(build_method(attr))

    methods_text = "".join(methods)

    cls = f"""
class _GTNamespaceAutogen_{name}:
{methods_text or "    pass"}
"""
    return cls


def generate_autogen_file():
    blocks = []

    for name, module in NAMESPACES.items():
        blocks.append(generate_namespace_class(name, module))

    header = '''"""
AUTO-GENERATED FILE â€” DO NOT EDIT
Generated by generate_gt_proxy.py
Provides autocomplete wrappers for graph-tool namespaces.
"""
'''

    full_text = header + "\n\n".join(blocks)

    with open(OUTPUT_FILE, "w", encoding="utf8") as f:
        f.write(full_text)

    print(f"Wrote {OUTPUT_FILE}")


if __name__ == "__main__":
    generate_autogen_file()
